<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[某三消游戏逆向(1)——lua脚本解密]]></title>
    <url>%2F2021%2F04%2F12%2F%E6%9F%90%E4%B8%89%E6%B6%88%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%2F</url>
    <content type="text"><![CDATA[文件分析确定分析对象解压apk安装包，进入./lib目录，都是.so的底层库。 1234567891011121314151617181920212223242526lib39285EFA.so //移动安全联盟 OAID SDK 广告服务等 libsgcore.so //快手libBugly.so //腾讯Bugly crash监控 libhegame.so //游戏逻辑 libtobEmbedEncrypt.so //bytedance广告libCtaApiLib.so //极光JVerification Android SDK libtquic.so //quic协议？libShanYCore.so //闪验Flutterlibiconv.so //多语言编码 libtraeimp-rtmp.so //腾讯云移动直播libbuffer_pg.so //字节libindoor.so //百度室内定位 libtxffmpeg.so //ffmpeglibc++_shared.so libkwad_common.so libtxplayer.so //腾讯云短视频libcostquic.so //quic协议？ libliteavsdk.so //移动直播sdk libtxsdl.so //腾讯sdl？libfile_lock_pg.so liblocSDK7b.so //百度定位？libweibosdkcore.so //微博libmarsstn.so //微信Mars 跨平台基础架构组件 libzbarjni.so //Zbar读取条码libmarsxlog.so //微信Mars 跨平台基础架构组件 libnms.so //对象检测 用ida打开可疑的libhegame.so 看到函数的名字有大量的lua ，可以知道开心消消乐使用的lua引擎（和网上搜索得到的信息一致）assert/src 目录下是lua脚本，有经过加密，需要对.so文件进行分析找到密钥。 分析libhegame.so方法名里搜索“lua”，可以看到都是jni的方法。 查看j_Java_com_happyelements_test_TestService_initLua 方法，一路跟进sub_6EA84。 可以看到初始化lua的方法应该是com/happyelements/android/LuaHelper类里的initLuaEnv()方法. 全文搜索“load_lua”，可以看到方法sub_106B0C(),根据调试信息可以看出此方法为加载lua文件的地方。 其中sub_569864 为读取lua文件，sub_95C00 为解码，sub_97670为解压缩 sub_95C00 -&gt; sub_95C18 从调试信息 推测sub_95C18为openssl的EVP解码算法。 动态调试frida hook sub_95C00方法js脚本内容为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function get_func_addr(module, offset) &#123; var base_addr = Module.findBaseAddress(module); console.log(&quot;base_addr: &quot; + base_addr); console.log(hexdump(ptr(base_addr), &#123; length: 16, header: true, ansi: true &#125;)) var func_addr = base_addr.add(offset); if (Process.arch == &apos;arm&apos;) return func_addr.add(1); //如果是32位地址+1 else return func_addr;&#125; //var func_addr = get_func_addr(&apos;libhegame.so&apos;, 0x97670); var func_addr = get_func_addr(&apos;libhegame.so&apos;, 0x95C00); console.log(&apos;func_addr: &apos; + func_addr); console.log(hexdump(ptr(func_addr), &#123; length: 16, header: true, ansi: true &#125;)) Interceptor.attach(ptr(func_addr), &#123; onEnter: function(args) &#123; console.log(&quot;onEnter&quot;); var num1 = args[0]; var num2 = args[1]; console.log(&quot;num1: &quot; + num1); console.log(&quot;num2: &quot; + num2); console.log(hexdump(ptr(num1), &#123; length: 16, header: true, ansi: true &#125;)) &#125;, onLeave: function(retval) &#123; console.log(&quot;onLeave&quot;); //retval.replace(3); //返回值替换成3 console.log(&quot;return: &quot; + retval); &#125;&#125;); 可以看到密钥为e9 74 7d 92 cc 32 2e 7d 11 2e 7c 34 51 d7 b3 6a 解码lua文件123456789101112131415#coding=UTF-8import Cryptoimport zlibfrom Crypto.Cipher import AESdef decdata(c): key=b&apos;\xe9\x74\x7d\x92\xcc\x32\x2e\x7d\x11\x2e\x7c\x34\x51\xd7\xb3\x6a&apos; iv=c[0:16] main_data=c[16:] cryptor = AES.new(key,AES.MODE_CBC,iv) pad_compress_data=cryptor.decrypt(main_data) str_len=len(pad_compress_data) pad=pad_compress_data[-1] compress_data=pad_compress_data[0:str_len-pad] plain_text = zlib.decompress(compress_data) return plain_text]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>Android</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac10.14编译Lineage16.0 for Xiaomi6(sagit)]]></title>
    <url>%2F2021%2F03%2F10%2FMac10-14%E7%BC%96%E8%AF%91Lineage16-0-for-Xiaomi6-sagit%2F</url>
    <content type="text"><![CDATA[由于内网服务器各种不方便，最后选择购入1T的移动SSD在本地编译了。虚拟机的话需要本机至少24G内存，条件不满足；而且安卓代码对MAC的支持比较友好了，所以决定就在mac环境下编译啦 lineage16.0不再支持小米6，因此换成17.1 ：https://www.lineageoslog.com/16.0/sagit 准备磁盘三星T5 SSD 使用MAC的磁盘工具重新挂载后抹除 ，使磁盘可写，可区分大小写 repo工具下载及添加到环境变量使用清华的镜像源 123456789​mkdir ~/bin​#本地下载repo，使用jumper的上传下到服务器上curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; /bin/repo/chmod a+x ~/bin/repo​export REPO_URL=&apos;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&apos;export PATH=~/bin:$PATH 代码同步 创建一个大小写敏感的分区,或者创建一个大小写敏感的镜像文件,用来存放 同步下来的源码. 进入存放源码的路径 在当前路径下初始化源码仓库: 1repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/lineageOS/LineageOS/android.git -b lineage-16.0 打开.repo/manifest.xml，将 123&lt;remote name=&quot;github&quot; fetch=&quot;..&quot; review=&quot;review.lineageos.org&quot; /&gt; 改成 12345&lt;remote name=&quot;github&quot; fetch=&quot;https://github.com/&quot; /&gt; &lt;remote name=&quot;lineage&quot; fetch=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/lineageOS/&quot; review=&quot;review.lineageos.org&quot; /&gt; 将 12&lt;remote name=&quot;aosp&quot; fetch=&quot;https://android.googlesource.com&quot; 改成 12&lt;remote name=&quot;aosp&quot; fetch=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/AOSP&quot; 将 12&lt;default revision=&quot;...&quot; remote=&quot;github&quot; 改成 12&lt;default revision=&quot;...&quot; remote=&quot;lineage&quot; 同步源码树（以后只需执行这条命令来同步）：123456789repo sync -j8 -c​#若出现error: Exited sync due to fetch errors#使用repo sync -j8 -f --force-sync​#若出现bundle错误#使用repo sync -j8 --no-clone-bundle 快速同步或直接下载repo包，解压后cd到lineage目录 直接执行repo sync -l提取源码 安装依赖1234567891011121314151617181920212223242526272829303132333435363738brew install findutilsbrew install gpgbrew install Imagemagick​#sedbrew install gnu-sed export PATH=/usr/local/opt/findutils/libexec/gnubin:/usr/local/opt/gnu-sed/libexec/gnubin:$PATH​#安装 Xcode 命令行工具：xcode-select --install​#通过 macports.org 安装 MacPorts。#https://www.macports.org/install.php​export PATH=/opt/local/bin:$PATH​#通过 MacPorts 获取 Make、Git 和 GPG 程序包：sudo port -d syncPOSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg​#设置文件描述符数量上限vim ~/.bash_profile#添加此行# set the number of open files to be 1024ulimit -S -n 1024​​#优化编译环境brew install Ccache​在源代码树的根目录下执行以下命令：export USE_CCACHE=1export CCACHE_DIR=/Volumes/Samsung_T5/android/build_cache/.ccacheexport CCACHE_COMPRESS=1ccache -M 100G​#errorexport ALLOW_MISSING_DEPENDENCIES=true idea源码阅读源码根目录执行 12mmma development/tools/idegen/#在/out/host/darwin-x86/framework下生成idegen.jar 问题与解决出现error 缺少macos10.14的sdk，到https://github.com/phracker/MacOSX-SDKs/releases/tag/10.15 下载 ,放到/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs下。 出现error:device/xiaomi/sagit/rro_overlays/SagitWifiOverlay/Android.bp:1:1: unrecognized module type “runtime_resource_overlay”，把/device/xiaomi/sagit/rro_overlays/SagitWifiOverlay 目录删除。 遇到 1brew install error：python@3.9: undefined method `on_macos&apos; for #&lt;PourBottleCheck:0x00007f86e80a3220&gt; 执行 brew update -v 运行无误生成 out/host/darwin-x86/framework/idegen.jar 执行123cd croot​./development/tools/idegen/idegen.sh 会在源代码根目录生成下列文件 123456// 用于IntelliJ IDEA的项目配置文件android.iprandroid.iml​// 用于Eclipse的项目配置文件.classpath 使用IntelliJ IDEA，则打开工程，浏览选择刚才生成的android.ipr文件即可。 xiaomi6 vendor包android_proprietary_vendor_xiaomi_sagit android_vendor_xiaomi_msm8998-common 放到vendor/xiaomi/ 目录下 目录名分别为 msm8998-common 和sagithttps://wiki.lineageos.org/devices/dipper/build#extract-proprietary-blobs 从设备提取 编译修改.repo/local_manifest/roomservice.xml ,增加以下 1234&lt;project name=&quot;LineageOS/android_device_xiaomi_sagit&quot; path=&quot;device/xiaomi/sagit&quot; remote=&quot;github&quot; /&gt;&lt;project name=&quot;LineageOS/android_device_xiaomi_msm8998-common&quot; path=&quot;device/xiaomi/msm8998-common&quot; remote=&quot;github&quot; /&gt;&lt;project name=&quot;LineageOS/android_kernel_xiaomi_msm8998&quot; path=&quot;kernel/xiaomi/msm8998&quot; remote=&quot;github&quot; /&gt;&lt;project name=&quot;xiaomi-msm8998/vendor_xiaomi&quot; path=&quot;vendor/xiaomi&quot; remote=&quot;github&quot; /&gt; 再repo sync 1234567source build/envsetup.sh​breakfast sagit​croot​brunch sagit 如果出现python相关的错，记得把python切换到python2]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Android</tag>
        <tag>Lineage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用yolo3-tf2训练自己的数据集]]></title>
    <url>%2F2021%2F02%2F07%2F%E4%BD%BF%E7%94%A8yolo3-tf2%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[配置环境下载yolo工程yolov3-tf2地址：https://github.com/zzh8829/yolov3-tf2 12git clone https://github.com/zzh8829/yolov3-tf2 yolov3-tf2cd yolov3-tf2 建立conda环境1234567# Tensorflow CPUconda env create -f conda-cpu.ymlconda activate yolov3-tf2-cpu​# Tensorflow GPUconda env create -f conda-gpu.ymlconda activate yolov3-tf2-gpu 下载权重文件并验证123wget https://pjreddie.com/media/files/yolov3.weights -O data/yolov3.weightspython convert.pypython detect.py --image ./data/meme.jpg # Sanity check 制作VOC数据集目录： VOC Annotations #存放xml文件，可使用LabelImg生成 JPEGImages #存放图片 ImageSets Main test.txt train.txt trainval.txt val.txt 执行python make.py 在Main 下生成四个txt 123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding：utf-8 -*-​import os import random ​trainval_percent = 0.6 # 自己设定（训练集+验证集）所占（训练集+验证集+测试集）的比重 train_percent = 0.7 # 自己设定（训练集）所占（训练集+验证集）的比重xmlfilepath = &apos;Annotations&apos; #注意自己地址是否正确txtsavepath = &apos;ImageSets/Main&apos; #注意自己地址是否正确total_xml = os.listdir(xmlfilepath) ​num = len(total_xml) print(num)list = range(num) tv = int(num*trainval_percent) tr = int(tv*train_percent) trainval = random.sample(list,tv) train = random.sample(trainval,tr) ​ftrainval = open(&apos;ImageSets/Main/trainval.txt&apos;, &apos;w&apos;)ftest = open(&apos;ImageSets/Main/test.txt&apos;, &apos;w&apos;)ftrain = open(&apos;ImageSets/Main/train.txt&apos;, &apos;w&apos;)fval = open(&apos;ImageSets/Main/val.txt&apos;, &apos;w&apos;)​for i in list: name = total_xml[i][:-4]+&apos;\n&apos; #print(name) if i in trainval: ftrainval.write(name) if i in train: ftrain.write(name) else: fval.write(name) else: ftest.write(name) ​ftrainval.close() ftrain.close() fval.close() ftest.close()print(&apos;Done&apos;)​ 建立标签.names文件在data文件夹下，写入的就是自己要训练的类别 生成tfrecord文件训练集 12345python tools/voc2012.py \ --data_dir &apos;./data/voc-5h&apos; \ --split train \ --output_file ./data/voc5h_train.tfrecord \ --classes ./data/voc-5h.names 测试集 12345python tools/voc2012.py \ --data_dir &apos;./data/voc-5h&apos; \ --split val \ --output_file ./data/voc5h_val.tfrecord \ --classes ./data/voc-5h.names 训练进行迁移训练12345678910python train.py \ --dataset ./data/voc5h_train.tfrecord \ --val_dataset ./data/voc5h_val.tfrecord \ --classes ./data/voc-5h.names \ --num_classes 181 \ --mode fit --transfer darknet \ --batch_size 16 \ --epochs 10 \ --weights ./checkpoints/yolov3.tf \ --weights_num_classes 80 使用随机权重进行训练12345678python train.py \ --dataset ./data/voc5h_train.tfrecord \ --val_dataset ./data/voc5h_val.tfrecord \ --classes ./data/voc-5h.names \ --num_classes 181 \ --mode fit --transfer none \ --batch_size 16 \ --epochs 50 \ 模型测试从图像中检测12345python detect.py \ --classes ./data/voc-5h.names \ --num_classes 181 \ --weights ./checkpoints/yolov3_train_5.tf \ --image ./data/street.jpg 从验证集中检测12345python detect.py \ --classes ./data/voc-5h.names \ --num_classes 181 \ --weights ./checkpoints/yolov3_train_5.tf \ --tfrecord ./data/voc5h_val.tfrecord]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>yolo3</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片处理]]></title>
    <url>%2F2021%2F01%2F29%2F%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[OpenCV-Python方法教程：https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html opencv以BGR模式加载图片。 使用需 import cv2 读写展示图片读本地图片1234567891011121314cv2.imread(filepath,flags)​#参数一：工作路径or完整路径 参数二：读取这幅图片方式，可省略#参数二：#cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道，实际取值为1#cv2.IMREAD_GRAYSCALE：读入灰度图片，实际取值为0#cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道​exp:#读取工作路径下彩色图片cv2.imread(&quot;1.jpg&quot;)​#读取完整路径下灰度图片cv2.imread(&quot;/Users/mabelguo/1.jpg&quot;,0) 写图片到本地1234567cv2.imwrite(filepath,img)​#若保存为png，则保留alpha通道；保存为jpg，丢失alpha通道​exp:cv2.imwrite(&quot;1.png&quot;,img)` 窗体展示图片1234567891011121314151617181920212223242526#展示窗体，窗口自适应图片的大小cv2.imshow(windowName,img)#参数一：窗体标题 参数二：图像​​#等待键盘输入，否则窗体一闪而过cv2.waitKey(0)#销毁所有窗口cv2.destroyAllWindows()​#可调整大小窗口cv2.namedWindow(windowName,flag)#如果我们想放大缩小窗口，必须单独用cv2.namedWindow(),并通过flag参数指定窗口模式为cv2.WINDOW_NORMAL,默认为cv2.WINDOW_AUTOSIZE.​flag:窗口大小可以改变： cv2.WINDOW_NORMAL , cv2.WINDOW_GUI_NORMAL窗口大小不可以改变： cv2.WINDOW_AUTOSIZE窗口大小自适应比例： cv2.WINDOW_FREERATIO窗口大小保持比例： cv2.WINDOW_KEEPRATIO 显示色彩变成暗色： cv2.WINDOW_GUI_EXPANDED​exp:cv2.namedWindow(&quot;lena&quot;,0)cv2.imshow(&quot;lena&quot;,img)cv2.waitKey(0)cv2.destroyAllWindows() 图像标注1234567891011121314151617181920212223242526#画直线cv2.line()cv2.line(img, pt1, pt2, color[, thickness[, lineType[, shift]]])​img，背景图pt1，直线起点坐标pt2，直线终点坐标color，当前绘画的颜色。如在BGR模式下，传递(255,0,0)表示蓝色画笔。灰度图下，只需要传递亮度值即可。thickness，画笔的粗细，线宽。若是-1表示画封闭图像，如填充的圆。默认值是1.​​#画圈cv2.circle()cv2.circle(img, center, radius, color[, thickness[, lineType[, shift]]])​img，背景图center，圆心radius，半径color，颜色thickness，线粗细​ #画矩形cv2.rectangle()cv2.rectangle(img, pt1, pt2, color[, thickness[, lineType[, shift]]])​ 图片常见预处理利用numpy创建一张新的图片OpenCV的基础数据类型为numpy.ndarray，numpy.ndarray中的每个元素的dtype应该为numpy.uint8。 1234567891011121314151617import cv2import numpy as np​#创建三通道黑色图片img = np.zeros([w, h, 3], np.uint8)​#创建三通道白色图片img = np.zeros([w, h, 3], np.uint8) + 255​#创建四通道黑色透明图片（需保存为png才能看到透明度）img = np.zeros([w, h, 4], np.uint8)​#由于opencv 颜色通道顺序为BGR蓝色通道为：img[:, :, 0] 绿色通道为：img[:, :, 1] 红色通道为：img[:, :, 2] 透明度通道为：img[:, :, 3] 颜色空间转换12345678910image = cv2.imread(&quot;1.png&quot;)​#从BGR转到HSV颜色空间image_hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)​#从彩色图转灰度图image_ = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)​#从BGR转到RGB颜色空间image_hsv = cv2.cvtColor(image,cv2.COLOR_BGR2RGB) 图像去噪123456789101112131415161718192021222324#高斯滤波cv2.GaussianBlur()​cv2.GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]])@param: src: nparray input image.@param: ksize: (int,int) Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero’s and then they are computed from sigma* .@param: sigmaX: float Gaussian kernel standard deviation in X direction.@param: sigmaY: float Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height. To fully control the result, it is recommended to specify all of ksize, sigmaX, and sigmaY. #exp#可以自己构建高斯核cv2.getGaussianKernel()#也可以直接做模糊blur = cv2.GaussianBlur(img, (6, 6), 1, 0) 二值化cv2.threshold() 函数原型： cv2.threshold (src, thresh, maxval, type) src：源图片，必须是单通道 thresh：阈值，取值范围0～255 maxval：填充色，取值范围0～255 type：阈值类型，见下表 阈值 小于阈值的像素点 大于阈值的像素点 0 置0 置填充色 1 置填充色 置0 2 保持原色 置灰色 3 置0 保持原色 4 保持原色 置0 1ret, binary = cv2.threshold(gray, 80, 255, cv2.THRESH_BINARY_INV) 形态学处理腐蚀1234567import cv2import numpy as np​img = cv2.imread(&apos;j.png&apos;,0)kernel = np.ones((5,5), np.uint8)erosion = cv2.erode(img,kernel,iterations=1)​ 膨胀把分隔对象连起来很有用 1dilation = cv2.dilate(img,kernel,iterations=1) 开运算：先腐蚀后膨胀cv2.morphologyEx() 1opening = cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel) 闭运算：先膨胀后腐蚀用来关闭前景对象里的小洞或小黑点很有用 1closing = cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel) 形态梯度：物体的轮廓1gradient = cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel) 进阶方法查找、绘制轮廓函数cv2.findContours() 函数原型： cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]]) image 源图像，一个8位单通道图像 contours 检测到的轮廓 hierarchy 轮廓级别信息。Hierarchy为可选输出变量 mode 轮廓检索模式 method 轮廓近似法 offset 每个轮廓点移动的偏移量，可选参数，cv::Point()类型 1binary, contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE) cv2.drawContours() 函数原型： image = cv.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]]) 函数参数： image 输入：源图像。单通道或3通道图像。 contours 输入：待绘制的轮廓 contourIdx 输入：待绘制的轮廓序号，-1为绘制所有轮廓。 color 输入：轮廓颜色 thickness 输入：轮廓粗细。int型变量，默认为1，值越大越粗 lineType 输入：绘制轮廓的线型。 hierarchy 输入：待绘制的轮廓级别。 maxLevel 输入：待绘制的轮廓最大级别。 method 输入：轮廓近似法 offset 输入：每个轮廓点移动的偏移量，可选参数。 模板检测cv2.matchTemplate() 函数原型： cv2.matchTemplate(image, templ, method, result=None, mask=None) image：待搜索图像 templ：模板图像 result：匹配结果 method：计算匹配程度的方法 关于匹配方法，使用不同的方法产生的结果的意义可能不太一样，有些返回的值越大表示匹配程度越好，而有些方法返回的值越小表示匹配程度越好。 关于参数 method： CV_TM_SQDIFF 平方差匹配法：该方法采用平方差来进行匹配；最好的匹配值为0；匹配越差，匹配值越大。 CV_TM_CCORR 相关匹配法：该方法采用乘法操作；数值越大表明匹配程度越好。 CV_TM_CCOEFF 相关系数匹配法：1表示完美的匹配；-1表示最差的匹配。 CV_TM_SQDIFF_NORMED 归一化平方差匹配法 CV_TM_CCORR_NORMED 归一化相关匹配法 CV_TM_CCOEFF_NORMED 归一化相关系数匹配法 例子： 123456789101112131415161718192021222324252627#导入所需库文件import cv2import numpy as np​#加载原始RGB图像 img_rgb = cv2.imread(&quot;photo.jpg&quot;) #创建一个原始图像的灰度版本，所有操作在灰度版本中处理，然后在RGB图像中使用相同坐标还原 img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY) #加载将要搜索的图像模板 template = cv2.imread(&apos;face.jpg&apos;,0) #记录图像模板的尺寸 w, h = template.shape[::-1]​#使用matchTemplate对原始灰度图像和图像模板进行匹配 res = cv2.matchTemplate(img_gray,template,cv2.TM_CCOEFF_NORMED) #设定阈值 threshold = 0.7 #res大于70% loc = np.where( res &gt;= threshold)​#使用灰度图像中的坐标对原始RGB图像进行标记 for pt in zip(*loc[::-1]): cv2.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (7,249,151), 2) ​#显示图像 cv2.imshow(&apos;Detected&apos;,img_rgb) cv2.waitKey(0) cv2.destroyAllWindows()​ 图片常见统计学处理直方图计算cv.calcHist()函数 cv.calcHist（images，channels，mask，histSize，ranges ） images：uint8或float32类型的源图像,以方括号传入，如：[img]。 channels：计算直方图的通道的索引，也以方括号给出。灰度图像，值为[0]。彩色图B/G/R分别传入[0]/[1]/[2]。 mask：图像掩码。计算整幅图写None。若要查找图像特定区域的直方图，则必须为此创建一个掩码图像并将其作为掩码。 histSize：也叫bins,子区段数目，如果我们统计0-255每个像素值，bins=256；如果划分区间，比如0-15, 16-31…240-255这样16个区间，bins=16。 ranges：要计算的像素值范围，一般为[0,256) 如：hist = cv2.calcHist([img], [0], None, [256], [0, 256]) Matplotlib方法绘制直方图Matplotlib.pyplot.hist() 1234567import cv2import numpy as npfrom matplotlib import pyplot as plt​img = cv2.imread(&apos;home.jpg&apos;,0)plt.hist(img.ravel(),256,[0,256])plt.show()]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>机器学习</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用Charles进行HTTP/HTTPS抓包]]></title>
    <url>%2F2021%2F01%2F19%2FMac%E4%B8%8B%E4%BD%BF%E7%94%A8Charles%E8%BF%9B%E8%A1%8CHTTP-HTTPS%E6%8A%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Charles安装与配置下载最新的Charles工具，下载地址：https://www.charlesproxy.com/download/ 配置代理端口号Proxy -&gt; Proxy Settings -&gt; Port，port可以随便指定，这里取8888 配置HTTPS证书添加SSL ProxyingProxy -&gt; SSL Proxying Settings -&gt;勾选“Enable SSL Proxying”，并点击下方的Add，可以这样配置： 安装Charles证书到MacHelp–&gt;SSL Proxying→Install Charles Root Certificate 此时会启动“钥匙串访问”APP，搜索框搜所刚安装好的证书，证书名字：Charles Proxy CA。 选中该证书，点击显示简介 更改证书信任权限。更改为始终信任，并关闭窗口输入密码保存 移动复制该证书到“系统”里面 结束！可以抓包了 Android 设置Android代理设置以小米+lineageOS为例 设置 -&gt; WI-FI -&gt; 网络详情 -&gt; 编辑 配置代理，IP设为电脑的IP，端口输入之前设置的端口（此为8888），点击存储 （mac 查看ip：ifconfig en0 ） Android 7.0 以下设置打开Safari浏览器，访问：chls.pro/ssl 手机会提示下载文件，点击安装 Android 7.0 以上设置Android 7.0及以上为何不能抓取到Https请求的明文数据？ 其实Charles上显示确实抓到了包，但是当我们看抓包的详细数据时会发现报错: “You may need to configure your browser or application to trust the Charles Root Certificate. See SSL Proxying in the Help menu”。 Charles说手机端没有信任Charles的根证书，但是我们手机上已经安装了Charles根证书了，为什么会这样？ 原来在Android 7.0(API 24 ) ，有一个名为“Network Security Configuration”的新安全功能。这个新功能的目标是允许开发人员在不修改应用程序代码的情况下自定义他们的网络安全设置。如果应用程序运行的系统版本高于或等于24，并且targetSdkVersion&gt;=24，则只有系统(system)证书才会被信任。所以用户(user)导入的Charles根证书是不被信任的。 方法一：将证书提升为系统证书参考：android 7.0以上charles https抓包 将手机进行Root 将下载的pem证书文件传到到电脑上，并执行以下命令得到证书的md5值 openssl x509 -subject_hash_old -in &lt;file_name&gt; 第一行： 即为md5值。 将charles-proxy-ssl-proxying-certificate.pem重命名为:&lt;8位md值&gt;.&lt;0&gt;，这里的md5值为上一步得到的。 Android系统根目录下的证书名字格式如下：&lt;8位md值&gt;.&lt;0&gt; 将上面步骤产生证书push到手机目录：/system/etc/security/cacerts push中如果遇到错误 例如remount of the / superblock failed: Permission denied或者file only read等。 解决办法: 1234$ adb root$ adb disable-verity$ adb reboot$ adb root 在 设置-&gt;安全-&gt;加密与凭据-&gt;信任的凭据 的系统标签页看到你新加入的证书，将其启用即可顺利抓包 按照系统证书的方法，遇到问题：read-only file system android 尝试adb root ，报错 adbd cannot run as root in production builds 安装adbd Insecure 依然不行 方法二：利用VirtualXposed参考：Android 7.0+使用VirtualXposed+Charles进行抓包 注意，0.18.2以后的VirtualXposed 不支持32位app iOS 设置iPhone代理设置设置→WIFI –&gt;点击Wi-Fi旁边的ⓘ 滑到底部，点击配置代理 配置代理，IP设为电脑的IP，端口输入之前设置的端口（此为8888），点击存储 （mac 查看ip：ifconfig en0 ） iPhone证书安装打开Safari浏览器，访问：chls.pro/ssl，此时电脑上连接提示，点击allow允许 手机会提示下载描述文件，点击允许 安装完成后，点击 设置–&gt;通用→关于本机，下拉到底部，点击证书 信任设置，把刚信任开关打开。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS虚拟定位]]></title>
    <url>%2F2020%2F12%2F07%2FiOS%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[工具 iphone (iOS 14.1) lightning线 MAC电脑 准备工作 下载和iOS版本对应的Developer Disk Image 14.3-4.2 、14.3-11.3 安装libimobiledevice 使用 使用lightning线连接手机和电脑 运行ideviceimagemounter命令挂载Developer Disk Image 运行idevicesetlocation命令设置GPS坐标 使用完成后运行idevicesetlocation reset解除设置 12#exampleidevicesetlocation -- 32.036354 118.785575]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Virtual Location</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下编译V8]]></title>
    <url>%2F2020%2F07%2F15%2FMac%E4%B8%8B%E7%BC%96%E8%AF%91V8%2F</url>
    <content type="text"><![CDATA[下载V8源码参考官方手册 注意：不要直接从v8仓库使用git clone命令下载代码，这样下载下来的代码是无效的，会缺失很多东西，要使用官方提供的工具depot_tools 安装 depot_tools所需的 gn (配置生成工具) 和 nijia (构建工具) 都在这个仓库里。 1234# Clone depot_tools 仓库 $ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git# 导出环境变量$ export PATH=&quot;$PATH:/path/to/depot_tools&quot; 下载所需依赖12345$mkdir v8 &amp;&amp; cd v8# 配置 v8 仓库$ gclient config https://chromium.googlesource.com/v8/v8# 需要科学上网，然后等待很长一段时间...$ gclient sync 结束后会发现有v8库文件的文件夹 修改mini-SDK由于对要求 MAC OSX SDK&gt;10.15，而我的xcode带的是10.12。所以需要修改 查看sdk版本： 12# Xcode中添加的SDK版本$xcodebuild -showsdks v8/build/config/mac/mac_sdk_overrides.gni文件 123456789_sdk_min_from_env = getenv(&quot;FORCE_MAC_SDK_MIN&quot;)declare_args() &#123; # Minimum supported version of the Mac SDK. if (_sdk_min_from_env == &quot;&quot;) &#123; mac_sdk_min = &quot;10.15&quot; # 将这里修改成了10.12 &#125; else &#123; mac_sdk_min = _sdk_min_from_env &#125;&#125; 编译参考官方手册 方式一：gm脚本1234#配置别名：$ alias gm=/path/to/v8/tools/dev/gm.py$ gm x64.release$ gm x64.release.check 方式二：手动编译12345678910111213141516171819#生成ninja文件$ gn args out/foo或指定参数$ gn gen out/foo --args=&apos;is_debug=false target_cpu=&quot;x64&quot; v8_target_cpu=&quot;arm64&quot; use_goma=true&apos;​#或使用v8gen脚本#配置别名：$ alias v8gen=/path/to/v8/tools/dev/v8gen.py$ v8gen -b &apos;V8 Linux64 - debug builder&apos; -m client.v8 foo或：$ v8gen foo​$ v8gen x64.release.sample​#使用ninja来编译：$ ninja -C out/foo如果要在c++中嵌入v8，使用下面的$ ninja -C out.gn/x64.release.sample v8_monolith​ 替换libtool这里我编译出错 12345[48/1364] LIBTOOL-STATIC obj/libv8_libbase.aFAILED: obj/libv8_libbase.arm -f obj/libv8_libbase.a &amp;&amp; TOOL_VERSION=1594099062 python ../../build/toolchain/mac/filter_libtool.py /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool -static -D -o obj/libv8_libbase.a -filelist obj/libv8_libbase.a.rsperror: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool: unknown option character `D&apos; in: -DUsage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool -static [-] file [...] [-filelist listfile[,dirname]] [-arch_only arch] [-sacLT] [-no_warning_for_no_symbols] 看样子是xcode的libtool工具出错，将新版本xcode(11.5)里带的libtool拷贝到原来的xcode 的/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool目录下成功解决问题 移除i18n遇到报错 1FAILED: obj/v8_base_without_compiler/js-number-format.o icu67 移除了 getAllFieldPositions 这个 API，需要后续添加一个 icu67.1 的 patch 因为用不到国际化的模块，将 i18n 从编译选项中移除 123456# 编辑配置$ gn args out.gn/x64.release.sample# 增加一行：# v8_enable_i18n_support = false# 再次构建$ ninja -C out.gn/x64.release.sample v8_monolith 测试编译一下 samples/hello-world.cc 1234$ g++ samples/hello-world.cc -o hello-world \-I. -I./include \-L./out.gn/x64.release.sample/obj -lv8_monolith \-std=c++11 执行一下，如果有如下输出就是编译成功了 1234$ ./hello-world&apos;&apos;&apos;Hello, World!3 + 4 = 7 编译引用v8库的.cc文件G++命令 sample： 1g++ -I. -Iinclude samples/hello-world.cc -o hello_world -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x 命令解释： -std= 决定使用的语言标准，当编译C和C++的时候该选择支持配置。 上述命令中的c++0x表示： 语言标准使用即将发布的ISO c++ 0x标准的工作草案。此选项支持可能包含在c++ 0x中的实验性特性。工作草案在不断地变化，如果GCC的未来版本不属于c++ 0x标准，那么由这个标志启用的任何特性都可能被删除。 更多标准请参考：g++ -pthread 使用POSIX线程库添加对多线程的支持。此选项为预处理器和链接器设置标志。它不影响编译器生成的目标代码的线程安全性，也不影响与其提供的库的线程安全性。这些是特定于HP-UX的标志。 -I dir 将目录dir添加到要搜索头文件的目录列表中。在系统标准包含目录之前，搜索由-I指定的目录。如果目录dir是标准的系统包含目录，则忽略该选项，以确保不会破坏系统目录的默认搜索顺序和对系统头文件的特殊处理。如果dir以”=”开头，则”=”将被sysroot前缀替换。 -o file 指定输出文件。这与将file指定为cpp的第二个非选项参数相同。gcc 对第二个非选项参数的有另一种解释，因此必须使用-o指定输出文件 -llibrary -l library 链接时搜索名为library的库。(第二种指定库文件的方式仅适用于POSIX遵从性，不建议使用。) 在命令中编写这个选项的位置会有所不同;链接器按照指定的顺序搜索和处理库和目标文件。因此,foo.o -lz bar.o是在文件foo.o之后搜索库z。但在bar.o之前。如果bar.o是引用到了z库中的函数，这些函数是不能被加载。 链接器搜索库的标准目录列表，实际上是一个名为liblibrary.a的文件。然后链接器使用这个文件，就好像它是通过名称精确指定的一样。 搜索的目录包括几个标准系统目录，以及您使用-L指定的任何目录。 通常以这种方式找到的文件是库文件——其成员是目标文件的归档文件。链接器通过扫描成员来处理存档文件，这些成员定义了到目前为止已经引用但尚未定义的符号。但是，如果找到的文件是一个普通的对象文件，则以通常的方式链接它。 -Ldir 添加dir目录到搜索目录列表中去供-l使用 交叉编译 V8 for Raspberry Pi下载toolchain for RPi on MAC用法： 直接解压 加入环境变量export PATH=$PATH:/Users/guomengyuan/Downloads/xc-gcc_4.9.3_mac_rpi-master/arm-rpi-linux-gnueabihf/bin 修改名称，将所有的arm-rpi-linux-xxx 改为arm-linux-xxx gn构建ninja文件gn gen out.gn/arm --args=&#39;is_debug=false is_component_build=true symbol_level=0 target_os=&quot;linux&quot; target_cpu=&quot;arm&quot; v8_target_cpu=&quot;arm&quot;&#39; 编译ninja -C out.gn/arm v8引擎基本概念简述isolate表示的一个独立的V8虚拟机，拥有自己的堆栈。所以才取名isolate，意为“隔离”。在v8中使用以下语法进行初始化： 1Isolate* isolate = Isolate::New(create_params); handlehandle是指向对象的指针，在V8中，所有的对象都通过handle来引用，handle主要用于V8的垃圾回收机制。在 V8 中，handle 分为两种：持久化 (Persistent)handle 和本地 (Local)handle，持久化 handle 存放在堆上，而本地 handle 存放在栈上。比如我要使用本地句柄，句柄指向的内容是一个string，那么你要这么定义： 1Local&lt;String&gt; source = String::NewFromUtf8(isolate, &quot;&apos;Hello&apos; + &apos;, World&apos;&quot;, NewStringType::kNormal).ToLocalChecked(); 鉴于一个个释放Handle比较麻烦，v8又提供了HandleScope来批量处理，你可以在handle之前声明好： 1HandleScope handle_scope(isolate); contextcontext 是一个执行器环境，使用 context 可以将相互分离的 JavaScript 脚本在同一个 V8 实例中运行，而互不干涉。在运行 JavaScript 脚本是，需要显式的指定 context 对象。创建上下文，需要这样： 1234// 创建一个上下文 Local&lt;Context&gt; context = Context::New(isolate); // 进入上下文编译和运行脚本 Context::Scope context_scope(context); V8的数据类型由于 C++ 原生数据类型与 JavaScript 中数据类型有很大差异，因此 V8 提供了 Data 类，从 JavaScript 到 C++，从 C++ 到 JavaScrpt 都会用到这个类及其子类，比如： 1String::NewFromUtf8(info.GetIsolate(), &quot;version&quot;).ToLocalChecked() 这里的String便是V8的数据类型。再比如： 1v8::Integer::New(info.GetIsolate(), 10); 对象模板和函数模板这两个模板类用以定义 JavaScript 对象和 JavaScript 函数。我们在后续的小节部分将会接触到模板类的实例。通过使用 ObjectTemplate，可以将 C++ 中的对象暴露给脚本环境，类似的，FunctionTemplate 用以将 C++ 函数暴露给脚本环境，以供脚本使用。 Referencehttps://www.cnblogs.com/wolfx/p/5920141.htmlhttps://juejin.im/post/5d91a4d4f265da5b5f756c22https://gist.github.com/Jiab77/e59841227d1f9c7d2877862ced673ec6https://github.com/google/shaka-packager/issues/763https://groups.google.com/forum/#!topic/v8-users/LTppUbqNrzI豆瓣LLVMrpi交叉编译工具gn参数http://blog.hszofficial.site/introduce/2018/02/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8E%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米6刷Magisk全流程]]></title>
    <url>%2F2020%2F05%2F29%2F%E5%B0%8F%E7%B1%B36%E5%88%B7Magisk%E5%85%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[解锁bootloader需要：sim卡 ，mi手机解锁工具 首先手机进入开发者模式（miui版本连击7次），进入解锁状态(需要sim卡联网) 绑定小米账号和设备(需验证码)，申请解锁设备 windows下载并运行mi手机解锁工具，登录小米账号 小米6手机关机后，同时长按音量“-”和电源，进入fastboot状态（界面出现一个兔子） 手机通过usb与电脑连接 点击解锁手机 解锁成功 刷入第三方twrp recovery找到小米6对应的twrp recovery版本，下载到本地 手机打开usb调试 终端运行 123456#进入fastbootadb reboot bootloader#刷入imgfastboot flash recovery twrp.img#重启fastboot reboot 进入recovery 1fastboot boot twrp.img 注意：有可能会进到自带的Mi recovery，这样就得重新刷。尽量重启后在进入小米的系统之前就进入twrp。 小米进recovery的按钮是同时按音量“+”和电源 &lt;可选：刷入lineage &gt;下载lineage 的固件 进入 twrp recovery 把固件传入手机 adb push lineage.zip /sdcard/ twrp 里install 固件（不选校验，选之后重启） 重启后如果有个绿色的弧线，说明进到lineage里了 刷入Magiskmagisk push 到手机上，使用twrp安装。 重启后手机上出现magisk manager 若magisk manager一直显示要更新，可以把更新通道换为其他的： 进入”设置”，选择自定义通道输入这个链接:https://qianyegroup.gitee.io/magiskbuilds/updates/custom.json]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Magisk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS with Extension砸壳全过程]]></title>
    <url>%2F2019%2F10%2F10%2FiOS-with-Extension%E7%A0%B8%E5%A3%B3%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[准备工作 一部越狱的手机 dumpdecrypted或frida-ios-dump(砸壳使用) class-dump（导出砸壳后的二进制包的头文件） Cycript(Cydia)（在越狱手机的越狱市场下载，安装） OpenSSH(Cydia) （在越狱手机的越狱市场下载，安装） Frida(Cydia) （在越狱手机的越狱市场下载，安装） 重要步骤在APPStore中下载正版的应用到手机上以下以搜狗输入法为例（手机ios10.3.3 型号iphone 5c） ssh至手机，并查看路径转发手机22端口到主机2222端口 iproxy 2222 22 ssh至手机 ssh -p2222 root@127.0.0.1 查找 进程信息（此时app和extension都要打开） 123ps -e | grep Sogou cycript -p SogouInput dumpdecrypted砸壳下载并编译dumpdecrypted cd dumpdecrypted &amp;&amp; make 为dumpdecrypted.dylib签名codesign -fs &quot;iPhone Developer: my.guo@foxmail.com (WJ79M49LT4)&quot; dumpdecrypted.dylib 将dumpdecrypted.dylib拷贝到/usr/binsudo scp dumpdecrypted.dylib root@10.2.200.186:/usr/bin 执行以下命令为可执行文件砸壳 1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/EFE80EA8-BF4D-49C9-A342-B22357CA1A93/SogouInput.app/SogouInput 为extension砸壳 1DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib /var/containers/Bundle/Application/EFE80EA8-BF4D-49C9-A342-B22357CA1A93/SogouInput.app/PlugIns/com.sogou.sogouinput.BaseKeyboard.appex/com.sogou.sogouinput.BaseKeyboard 结果会在执行目录下生成可执行文件.decrypted文件 将文件拷贝回电脑 sudo scp root@127.0.0.1:/SogouInput.decrypted ~/Desktop frida-ios-dump 砸壳按照说明配置环境 修改dump.py 中的user等 1234User = &apos;root&apos;Password = &apos;*****&apos;Host = &apos;localhost&apos;Port = 2222 开始砸壳 sudo ./dump.py com.sogou.sogouinput 查看可执行文件是否成功砸壳otool -l 可执行文件路径 | grep cryptid结果为1加密了，0没有加密]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>dump</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac更新bash至4.0以上]]></title>
    <url>%2F2019%2F09%2F20%2FMac%E6%9B%B4%E6%96%B0bash%E8%87%B34-0%E4%BB%A5%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[Mac自带的bash为3.2版本，而最新的bash是5.0一上了。这导致bash无法支持新特性，而且执行脚本时也会提示bash要升级。 升级方法查看bash版本bash --version执行brew install bash 此时，bash虽然安装了，但是/bin/bash的版本依然没有改变。这是因为mac系统禁止更改系统目录的权限，引入sip机制，需要先关闭，修改，再打开这一系列操作 打开和关闭sip关闭sip 重启系统，然后按住Command+R 出现界面之后，在最上方菜单栏选择Utilities menu中Terminal 在Terminal中输入csrutil disable关闭SIP 重启reboot 加入软链接12sudo mv /bin/bash /bin/bash.originsudo ln -s /usr/local/bin/bash /bin/bash 修改完成之后，查看版本是否更改。更改后重新打开sip，打开时执行csrutil enable]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Mac虚拟机（VirtualBox）无法登陆Xcode的开发账号问题]]></title>
    <url>%2F2019%2F09%2F20%2F%E8%A7%A3%E5%86%B3Mac%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88VirtualBox%EF%BC%89%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86Xcode%E7%9A%84%E5%BC%80%E5%8F%91%E8%B4%A6%E5%8F%B7%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题表现形式登陆时输入正确的账户和密码，界面一直在loading状态，输入错误的密码会提示密码错误。与此同时，在网页上可以成功登陆苹果开发者网站，说明不是网络或与服务器连接上出现问题。 出现问题的原因在登陆app atore 或添加Xcode账户的时候，需要验证apple id。苹果在验证时会检查机器的smbios 信息，如果不是 mac 机器，就不让登录，虚拟机也不行。进入虚拟机后，点击左上角-关于本机 可查看虚拟机固件情况。如果是未经修饰的虚拟机，下面序列号等信息都为空 解决办法在VirtualBox的配置文件中有“ExtraData”部分，可以通过修改配置文件的方法，伪造出虚假的smbios信息。 如何获得虚假的smbios信息可以通过下载Chameleon-Wizard 软件或者Clover Configurator软件进行配置。配置方法比较傻瓜，选一个想要的型号，就会自动生成。最后保存为一个plist文件，需要的信息都在里面。 1234567891011121314151617&lt;ExtraDataItem name=&quot;GUI/InformationWindowGeometry&quot; value=&quot;0,45,1440,800,max&quot;/&gt;&lt;ExtraDataItem name=&quot;GUI/LastCloseAction&quot; value=&quot;PowerOff&quot;/&gt;&lt;ExtraDataItem name=&quot;GUI/LastNormalWindowPosition&quot; value=&quot;623,199,512,405&quot;/&gt;&lt;ExtraDataItem name=&quot;GUI/LastScaleWindowPosition&quot; value=&quot;400,194,640,480&quot;/&gt;&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiBoardProduct&quot; value=&quot;Mac-06Fxxxx93F0323C5&quot;/&gt;&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiBoardSerial&quot; value=&quot;C025xxxx0CDGDQPCB&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiSystemFamily&quot; value=&quot;MacBook Pro&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiSystemProduct&quot; value=&quot;MacBookPro11,4&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiSystemSerial&quot; value=&quot;C02PQ4ZBG8WL&quot;/&gt;&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiSystemUuid&quot; value=&quot;CAFECAFE-xxxx-CAFE-CAFE-DECAFFDECAFF&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiOEMVBoxVer&quot; value=&quot;string:1&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiOEMVBoxRev=&quot; value=&quot;string:.23456&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiBIOSVersion&quot; value=&quot;MBP114.88Z.F000.B00.1906140921&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiBIOSReleaseDate=&quot; value=&quot;06/14/2019&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal/Devices/smc/0/Config/DeviceKey&quot; value=&quot;ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc&quot;/&gt;&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC&quot; value=&quot;1&quot;/&gt; &lt;ExtraDataItem name=&quot;VBoxInternal2/SharedFoldersEnableSymlinksCreate/vagrant&quot; value=&quot;1&quot;/&gt; 通过配置命令修改信息cd至virtualbox目录下执行 VBoxManage setextradata &quot;OSName&quot; &quot;VBoxInternal/Devices/efi/0/Config/DmiSystemProduct&quot; &quot;MacBookPro11,3&quot; 修改SystemProduct信息其他信息类似 在虚拟机已经建立后，这种方法不一定能够成功修改，慎用 通过脚本直接新建虚拟机，在脚本里写上配置参数此方法参考开源项目macos-guest-virtualbox 具体步骤： 将工程下载或pull到本地 升级bash到bash4.0 参考Mac更新bash至4-0以上 安装依赖 bash coreutils wget unzip dmg2img 按照前面生成的plist信息修改脚本文件 cd 到目录下运行脚本 $ ./macos-guest-virtualbox.sh 一路enter，选择一下os版本，然后看提示信息一路enter最后虚拟机建立好后，可以看到虚拟机的信息已经跟真机类似了，而且跟我们配置的参数一样，后面xcode的账户果然也可以正常登录 其他问题vmware虚拟机相同问题同样的，如果vmware出现相同问题，也可以通过修改配置文件的方法解决，具体参考：https://www.insanelymac.com/forum/topic/292170-how-to-spoof-real-mac-in-vmware/?page=1https://www.insanelymac.com/forum/topic/309654-run-vanilla-os-x-el-capitan-sierra-high-sierra-or-mojave-in-virtualbox-5xx-on-a-windows-host/]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Xcode</tag>
        <tag>VirtualBox</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode的各种坑]]></title>
    <url>%2F2019%2F09%2F12%2FXcode%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91%2F</url>
    <content type="text"><![CDATA[作为一个iOS萌新，使用Xcode的过程真是一言难尽，遇到各种奇怪的耽误事儿的问题。这里就占个楼专门总结使用中碰到的问题，以后遇到了也有的参考。 什么？还需要开发者账号？第一次使用Xcode的时候，我以为它和VS、Eclipse什么的一样就是一个简单的开发环境。后来才知道苹果对开发者管控的很严格，开发者需要注册开发者账号才能具备签名打包工程，发布到Apple Store的资格。 一般来说，开发者需要到苹果开发者网站注册开发者账号。具体的流程为： 注册apple id (注意国籍中国 + 年龄&gt;18) 加入apple developer计划 根据自己的身份进行填写注册 完成付款，个人是每年99刀 在这之后就可以创建证书和包了 不过自15年之后，也就是Xcode7.x之后，开发者可以用中间的apple id申请一个免费的开发账号。不过这个账号只有测试功能，且权限有限，只支持三个测试设备，用的时候要很节省。 Bundle Identifier？那是什么东西？在我刚开始尝试OC的时候，我就像自己学习C或Java一样，疯狂建了一堆类似“TEST”、“HelloWorld”、“MyFirstApp”这样的OC工程。建工程之前会让你填写Team或者Bundle Identifier之类的信息，年轻的我以为这只是一些工程或者组织信息描述，就随手填了名字。没想到，在我疯狂建了各种名字的工程之后，突然有天再新建时提示我Bundle Identifier满了…原来一个账号的Bundle Identifier是有限的，尤其是上架之后不能与其他人的重复。满了之后再想用只能等之前的过期了。另外，测试设备的数量也是有限的，占用了之后只能等每年Apple清理掉了。 打开工程时一直loading转圈？有一天，我打开一个大工程时，Xcode一直右下角在loading。而且只能通过杀死进程的方法才能关掉。解决办法:Xcode打开工程假死不过我当时好像是把整个工程都删了，文件夹清理一遍才好。 添加账号时一直loading转圈？这个问题是最让我烦躁的，填了账户密码之后就一直转圈，一点反应没有。有人说是因为验证的服务器有问题，不过我试了之后发现输了错误的密码之后是有错误提示的。说明验证是能验证的，应该是接下来的步骤卡死。这个问题在某一天突然解决，又在某一天突然出现，毫无防备。 如果在虚拟机上出现该问题，参考文章解决Mac虚拟机（VirtualBox）无法登陆Xcode的开发账号问题 使用低版本SDK有时在开发中，我们升级Xcode为较高的版本，或者由于mac系统版本限制只能使用某个较高版本的Xcode，而可其支持的最低版本iOS SDK却比我们需要的版本高。这时就需要将较低版本的SDK移过来。首先，从旧版本Xcode中将SDK拷贝出来，路径为:Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs然后将其拷贝到新版本的对应位置再打开/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Info.plist文件改变MinimumSDKVersion的值，重启Xcode会识别大于等于MinimumSDKVersion的所有SDK]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hook技术的原理和实现]]></title>
    <url>%2F2019%2F09%2F12%2FHook%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Arm指令]]></title>
    <url>%2F2019%2F09%2F04%2FArm%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[传输数据指令CPSR状态寄存器： .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-baqh{text-align:center;vertical-align:top} .tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top} 条件码标志 保留 控制位 31 30 29 28 27 26 25 24-8 7 6 5 4 3 2 1 0 N Z C V I F T M4 M3 M2 M1 M0 Less than Zero Carry Overflow IRQ FIQ State Mode bits 数据处理指令语法 &lt;操作{&lt;cond&gt;}{S}&gt; &lt;Rd&gt;, &lt;Rn&gt;, &lt;Operand2&gt; &lt;操作码&gt; &lt;目标寄存器Rd&gt; &lt;第一操作寄存器Rn&gt; &lt;第二操作数Operand2&gt; 第一个位置必须是寄存器，第二操作数可以是寄存器，也可以是立即数 数据传送指令 MOV,MVN指令的几种形式： .tg {border-collapse:collapse;border-spacing:0;} .tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;} .tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top} .tg .tg-0lax{text-align:left;vertical-align:top} 从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器 mov 寄存器、 立即数 mov r0,#0x1 r0 = 0x1 mov 寄存器、 寄存器 mov r2, r1 r2 = r1 取反后再传值,比MOV多了一步取反 mov 寄存器、 立即数 mvn r0,#0x1 r0 = ~0x1 mov 寄存器、 寄存器 mvn r2, r1 r2 = ~r1 movx 其中 x 可以是下面的字符: l用于32位的长字值w用于16位的字值 把 16 位立即数放到寄存器的低16位，高16位清0 t用于16位的字值 把 16 位立即数放到寄存器的高16位，低 16位不影响b用于8位的字节值 算术运算指令 ADD/ADC , SUB/SBC , MULADD12345678;ADD加法指令mov r0, #1mov r1, #1add r2, r1, r0 ;r2 = r1 + r0add r2, r1, #2 ;r2 = r1 + 2;ADC带进位加法指令,即除了加两个数以外,还要把CPSR的C值也要带进来ADDS R0,R1,R2; R0=R1+R2,ADDS中S表示把进位结果写入CPSRADC R5,R3,R4 ;R5=R3+R4+C SUB12345678;SUB减法指令mov r0, #5mov r1, #3sub r2, r0, r1 ;r2 = r0 - r1sub r2, r1, #2 ;r2 = r1 - 2;SBC带进位减法指令,即除了加两个数以外,还要把CPSR的C值也要带进来,类似ADCSUBS R0,R1,R2; R0=R1-R2,SUBS中S表示把进位结果写入CPSRSBC R5,R3,R4 ;R5=R3-R4-C MUL123;MUL 乘法指令MUL R0,R1,R2; R0=R1*R2MUL R0,R1,#3 ;R0=R1*3 位操作指令 AND,ORR, TST,BICAND 与操作12AND R0,R1,R2; R0=R1 &amp; R2AND R0,R1,#0xFF ;R0=R1 &amp; 0xFF ORR 或操作12ORR R0,R1,R2; R0=R1 | R2ORR R0,R1,#0xFF ;R0=R1 | 0xFF TST 测试某一位是否为1,并把结果写入CPSR,供下一句使用12TST R1,#0xffe; 等同于if(R1 &amp; 0xffe)TST R1,#%1;测试最低位是否为1,%表示二进制 BIC 清位操作12BIC R0，R0，＃0xF ； 等同于 R0 &amp;=~(0xF)BIC R0，R0，＃％1011 ； 该指令清除 R0 中的位 0 1 3，其余的位保持; %表示是二进制,0x表示十六进制 cmp指令cmp是比较指令,cmp的功能相当于减法指令。它不保存结果，只是影响相应的标志位。其他的指令通过识别这些被影响的标志位来得知比较结果。 cmp指令格式: cmp 操作对象1, 操作对象2 不同大小数进行cmp指令时的结果： cmp eax, eax (两数相等) cmp eax, ebx (eax - ebx = 03h) cmp al, bl (al - bl = -03h) 我们怎么判断大小呢？若执行指令后 （1）ZF ZF=1 ，则说明两个数相等，因为zero为1说明结果为0。 （2）CF 当无符号时： CF=1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1 &lt; oprd2 CF=0 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1&gt;oprd2 当有符号时： 若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1&gt;oprd2 若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1 &lt; oprd2 若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1 &lt; oprd2 若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1 &gt; oprd2 beq &amp; bnqbeq指令beq指令格式: beq 地址 若标志位ZF为1，则跳转；若为0，则不跳转 （若前面有cmp指令，则意味着相等跳转，不等执行下一步） bnq指令bnq指令格式: bnq 地址 若标志位ZF为0，则跳转；若为1，则不跳转 （若前面有cmp指令，则意味着不等跳转，相等执行下一步） 寄存器入栈及出栈指令 POP PUSH实现低寄存器、可选的 LR 寄存器入栈寄存器、可选的 PC寄存器出栈操作，堆栈地址由 SP 寄存设置,堆栈是满递减堆栈. 指令格式： 12PUSH &#123;reglist[,LR]&#125; reglist 入栈/出栈低寄存器列表,即 R0~R7 LR 入栈时的可选寄存器POP &#123;reglist[,PC]&#125; PC 出栈时的可选寄存器 STR指令STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。 指令格式： STR{条件} 源寄存器，&lt;存储器地址&gt; 123STR R0，[R1]，＃8 ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。STR R0，[R1，＃8] ；将R0中的字数据写入以R1＋8为地址的存储器中。”str r1, [r0] ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中 条件指令https://www.anquanke.com/post/id/86422 特殊的跟0的比较跳转指令大于等于0（BGEZ），大于0（BGTZ），小于等于0（BLEZ），还有小于0（BLTZ） 分支指令将一个寄存器的值跟0比较BEQ,BGE,BGT,BLE,BLT,BNE]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决mac上使用VirtualBox建立mac虚拟机分辨率问题]]></title>
    <url>%2F2019%2F08%2F21%2F%E8%A7%A3%E5%86%B3mac%E4%B8%8A%E4%BD%BF%E7%94%A8VirtualBox%E5%BB%BA%E7%AB%8Bmac%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[mac主机使用virtualbox安装mac虚拟机经常出现分辨率问题，虚拟机 关于本机-&gt;显示器 里可查看可用的分辨率选项很低。那么如何将虚拟机的分辨率调整至1920x1080,或是2880x1800呢？ 首先将VirtualBox全部关闭终端进入VirtualBox.app路径下执行以下命令： 12VBoxManage setextradata &quot;mac10.10.5&quot; CustomVideoMode1 2880x1800x32 #数组间的符号为小写字母x, 下同VBoxManage setextradata &quot;mac10.10.5&quot; VBoxInternal2/EfiGraphicsResolution 2880x1800 引号内为虚拟机名称，可通过VBoxManage list -s vms命令查看]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用ipa重签名]]></title>
    <url>%2F2019%2F08%2F21%2FiOS%E5%BA%94%E7%94%A8ipa%E9%87%8D%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[使用Xcode重签名 新建一个工程编译 获得这个新工程的签名 查看位置：product-&gt;app-&gt;在path中打开 用要签名的app替换掉工程app，把要签名的app的名字改为工程名字 把要签名app的info.plist里的buddleid 改为工程的bundleid 使用要签名的证书对app进行签名 1codesign -fs &quot;iPhone Developer: amor.diavolo@icloud.com (K239F7Y6DD)&quot; MTPotal.app 查看本机证书： security find-identity -v -p codesigning 在xcode中run，将会把签名后的app安装在真机上，此时可看到ui界面，也可lldb进行调试。 使用Monkeydev自动签名 创建一个MonkeyDev项目 把砸了壳的IPA包放到Target目录下 直接运行就可以跑到手机上了]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homebrew安装与使用]]></title>
    <url>%2F2019%2F08%2F19%2FHome-brew%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Homebrew是一款MacOS平台下自由及开放源代码的软件包管理系统，用以简化macOS系统上的软件安装过程。可以理解为MacOS版的yum或apt-get吧 Homebrew安装Homebrew是基于Ruby的，安装过程也非常很简单，只需执行： 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序，之后在终端就可以使用 brew 命令了。 Homebrew使用常见的Homebrew命令123456789101112131415161718192021222324252627282930313233//查看brew的帮助brew –help //查看Homebrew版本brew -v//安装软件brew install &lt;packageName&gt; //卸载软件brew uninstall &lt;packageName&gt; //搜索软件brew search &lt;packageName&gt; //显示已经安装软件列表brew list //更新软件，把所有的Formula目录更新，并且会对本机已经安装并有更新的软件用*标明。brew update //更新某具体软件brew upgrade &lt;packageName&gt; //查看软件信息brew [info | home] [FORMULA...] //删除程序，和upgrade一样，单个软件删除和所有程序老版删除。brew cleanup &lt;packageName&gt;brew cleanup //查看那些已安装的程序需要更新brew outdated brew卸载软件及依赖123$ brew tap beeftornado/rmtree$ brew rmtree &lt;package&gt; brew安装指定版本软件首先把Homebrew克隆下来 1git clone https://github.com/Homebrew/homebrew-core 执行 1git log master -- Formula/qemu.rb 在提交记录里查找到需要的的提交版本,如qemu2.12.0的提交版本为:commit 22ee44faa55709ca466b5b17330ca72a55a2e8dd 将版本回滚到需要的版本，如将qemu版本回滚到2.12.0 1git checkout 22ee44faa55709ca466b5b17330ca72a55a2e8dd 将qemu.rb拷贝出来，执行brew install /Path/qemu.rb 安装 切换brew源如果brew的速度太慢可以切换brew源，清华源：https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git 通过以下操作进行替换和还原 替换 brew.git/ homebrew-core.git仓库地址 12345678910# 替换成清华的 brew.git 仓库地址:cd &quot;$(brew --repo)&quot;git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git# 替换成清华的 homebrew-core.git 仓库地址:cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git#更新brew update 还原 brew.git/ homebrew-core.git 仓库地址 12345678910# 还原为官方提供的 brew.git 仓库地址cd &quot;$(brew --repo)&quot;git remote set-url origin https://github.com/Homebrew/brew.git# 还原为官方提供的 homebrew-core.git 仓库地址cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;git remote set-url origin https://github.com/Homebrew/homebrew-core.git#更新brew update]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debugserver + lldb 动态调试]]></title>
    <url>%2F2019%2F08%2F16%2Fdebugserver-lldb-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[配置debugserverdebugserver运行在的iOS上，顾名思义，它作为服务端，实际执行LLDB（作为客户端）传过来的命令，再把执行结果反馈给LLDB，显示给用户，即所谓的“远程调试”。在默认情况下，iOS设备上并没有安装debugserver，只有在设备连接过一次的Xcode，并在窗口→设备菜单中添加此设备后，debugserver才会被Xcode中安装到iOS版的“/开发人员的/ usr / bin中/”目录下。 将debugserver从手机传到mac使用iproxy工具，将当前连接设备的22端口（SSH）映射到电脑的2222端口 1iproxy 2222 22 SSH到usb设备上 1ssh -p2222 root@127.0.0.1 传输文件 1scp -P2222 root@127.0.0.1:/Developer/usr/bin/debugserver ~/Desktop 给debugserver瘦身对照表格找到设备的ARM信息例如iphone为5c,执行 1lipo -thin armv7s ~/debugserver -output ~/debugserver 给debugserver添加权限安装ldid 1brew install ldid 下载ent.xml到MACOS目录，然后运行： 1ldid -Sent.xml debugserver 注意“-S”选项与“Sent.xml”之间是没有空格的，Sent.xml是设置二进制授权的文件，没有的话可以去网上找找，也可在工程中找entitlements文件获得。 将经过处理的debugserver拷回手机1scp -P2222 ~/debugserver root@127.0.0.1:/usr/bin/debugserver 连接进程通过端口号调试ssh到ios上，执行 1ps aux 查看pid 1debugserver *:1234 -a prossesname/pid 文件方式启动，不需端口号1debugserver -x frontboard *:1234 /var/containers/Bundle/Application/1452A4F7-C5B1-4654-9CDC-4D94C3C94F47/MTPotal.app 把本地端口映射到苹果端口1iproxy 1234 1234 在Mac系统上用LLDB远程调试1process connect connect://localhost:1234 这条命令执行耗时比较长，需要耐心等一会 常用lldb命令12345678910111213#查看地址image list -o -f#查看类内地址po [className _shortMethodDescription]#设置断点br s -a 0x452C96#删除所有断点br del #禁用第3个断点（启用en）br dis 3-c 用来设置断点条件-o 来设置单次断点 更多命令查看手册 参考链接http://iosre.com/t/debugserver-lldb-gdb/65http://zhz.io/2018/07/05/%E9%82%A3%E4%B8%AALLDB%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>debugserver</tag>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[theos安装、环境配置]]></title>
    <url>%2F2019%2F08%2F16%2Ftheos%E5%AE%89%E8%A3%85%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Theos 是一个越狱开发工具包，安装方法可以参考 Wiki。 安装依赖安装 dpkgdpkg(Debian Packager) 是 Theos 依赖工具之一，可以使用 dpkg 制作 deb，Theos 开发的插件都会以 deb 的格式进行发布，在安装 Theos 之前需要安装 dpkg. 安装借助于Homebrew安装，确保先安装 Homebrew。 1brew install dpkg 安装 ldidldid是越狱祖师爷Saurik开发的一款二进制授权管理软件，可以对越狱应用进行SHA1运算生成授权，让软件包可以在iPhone上执行。Theos 开发中，iOS 文件的签名使用 ldid 工具完成，代替了 XCode 中的 Codesign。 1brew install ldid 安装Thoes将 Theos 安装在 /opt/theos 目录下 12sudo Git clone --recursive https://github.com/theos/theos.git /opt/theos//recursive表示递归 将 /opt/theos 权限改为自己1sudo chown $(id -u):$(id -g) /opt/theos 配置环境变量 在~./bash_profile中加上: 12export THEOS=/opt/theosexport PATH=/opt/theos/bin/:$PATH 执行一遍source命令使得环境变量生效 1source ~/.bash_profile 测试是否安装成功1nic.pl New Instance Creator开始执行则已经安装成功 Theos升级到最新版1git submodule update –recursive 参考链接：http://iosre.com/t/theos/4928]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>theos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/C++预处理指令]]></title>
    <url>%2F2019%2F08%2F16%2FC%3AC%2B%2B%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[预处理指令是我们写在程序代码中的给预处理器(preprocessor)的命令，该指令将在编译器进行编译之前对源代码做某些转换。预处理指令以#号开头（# 号必须是该行除了任何空白字符外的第一个字符），#后是指令关键字，在关键字和# 号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令。 使用预处理功能便于程序的修改、阅读、移植和调试，也便于实现模块化程序设计。 常见的预处理指令 指令 说明 # 空指令，无任何效果 #include 包含一个源代码文件 #define 定义宏 #undef 取消已定义的宏 #if 如果给定条件为真，则编译下面代码 #ifdef 如果宏已经定义，则编译下面代码 #ifndef 如果宏没有定义，则编译下面代码 #elif 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码 #endif 结束一个#if……#else条件编译块 #include当预处理器找到一个#include 指令时，它用指定文件的全部内容替换这条语句。声明包含一个文件有两种方式： 1#include &quot;file&quot; or #include &lt;file&gt; 两种表达的唯一区别是编译器应该在什么路经下寻找指定的文件。 第一种情况下，文件名被写在双引号中，编译器首先在包含这条指令的文件所在的目录下进行寻找，如果找不到指定文件，编译器再到被配置的默认路径下（也就是标准头文件路径下）进行寻找。 如果文件名是在尖括号 &lt;&gt; 中，编译器会直接到默认标准头文件路径下寻找。 #define #define可以被用来生成宏定义常量(defined constantants 或 macros)，它的形式是： 1#define [MacroName] [MacroValue] 它的作用是定义一个叫做name 的宏定义，然后每当在程序中遇到这个名字的时候，它就会被value代替。 取消宏则是： 1#undef [MacroName] 简单的define定义1#define MAXTIME 1000 一个简单的MAXTIME就定义好了，它代表1000，假设在程序里面写 1if(i &lt; MAXTIME)&#123;.........&#125; 编译器在处理这个代码之前会对MAXTIME进行处理替换为1000。 这种定义看起来相似于普通的常量定义CONST，但也有着不同，由于define的定义更像是简单的文本替换，而不是作为一个量来使用，这个问题在以下反映的尤为突出。 define的“函数定义”define能够像函数那样接受一些參数，例如以下 1#define max(x,y) (x)&gt;(y)?(x):(y); 这个定义就将返回两个数中较大的那个，看到了吗？由于这个“函数”没有类型检查，就好像一个函数模板似的，当然，它绝对没有模板那么安全就是了。能够作为一个简单的模板来使用而已。 可是这样做的话存在隐患，样例例如以下： 1#define Add(a,b) a+b; 在一般使用的时候是没有问题的，可是假设遇到如： 1c * Add(a,b) * d 的时候就会出现故障，代数式的本意是a+b然后去和c，d相乘，可是由于使用了define（它仅仅是一个简单的替换），所以式子实际上变成了：c*a + b*d 另外举一个样例： 12#define pin (int*);pin a,b; 本意是a和b都是int型指针，可是实际上变成int* a,b; a是int型指针，而b是int型变量。这是应该使用typedef来取代define，这样a和b就都是int型指针了。所以我们在定义的时候，养成一个良好的习惯，建议全部的层次都要加括号。 define的单行定义123#define A(x) T_##x#define B（x) #@x#define C（x) #x 我们如果：x=1，则有： A(1)——&gt; T_1 （T_##x,##符号是记号粘黏符号，将前后的字符粘黏起来。）B(1)——&gt; ‘1’ （ #@x , #@ 符号会将宏的参数进行字符串字面量化，并且加‘’号）C(1)——&gt; “1” （ #x ,#符号会将宏的参数进行字符串字面量化，并且加””号） define的多行定义define能够替代多行的代码，比如MFC中的宏定义 123456#define MACRO(arg1, arg2) do&#123; \ \ stmt1; \ stmt2; \ \ &#125; while(0) 注意： 使用#define声明多行宏函数与声明单行宏函数没有本质区别； 多行声明时，回车换行前要加上字符‘\’，即“[enter]”，注意字符‘\’后要紧跟回车键，中间不能有空格或其他字符。 另外，在Linux操作系统中 “[enter]”称为跳脱字符，意思是一行写不完的时候可以使用跳脱字符换行，但对于操作系统而言，它认为你并没有换行。 define和typedef的差别typedef是一种用来声明自定义数据类型,配合各种原有数据类型达到简化编程目的的类型定义关键字，可以使用typedef为已有数据类型取别名。 两者的区别： 执行时间不同 关键字 typedef 在编译阶段有效, 犹豫是在编译阶段, 因此 typededf 有类型检查的功能. define 是宏定义, 发生在预处理阶段, 也就是编译之前, 它只是进行简单而机械的字符串替换, 而不进行任何检查. 功能不同 typedef 用来定义类型的别名, 这些类型不止包含内部类型(init,char等), 还包括自定义类型(如struct), 可以起到使类型易于记忆的功能.如： 12typedef int (*PF) (const char *, const char *); //定义一个指向函数的指针的数据类型PF，其中函数返回值为int，参数为const char *. 这个就和定义 Block 很像了 typedef 可定义机器无关的类型，如，你可以定义一个浮点类型，在目标机器上它可以获得最高的精度。如： 123456789typedef long double REAL; //在不支持 long double 的机器上，该 typedef 看起来会是下面这样：typedef double REAL; //并且，在连 double 都不支持的机器上，该 typedef 看起来会是这样：typedef float REAL; define 不止可以为类型取别名, 还可以定义常量, 变量, 编译开关等. 作用域不同 #define 没有作用域的限制, 只要是之前预定义过的宏, 在以后的程序中都可以使用。而 typedef 有自己的作用域.1234567void fun() &#123; #define A int&#125;void gun() &#123;//在这里也可以使用A，因为宏替换没有作用域，//但如果上面用的是typedef，那这里就不能用A ，不过一般不在函数内使用typedef&#125; 对指针的操作不同 二者修饰指针类型时, 作用不同123456Typedef int * pint； #define PINT int * Const pint p；//p不可更改，p指向的内容可以更改，相当于 int * const p; Const PINT p；//p可以更改，p指向的内容不能更改，相当于 const int *p；或 int const *p； pint s1, s2; //s1和s2都是int型指针 PINT s3, s4; //相当于int * s3，s4；只有一个是指针。 条件编译——#ifdef, #ifndef, #if, #endif, #else and #elif这些指令可以使程序的一部分在某种条件下被忽略。 #ifdef #ifdef 可以使一段程序只有在某个指定常量已经被定义了的情况下才被编译，无论被定义的值是什么。它的操作是： 123#ifdef name// code here#endif 例如： 123#ifdef MAX_WIDTHchar str[MAX_WIDTH];#endif 在这个例子中，语句char str[MAX_WIDTH]; 只有在宏定义常量MAX_WIDTH 已经被定义的情况下才被编译器考虑，不管它的值是什么。如果它还没有被定义，这一行代码则不会被包括在程序中。 #ifndef #ifndef 起相反的作用：在指令#ifndef 和 #endif 之间的代码只有在某个常量没有被定义的情况下才被编译，例如： 1234#ifndef MAX_WIDTH#define MAX_WIDTH 100#endifchar str[MAX_WIDTH]; 这个例子中，如果当处理到这段代码的时候MAX_WIDTH 还没有被定义，则它会被定义为值100。而如果它已经被定义了，那么它会保持原值 (因为#define 语句这一行不会被执行) 。 #if, #else 和 #elif指令#if, #else 和 #elif (elif = else if) 用来使得其后面所跟的程序部分只有在特定条件下才被编译。这些条件只能够是常量表达式，例如： 1234567891011121314#if MAX_WIDTH&gt;200#undef MAX_WIDTH#define MAX_WIDTH 200#elsif MAX_WIDTH&lt;50#undef MAX_WIDTH#define MAX_WIDTH 50#else#undef MAX_WIDTH#define MAX_WIDTH 100#endifchar str[MAX_WIDTH]; 注意看这一连串的指令 #if, #elsif 和 #else 是怎样以 #endif 结尾的。 常常使用宏来调试代码:1234567891011121314151617#if 0///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)#else///&lt; 新的代码(或函数)#endif #ifndef JOE_DEBUG///&lt; 新的代码(或函数)#else///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)#endif #ifdef Q_DEBUG///&lt; 新的代码(或函数)#else///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)#endif #line当我们编译一段程序的时候，如果有错误发生，编译器会在错误前面显示出错文件的名称以及文件中的第几行发生的错误。 指令#line 可以使我们对这两点进行控制，也就是说当出错时显示文件中的行数以及我们希望显示的文件名。它的格式是： 1#line number &quot;filename&quot; 这里number 是将会赋给下一行的新行数。它后面的行数从这一点逐个递增。 filename 是一个可选参数，用来替换自此行以后出错时显示的文件名，直到有另外一个#line指令替换它或直到文件的末尾。例如： 12#line 1 &quot;assigning variable&quot;int a?; 这段代码将会产生一个错误，显示为在文件”assigning variable”, line 1 。 #error这个指令将中断编译过程并返回一个参数中定义的出错信息，例如： 123#ifndef __cplusplus#error A C++ compiler is required#endif 这个例子中如果__cplusplus没有被定义就会中断编译过程。 #pragma这个指令是用来对编译器进行配置的，针对你所使用的平台和编译器而有所不同。要了解更多信息，请参考你的编译器手册。如果你的编译器不支持某个#pragma的特定参数，这个参数会被忽略，不会产生出错。 预定义宏 (Predefined macro names)以下宏名称在任何时候都是定义好的： macro value LINE 整数值，表示当前正在编译的行在源文件中的行数。 FILE 字符串，表示被编译的源文件的文件名。 DATE 一个格式为 “Mmm dd yyyy” 的字符串，存储编译开始的日期。 TIME 一个格式为 “hh:mm:ss” 的字符串，存储编译开始的时间。 STDC 如果编译器接受标准C，那么值为1. （整型） __cplusplus 整数值，所有C++编译器都定义了这个常量为某个值。如果这个编译器是完全遵守C++标准的，它的值应该等于或大于199711L，具体值取决于它遵守的是哪个版本的标准。 参考文献:https://www.cnblogs.com/zi-xing/p/4550246.htmlhttps://www.cnblogs.com/lcchuguo/p/4005360.htmlhttps://www.kancloud.cn/kancloud/cplusplus/62276http://blog.sina.com.cn/s/blog_4fc2fb600102yds4.htmlhttps://www.jianshu.com/p/53ac91a23979]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apple Opensource 下载Apple开源项目]]></title>
    <url>%2F2019%2F08%2F16%2FApple-Opensource%2F</url>
    <content type="text"><![CDATA[在学习OC的过程中，经常需要结合源码一起理解。Apple的很多项目会发布在Apple Open Source上，比如macOS、Xcode、iOS等的各个release版本都能在上面找到。 这里示例Objective-C的源码获取方式：源码的在线浏览：https://opensource.apple.com/source/objc4/ 获取tar包：https://opensource.apple.com/tarballs/objc4/ 开发工具的更多版本:https://developer.apple.com/download/more/ 接下来就可以尽情学习啦~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>Apple Opensource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Frida在iOS平台进行OC函数hook的常用方法]]></title>
    <url>%2F2019%2F08%2F12%2FFrida%2F</url>
    <content type="text"><![CDATA[frida是一款基于python + java 的hook框架，可运行在Android、iOS、Linux、Windows、MAC OS X各平台，主要使用动态二进制插桩（dynamic binary instrumentation ,DBI）技术。 动态二进制插桩技术，可以在不影响程序动态执行结果的前提下，按照用户的分析需求，在程序执行过程中插入特定分析代码，实现对程序动态执行过程的监控与分析。目前，应用广泛的动态二进制分析平台有Pin，DynamoRIO和Frida等。 这篇文章针对已经对Frida有过了解的初学者，对Frida的实际操作中常用方法进行总结。如果你还没有使用过Frida，可以先阅读Frida的官方文档，里面很详细地说明了Frida的功能和使用方式。 Python脚本的撰写1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from __future__ import print_functionimport fridaimport sys#进程名process_name = &apos;myprocess&apos;#导入的js脚本js_file_name = &apos;myhookjs.js&apos;# 自定义回调函数数据通过send（message [，data]）传递给python的on_message（消息，数据）函数，其中我们前面已经介绍过了，第一个参数是一个python字典类型，其中的message[&apos;payload&apos;]存放的就是第一个参数内容def on_message(message, data): if message[&apos;type&apos;] == &apos;send&apos;: print(message[&apos;payload&apos;]) elif message[&apos;type&apos;] == &apos;error&apos;: print(message[&apos;stack&apos;]) # hook逻辑脚本def get_js_code(): js_file = open(js_file_name) # type: BinaryIO return js_file.read()#start hereif __name__ == &apos;__main__&apos;:# 注入进程,attach传入进程名称（字符串）或者进程号（整数） process_id = 0 device = frida.get_usb_device() # 循环等待，根据进程名查找进程pid。找到执行hook while True: try: process1 = device.get_process(process_name) process_id = process1.pid #也可用 #pid = device.spawn([“com.android.chrome”]) print(process_id) break except: pass session = device.attach(process_id) # 指定JavaScript脚本 #script = session.create_script(get_js_code()% int(sys.argv[1], 16))) script = session.create_script(get_js_code()) script.on(&apos;message&apos;, on_message) script.load() # 读取返回输入 sys.stdin.read() #int()函数把字符串表示的16进制数转换成整数 #上面的jscode % int(sys.argv[1], 16)是python格式化字符串的语法 Frida hook Object-Cattach方法123456789101112131415161718192021222324var className = &quot;className&quot;;var funcName = &quot;functionName&quot;;var hook = eval(&apos;ObjC.classes.&apos; + className + &apos;[&quot;&apos; + funcName + &apos;&quot;]&apos;);#Interceptor.attach(target, callbacks)#target是NativePointer指定要拦截调用的函数的地址#如果从Frida API获取地址（例如Module.getExportByName()），Frida将处理详细信息Interceptor.attach(hook.implementation,&#123;#回调函数给出一个参数 args，可用于读取或写入参数作为NativePointer对象数组 onEnter: function(args) &#123; &#125;,#给定一个参数的回调函数，该参数 retval是NativePointer包含原始返回值的衍生对象#请注意，此对象在onLeave调用中循环使用，因此请勿在回调之外存储和使用它。如果需要存储包含的值，请进行深层复制，例如：ptr(retval.toString()) onLeave: function(retval) &#123; &#125; &#125;); 查看参数类型12#objc的函数，第0个参数是id，第1个参数是SEL，真正的参数从args[2]开始console.log(&quot;Type of arg[2] -&gt; &quot; + new ObjC.Object(args[2]).$className) 参数（返回值）NS与js类型转换12345678910111213141516171819202122232425262728293031#log Stringvar myString = new ObjC.Object(args[2]);console.log(&quot;String argument: &quot; + myString.toString());#NSString(NCFString) to String var NSString = new ObjC.Object(args[2]); var str = NSString.UTF8String();#replace js String str = str.replace(/BJP/,&quot;HZH&quot;);#log String console.log(str);#NSNumber to Int var myNumber = args[3].toInt32(); console.log(myNumber); #Converting NSData to String var data = new ObjC.Object(args[2]); var myString = data.bytes().readUtf8String(data.length()); console.log(myString); #Converting NSData to Base64String var myString = new ObjC.Object(args[2]); var base = myString.base64EncodedStringWithOptions_(0) console.log(&quot;String argument: &quot; + base); Tip: 2nd argument (number of bytes) is not required if the string data is null-terminated.#Converting NSData to Binary Datavar data = new ObjC.Object(args[2]);data.bytes().readByteArray(data.length()); 替换参数123var str =&quot;hello&quot;;var newstring = ObjC.classes.NSString.stringWithString_(str); args[2] = newstring; 替换返回值1234#用整数1337替换返回值retval.replace(1337)#用指针替换retval.replace(ptr(&quot;0x1234&quot;)) 调用函数123456var st = Memory.allocUtf8String(&quot;TESTMEPLZ!&quot;);#In NativeFunction param 2 is the return value type,#and param 3 is an array of input typesvar f = new NativeFunction(hook.implementation, &apos;pointer&apos;, [&apos;pointer&apos;,&apos;char&apos;,&apos;pointer&apos;]);#f(st,0,NSString1); 通过一个函数获得其他函数地址进行hook123456789101112131415161718192021222324252627282930var className = &quot;DTURLRequestOperation&quot;;var funcName = &quot;- rpcV1Sign:newSign:request: &quot;;var hook = eval(&apos;ObjC.classes.&apos; + className + &apos;[&quot;&apos; + funcName + &apos;&quot;]&apos;); var rpcV1SignAddr = hook.implementation;console.log(&apos;rpcV1SignAddr: &apos; + rpcV1SignAddr );/*var className2 = &quot;DTURLRequestOperation&quot;;var funcName2 = &quot;- avmpSign: &quot;;var hook2 = eval(&apos;ObjC.classes.&apos; + className2 + &apos;[&quot;&apos; + funcName2 + &apos;&quot;]&apos;); var avmpSignAddr = hook2.implementation;console.log(&apos;avmpSignAddr: &apos; + avmpSignAddr );*/#add的这个偏移是通过IDA的静态地址相减得到的var avmpSignAddr = rpcV1SignAddr.add(0x1DCE);console.log(&apos;avmpSignAddr: &apos; + avmpSignAddr);Interceptor.attach(avmpSignAddr, &#123; onEnter: function(args)&#123; console.log(&quot;onEnter&quot;); console.log(args[0]); console.log(args[1]); &#125;, onLeave: function(retval)&#123; console.log(&quot;onLeave&quot;); console.log(retval); &#125;&#125;);]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mach-O文件详解]]></title>
    <url>%2F2019%2F08%2F09%2FMach-O%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Mach-O是什么Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。类似于windows上的PE文件以及linux上的ELF文件。作为 a.out 格式的替代品，Mach-O提供更多的可扩展性和更快的符号表信息存取。大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS 是使用这种格式作为本地可执行文件、库和对象代码的例子。 Mach-O文件包含固定大小的头部(Header),几个可变大小的加载命令(LoadCommands)，一个或多个代码段(Segment)，每个代码段可以包含一个或多个代码区(Section)。 胖二进制文件为了使文件能运行在多个平台，出现了胖二进制文件(Fat Binary)，又叫通用二进制文件(Universal Binary)。使用lipo命令可以列出胖文件中的体系结构类型。胖二进制文件实际上是一个包装器(Wrapper)，一种将用于多种体系结构的Mach-O文件连接起来的简单存档。 胖二进制文件由胖头部(Fat Header)以及后面的 Mach-O 文件组成。胖头部包含一个幻数，后接一个整数值，表示二进制文件驻留在胖文件中的体系结构数量。 1234567#define FAT_MAGIC 0xcafebabe#define FAT_CIGAM 0xbebafeca /* NXSwapLong(FAT_MAGIC) */ struct fat_header &#123; uint32_t magic; /* FAT_MAGIC 标记，表示是Fat的文件类型，是固定的0xcafebabe或者是0xbebafeca */ uint32_t nfat_arch; /* number of structs that follow 包含了多个少Mach-O文件 */&#125;; 再后面是一系列胖体系结构指示符(fat_arch)，每个指示符用于胖文件中包含的一种体系结构。 1234567struct fat_arch &#123; cpu_type_t cputype; /* cpu specifier (int) 支持的CPU类型，一般有ARMV7，ARM64，X86，X86_64这几种类型 */ cpu_subtype_t cpusubtype; /* machine specifier (int) 子CPU类型*/ uint32_t offset; /* file offset to this object file 当前架构的 Mach-O 文件的数据相对于文件开头的偏移位置 */ uint32_t size; /* size of this object file 数据的大小*/ uint32_t align; /* alignment as a power of 2 数据的内存对齐边界 */&#125;; offset 在armv7中是16384(0x4000)，arm64中是4294967296 （0x10000 0000） 注意：尽管胖文件中的Mach-O文件遵循其所在体系结构的字节序，但fat_header和fat_arch总是大端字节储存。 MacOS是小端序的。 合并和瘦身Xcode 在编译 iOS 程序可以选择同时支持 ARMV7 和 ARM64，编译 macOS 程序也可以选择同时支持 x86 和 x86_64，但是如果一个程序需要同时支持 iOS 和 macOS 的时候，Xcode 不能自动生成，可以使用 lipo 命令手动对文件进行合并。 1$lipo -create test_iPhone test_macOS -output test_all 由于每个 CPU 平台都是单独的一个 Mach-O 文件，然后合成的 Fat 文件，所以体积会变大，比如某个程序我们只需要支持 ARM64，就可以把其他平台给移除掉，这样就能起到 “瘦身” 的作用，使用 lipo 命令移除其他平台。 1$lipo -thin arm64 ~/debugserver -output ~/debugserver Mach-O结构Mach-O 没有类似于 XML、YAML、JSON 等诸如此类的特殊格式，它只是一个二进制字节流，被划分为了有意义的数据块。这些块包含元信息，比如，字节顺序、cpu 类型、块的大小，等等。 典型的 Mach-O 文件包含三个区域： Header-包含该二进制文件的一般信息：字节顺序、（魔数）、cpu 类型、LoadCommands的数量等等。 LoadCommands -它是一张包含很多内容的表，内容包括区域的位置、符号表、动态符号表等。每个加载指令都包含一个元信息，比如指令类型、名称、在二进制文件中的位置等等。加载Mach-O文件时会使用这里的数据来确定内存的分布 Data-通常是对象文件中最大的部分。每一个segment的具体数据都保存在这里。主要包含代码、数据，例如符号表，动态符号表等等。 HeaderHeaders的主要作用就是帮助系统迅速的定位Mach-O文件的运行环境，以下是mach_header与mach_header_64的定义 123456789101112131415161718192021222324252627282930313233343536/* * The 32-bit mach header appears at the very beginning of the object file for * 32-bit architectures. */struct mach_header &#123; uint32_t magic; /* mach magic number identifier 和 fat_hader 里的 magic 类似，也是一个标记，32 位的值是 MH_MAGIC，64位的值是 MH_CIGAM_64。 */ cpu_type_t cputype; /* cpu specifier 与 fat_arch 里的 cputype 的含义一样。*/ cpu_subtype_t cpusubtype; /* machine specifier 与 fat_arch 里的 cpusubtype 的含义一样*/ uint32_t filetype; /* type of file 可执行文件就是 MH_EXECUTE，如果是动态库就是 MH_DYLIB */ uint32_t ncmds; /* number of load commands 表示 Mach-O 文件中 load command (加载命令)的个数 */ uint32_t sizeofcmds; /* the size of all the load commands 表示load command (加载命令) 占用的字节总大小 */ uint32_t flags; /* flags 表示dyld加载时文件的标志信息*/&#125;;​/* Constant for the magic field of the mach_header (32-bit architectures) */#define MH_MAGIC 0xfeedface /* the mach magic number */#define MH_CIGAM 0xcefaedfe /* NXSwapInt(MH_MAGIC) */​/* * The 64-bit mach header appears at the very beginning of object files for * 64-bit architectures. */struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved 系统保留字段 */&#125;;​/* Constant for the magic field of the mach_header_64 (64-bit architectures) */#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */ Mach-O文件不仅仅用来实现可执行文件，同时还用来实现了其他内容。 filetype:​12345678910111213#define MH_OBJECT 0x1 /* relocatable object file 一个中间的，可重定位的目标文件，也可用于内核扩展(传统具有.o后缀)*/#define MH_EXECUTE 0x2 /* demand paged executable file 一个标准的按需分页的可执行文件*/#define MH_FVMLIB 0x3 /* fixed VM shared library file CoreDump */#define MH_CORE 0x4 /* core file 用于存储中止程序的地址空间的文件，包含”核心转储“的核心文件(core file)*/#define MH_PRELOAD 0x5 /* preloaded executable file */#define MH_DYLIB 0x6 /* dynamically bound shared library 一个动态共享库*/#define MH_DYLINKER 0x7 /* dynamic link editor 一个特殊共享库，是一个动态链接器 */#define MH_BUNDLE 0x8 /* dynamically bound bundle file 在运行时以编程方式加载进应用程序中的插件代码*/#define MH_DYLIB_STUB 0x9 /* shared library stub for static */ /* linking only, no section contents */#define MH_DSYM 0xa /* companion file with only debug */ /* sections */#define MH_KEXT_BUNDLE 0xb /* x86_64 kexts 内核扩展文件*/ Mach-O headers还包含了一些很重要的dyld的加载参数 flags: 123456789101112131415161718192021222324252627/* Constants for the flags field of the mach_header */#define MH_NOUNDEFS 0x1 /* the object file has no undefinedreferences 目标文件没有未定义的符号，不存在链接依赖*/#define MH_INCRLINK 0x2 /* the object file is the output of an incremental link against a base file and can&apos;t be link edited again */#define MH_DYLDLINK 0x4 /* the object file is input for the 目标文件是动态链接输入文件，不能被再次静态链接 dynamic linker and can&apos;t be staticly link edited again */#define MH_BINDATLOAD 0x8 /* the object file&apos;s undefined references are bound by the dynamic linker when loaded. */#define MH_PREBOUND 0x10 /* the file has its dynamic undefined references prebound. */#define MH_SPLIT_SEGS 0x20 /* the file has its read-only and 只读 segments 和 可读写 segments 分离 read-write segments split */ #define MH_LAZY_INIT 0x40 /* the shared library init routine is to be run lazily via catching memory faults to its writeable segments (obsolete) */#define MH_TWOLEVEL 0x80 /* the image is using two-level name space bindings */​/*MH_NO_HEAP_EXECUTION 堆内存不可执行 MH_PIE 允许随机的地址空间MH_ALLOW_STACK_EXECUTION 栈内存可执行代码，一般是默认关闭的。MH_NO_HEAP_EXECUTION 堆内存无法执行代码*/ LoadCommandsHeaders 之后就是 Load Commands，其占用的内存和加载命令的总数在 Headers 中已经指出。 load_command 数据结构:​1234struct load_command &#123; uint32_t cmd; /* type of load command 加载命令类型 */ uint32_t cmdsize; /* total size of command in bytes 命令的总大小，以字节为单位*/&#125;; cmd结构类型: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* Constants for the cmd field of all load commands, the type */#define LC_SEGMENT 0x1 /* segment of this file to be mapped */#define LC_SYMTAB 0x2 /* link-edit stab symbol table info */#define LC_SYMSEG 0x3 /* link-edit gdb symbol table info (obsolete) */#define LC_THREAD 0x4 /* thread */#define LC_UNIXTHREAD 0x5 /* unix thread (includes a stack) */#define LC_LOADFVMLIB 0x6 /* load a specified fixed VM shared library */#define LC_IDFVMLIB 0x7 /* fixed VM shared library identification */#define LC_IDENT 0x8 /* object identification info (obsolete) */#define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */#define LC_PREPAGE 0xa /* prepage command (internal use) */#define LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */#define LC_LOAD_DYLIB 0xc /* load a dynamically linked shared library */#define LC_ID_DYLIB 0xd /* dynamically linked shared lib ident */#define LC_LOAD_DYLINKER 0xe /* load a dynamic linker */#define LC_ID_DYLINKER 0xf /* dynamic linker identification */#define LC_PREBOUND_DYLIB 0x10 /* modules prebound for a dynamically */ /* linked shared library */#define LC_ROUTINES 0x11 /* image routines */#define LC_SUB_FRAMEWORK 0x12 /* sub framework */#define LC_SUB_UMBRELLA 0x13 /* sub umbrella */#define LC_SUB_CLIENT 0x14 /* sub client */#define LC_SUB_LIBRARY 0x15 /* sub library */#define LC_TWOLEVEL_HINTS 0x16 /* two-level namespace lookup hints */#define LC_PREBIND_CKSUM 0x17 /* prebind checksum */ /* * load a dynamically linked shared library that is allowed to be missing * (all symbols are weak imported). */#define LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD) #define LC_SEGMENT_64 0x19 /* 64-bit segment of this file to be mapped */#define LC_ROUTINES_64 0x1a /* 64-bit image routines */#define LC_UUID 0x1b /* the uuid */#define LC_RPATH (0x1c | LC_REQ_DYLD) /* runpath additions */#define LC_CODE_SIGNATURE 0x1d /* local of code signature */#define LC_SEGMENT_SPLIT_INFO 0x1e /* local of info to split segments */#define LC_REEXPORT_DYLIB (0x1f | LC_REQ_DYLD) /* load and re-export dylib */#define LC_LAZY_LOAD_DYLIB 0x20 /* delay load of dylib until first use */#define LC_ENCRYPTION_INFO 0x21 /* encrypted segment information */#define LC_DYLD_INFO 0x22 /* compressed dyld information */#define LC_DYLD_INFO_ONLY (0x22|LC_REQ_DYLD) /* compressed dyld information only */#define LC_LOAD_UPWARD_DYLIB (0x23 | LC_REQ_DYLD) /* load upward dylib */#define LC_VERSION_MIN_MACOSX 0x24 /* build for MacOSX min OS version */#define LC_VERSION_MIN_IPHONEOS 0x25 /* build for iPhoneOS min OS version */#define LC_FUNCTION_STARTS 0x26 /* compressed table of function start addresses */#define LC_DYLD_ENVIRONMENT 0x27 /* string for dyld to treat like environment variable */#define LC_MAIN (0x28|LC_REQ_DYLD) /* replacement for LC_UNIXTHREAD */#define LC_DATA_IN_CODE 0x29 /* table of non-instructions in __text */#define LC_SOURCE_VERSION 0x2A /* source version used to build binary */#define LC_DYLIB_CODE_SIGN_DRS 0x2B /* Code signing DRs copied from linked dylibs */#define LC_ENCRYPTION_INFO_64 0x2C /* 64-bit encrypted segment information */#define LC_LINKER_OPTION 0x2D /* linker options in MH_OBJECT files */#define LC_LINKER_OPTIMIZATION_HINT 0x2E /* optimization hints in MH_OBJECT files */#ifndef __OPEN_SOURCE__#define LC_VERSION_MIN_TVOS 0x2F /* build for AppleTV min OS version */#endif /* __OPEN_SOURCE__ */#define LC_VERSION_MIN_WATCHOS 0x30 /* build for Watch min OS version */ 结构 介绍 LC_SEGMENT、LC_SEGMENT_64 将 segment 映射到进程的内存空间， LC_ID_DYLIB 动态库 LC_UUID 二进制文件 id，与符号表 uuid 对应，可用作符号表匹配 LC_LOAD_DYLINKER 启动动态加载器， LC_SYMTAB 描述在 __LINKEDIT 段的哪找字符串表、符号表 LC_CODE_SIGNATURE 代码数字签名等 LC_THREAD 开启一个MACH线程，但是不分配栈空间 LC_UNIXTHREAD 开启一个UNIX线程 LC_ENCRYPTION_INFO 加密二进制文件 LC_RPATH 程序运行时的查找路径 LC_VERSION_MIN_IPHONEOS 支持最低的 iOS 版本号 LC_MAIN 记录了可执行文件的主函数main()的位置 LC_MAIN加载命令中的Entry Offset字段+基地址（RVA选项下的文件头部地址）= IDA中左侧函数_main的地址。 123456struct entry_point_command &#123; uint32_t cmd; /* LC_MAIN only used in MH_EXECUTE filetypes */ uint32_t cmdsize; /* 24 */ uint64_t entryoff; /* file (__TEXT) offset of main() main() 函数的文件偏移*/ uint64_t stacksize;/* if not zero, initial stack size */&#125;; Segment &amp; Section加载数据时，主要加载的就是LC_SEGMET或LC_SEGMENT_64。LC_SEGMENT的数据结构是这样的。这里大部分的数据是用来帮助内核将Segment映射到虚拟内存的 segment_command: 12345678910111213struct segment_command &#123; /* for 32-bit architectures */ uint32_t cmd; /* LC_SEGMENT */ uint32_t cmdsize; /* includes sizeof section structs */ char segname[16]; /* segment name 段的名称,常见的段名称有 __PAGEZERO、__LINKEDIT、__TEXT、__DATA*/ uint32_t vmaddr; /* memory address of this segment 段要加载的虚拟内存地址 未偏移），由于 ALSR，程序会在进程加上一段偏移量（slide），真实的地址 = vm address + slide*/ uint32_t vmsize; /* memory size of this segment 段所占的虚拟内存的大小*/ uint32_t fileoff; /* file offset of this segment 段数据所有的文件中的偏移地址*/ uint32_t filesize; /* amount to map from the file 段数据的大小*/ vm_prot_t maxprot; /* maximum VM protection 页面所需要的最高内存保护*/ vm_prot_t initprot; /* initial VM protection 页面初始的内存保护*/ uint32_t nsects; /* number of sections in segment 标示了Segment中有多少secetion */ uint32_t flags; /* flags 段的标志信息*/&#125;; 12345__PAGEZERO : 可执行文件有的，动态库里没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常。这个段的大小，32位上是 0x4000，64位上是 4G。__TEXT：代码段，里面主要是存放代码的，该段是可读可执行，但是不可写。__DATA ：数据段，里面主要是存放数据，该段是可读可写，但不可执行。__LINKEDIT ：用于存放签名信息，该段是只可读，不可写不可执行。 包含需要被动态链接器使用的信息，包括符号表、字符串表、重定位项表等__OBJC 包含会被Objective Runtime使用到的一些数据 section: 12345678910111213struct section &#123; /* for 32-bit architectures */ char sectname[16]; /* name of this section section的名称，最长 16 字节大小*/ char segname[16]; /* segment this section goes in 节区所在的段名*/ uint32_t addr; /* memory address of this section 节区所在的内存地址*/ uint32_t size; /* size in bytes of this section 节区所在的大小*/ uint32_t offset; /* file offset of this section 节区所在文件偏移*/ uint32_t align; /* section alignment (power of 2) 节区的内存对齐边界*/ uint32_t reloff; /* file offset of relocation entries 重定位信息的文件偏移*/ uint32_t nreloc; /* number of relocation entries 重定位条目的个数 */ uint32_t flags; /* flags (section type and attributes) 节区的标志属性 如果是 SG_PROTECTED_VERSION_1，表示该段是经过加密的*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */&#125;; TEXT1234567891011121314151617181920212223_text：主程序代码__cstring: 硬编码的字符串 去重后的C字符串const 初始化过的常量__stubs 桩代码 符号桩。本质上是一小段会直接跳入lazybinding的表对应项指针指向的地址的代码。__stub_helper：辅助函数。上述提到的lazybinding的表中对应项的指针在没有找到真正的符号地址的时候，都指向这。__symbolstub1：用于动态链接的存根unwind_info：用于存储处理异常情况信息__objc_methname：Objective-C的方法名__objc_classname：Objective-C的类名__cstring：硬编码的字符串_DATA __data 初始化可变的数据const 没有初始化过的常量__objc_imageinfo 镜像信息 ，在运行时初始化时 objc_init，调用 load_images 加载新的镜像到 infolist 中__lazy_symbol：懒加载，延迟加载节，通过dyld_stub_binder辅助链接_got：存储引用符号的实际地址，类似于动态符号表__la_symbol_ptr: lazy-binding的指针表，每个表项中的指针一开始指向stub_helper__nl_symbol_ptr：非lazy-binding的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号__mod_init_func：初始化的全局函数地址，在主要之前被调用 初始化函数，在main之前调用__mod_term_func：结束函数地址 终止函数，在main返回之后调用__cfstring：Core Foundation用到的字符串（OC字符串）__objc_classlist 类列表__objc_classrefs 引用的类 Symbol Table &amp; String TableSymbol 表的头信息是在 LoadCommand 里的 LC_SYMTAB，其中 symoff 表示符号表的偏移。符号表的结构是一个连续的列表，其中的每一项都是一个 struct nlist。 nlist： 123456789struct nlist &#123; union &#123; uint32_t n_strx; /*符号名在字符串表中的偏移量 */ &#125; n_un; uint8_t n_type; uint8_t n_sect; /*节的索引*/ int16_t n_desc; uint32_t n_value; /*函数对应的地址*/&#125;; 动态库载入信息 Dynamic Loader Info 入口函数 Function Starts 符号表 Symbol Table 动态库符号表 Dynamic Symbol Table 字符串表 String Table Mach-O执行当你点击一个icon启动应用程序的时候，系统在内部大致做了如下几件事： 内核（OS Kernel）创建一个进程，分配虚拟的进程空间等等，加载动态链接器。 通过动态链接器加载主二进制程序引用的库、绑定符号。 启动程序 内核处理流程二进制文件加载过程下面列出来在加载二进制文件过程中依次调用的函数 1234567execve__mac_execveexec_activate_imageexec_mach_imgactload_machfileparse_machfileload_dylinker 加载dyld过程12345678910111213141516load_dylinker&#123; get_macho_vnode&#123; //读取dyld的fat_header vn_rdwr&#123;&#125; //读取dyld的mach_header vn_rdwr&#123;&#125; &#125; parse_machfile&#123; //Map the load commands into kernel memory. vn_rdwr&#123;&#125; load_segment&#123; //这里进行了slide偏移, 并且在对_TEXT segment 进行映射时重新定位了, result-&gt;mach_header, 这个的原理像elf的segment加载时, 把elf-header算在第一个segment上. map_segment&#123;&#125; &#125; &#125;&#125; dyld处理流程dyld 的处理过程在 dyld.cpp, 从 LC_MAIN 拿到地址后转到 dyld.cpp/_main() 执行 一切的开始是dyldbootstrap::start这个函数.它去调用了dyld::main函数.这个函数从外部传入Mach-O的header,在dyld::main中,dyld会去设置运行环境,配置相关的环境变量. 处理环境变量123456789101112131415161718192021222324252627uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; [...] configureProcessRestrictions(mainExecutableMH);#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( gLinkContext.processIsRestricted ) &#123; pruneEnvironmentVariables(envp, &amp;apple); // set again because envp and apple may have changed or moved setContext(mainExecutableMH, argc, argv, envp, apple); &#125; else#endif &#123; checkEnvironmentVariables(envp); defaultUninitializedFallbackPaths(envp); &#125; configureProcessRestrictions //对 ios 和 osx 做了区分, ios 默认不支持任何环境变量|checkEnvironmentVariables //检查环境变量, 之后调用下一个函数做处理|processDyldEnvironmentVariable //处理环境变量, 设置gLinkContext 这里有一个关键的过程 setContext(mainExecutableMH, argc, argv, envp, apple); 设置上下文需要使用到的全局变量. 解析macho执行文件123456789101112131415161718192021222324252627282930313233uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; [...] // instantiate ImageLoader for main executable sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath); gLinkContext.mainExecutable = sMainExecutable; gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);从 instantiateFromLoadedImage 开始解析instantiateFromLoadedImage// 检查文件格式, 加载主可执行文件, 记录该image到全局环境变量instantiateFromLoadedImage:dyld.cpp&#123; // 处理加载命令, 根据加载命令处理加载可执行文件 ImageLoaderMachO::instantiateMainExecutable:ImageLoaderMachO.cpp &#123; // 处理, 区分加载命令 ImageLoaderMachO::sniffLoadCommands:ImageLoaderMachO.cpp // 根据加载命令, 开始加载可执行文件 ImageLoaderMachOCompressed::instantiateMainExecutable:ImageLoaderMachOCompressed.cpp &#123; // 创建ImageLoaderMachOCompressed对象 ImageLoaderMachOCompressed::instantiateStart:ImageLoaderMachOCompressed.cpp // 根据加载命令填充ImageLoaderMachOCompressed对象 ImageLoaderMachOCompressed::instantiateFinish:ImageLoaderMachOCompressed.cpp &#125; &#125; // 记录image到全局变量 addImage:dyld.cpp&#125; 加载共享动态库在环境变量配置完毕后,dyld会去加载共享缓存 加载的步骤是先通过checkShareRegionDisable函数检查是否被关闭,iOS下必须开启共享缓存,如果没有被禁用,那么就会调用mapSharedCache函数去加载,当然实际加载是在该函数内调用的loadDyldCache函数,加载共三种,fast Path(已经加载的不需要再加载),slow path(第一次调用则去加载.mapCacheSystemWide),还有一种是模拟器下(simulator)的. 12345678910111213141516171819202122232425262728293031323334353637383940414243uintptr_t​_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide,​int argc, const char* argv[], const char* envp[], const char* apple[],​uintptr_t* startGlue)​&#123;​ [...]​// load shared cache​ checkSharedRegionDisable();​#if DYLD_SHARED_CACHE_SUPPORT​if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;​ mapSharedCache(); // 判断是否存在共享动态库, 如果存在直接使用, 否则进行加载, gLinkContext记录共享库地址​ &#125; else &#123;​dyld_kernel_image_info_t kernelCacheInfo;​ bzero(&amp;kernelCacheInfo.uuid[0], sizeof(uuid_t));​ kernelCacheInfo.load_addr = 0;​ kernelCacheInfo.fsobjid.fid_objno = 0;​ kernelCacheInfo.fsobjid.fid_generation = 0;​ kernelCacheInfo.fsid.val[0] = 0;​ kernelCacheInfo.fsid.val[0] = 0;​ task_register_dyld_shared_cache_image_info(mach_task_self(), kernelCacheInfo, true, false);​ &#125;​#endif 当共享缓存被加载后,接下来,dyld就会继续在main函数中加载我们的主程序也就是我们的可执行文件。我们在方法中找到instantiateFromLoadedImage这个函数,在这个函数里,dyld会实例化我们的可执行文件。它实际上是通过我们传进来的machO的header判断当前cpu是否支持当前我们的machO的架构.如果支持则调用instantiateMainExecutable函数去实例化我们的可执行文件,并添加到imageList中。 当然可执行文件的实例化是在instantiateMainExecutable函数内部实现的,在该函数内部先调用了sniffLoadCommands,这个函数通过读取loadCommand段内的信息去加载。在sniffLoadCommands中严格判断了loadCommands的条数,不能超过255条,依赖的库不能超过4095个。最后该函数会修改Compress值,外部的instantiateMainExecutable函数会通过这个值来决定加载主程序的方式。在主程序被实例化加载后,接下来dyld就会继续在main函数中去加载我们插入的动态库,具体加载函数在loadInsertedDylib里进行。 加载DYLD_INSERT_LIBRARIES的动态库1234567891011uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; [...] // load any inserted libraries if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123; for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); &#125; loadInsertedDylib： 12345678910111213141516171819202122loadInsertedDylib:dyld.cpp&#123; load:dyld.cpp &#123; loadPhase0:dyld.cpp loadPhase1:dyld.cpp loadPhase2:dyld.cpp loadPhase3:dyld.cpp loadPhase4:dyld.cpp loadPhase5:dyld.cpp loadPhase5check:dyld.cpp loadPhase5load:dyld.cpp loadPhase5stat:dyld.cpp loadPhase5load:dyld.cpp loadPhase5open:dyld.cpp loadPhase6 &#123; checkandAddImage::dyld.cpp &#125; &#125;&#125; 加载依赖动态库123456789101112uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue)&#123; [...] link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); sMainExecutable-&gt;setNeverUnloadRecursive(); if ( sMainExecutable-&gt;forceFlat() ) &#123; gLinkContext.bindFlat = true; gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding; &#125; 从 link 函数开始加载依赖动态库，在link方法中不光是链接我们的插入动态库,还会在函数内通过recursiveLoadLibraries函数循环加载我们的所有的依赖库.在加载后再Rebase每一个都添加上偏移值以得到真正的依赖库的地址也就是重定位。在链接定位后,还是在这个函数中继续对依赖库进行符号绑定,弱绑定等一系列操作,当这些都做完了主程序也就被加载链接完成。跟主程序加载链接一致,dyld当得知插入依赖库长度大于0会遍历加载链接这些库.链接完毕后就会将主程序与这些库绑定起来。 link 1234567891011121314link:dyld.cpp&#123; ImageLoader::link:ImageLoader.cpp &#123; ImageLoader::recursiveLoadLibraries:ImageLoader.cpp &#123; ImageLoaderMachO::doGetDependentLibraries:ImageLoader.cpp libraryLocator:dyld.cpp &#123; load:dyld.cpp &#125; &#125; &#125;&#125; 在这些依赖库的操作全部完成,就会调用initializeMainExecutable函数来初始化我们的主程序! 接下来会调用loadImages函数 load_images调用了call_load_methods，函数内就是循环调用我们的Objc类的load方法。接下来dyld就会调用doModInitFunctions这个函数会调用执行我们程序的特殊函数,比如全局的C++的构造方法.其实实质上就是dyld会读取Mach-O里DATA段中的init_func这个字段进行调用里面的函数。 最终一系列的操作完毕后,dyld就会去查找我们主程序的入口,对应我们Mach-O的LC_MAIN.在找到后返回一个result结果,也就调起了我们主程序的main函数,结束掉dyld_start整个流程。 参考文献: [1]解读Mach-O文件格式 [2]mach-o格式分析 [3]Mach-O 文件格式解析 [4]探秘 Mach-O 文件 [5]http://www.bubuko.com/infodetail-2243416.html [6]https://www.jianshu.com/p/8498cec10a41 [7]https://satanwoo.github.io/2017/06/13/Macho-1/ [8]https://jmpews.github.io/2017/02/27/darwin/PWN%E4%B9%8Bmacho%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/ [9]https://www.jianshu.com/p/7ad7b3ba7985 [10]https://www.jianshu.com/p/4d86de908721 [11]https://juejin.im/post/5c8e6f5c518825458b3ba6a4这个写的比较清楚]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Mach-O</tag>
        <tag>Mac OS</tag>
      </tags>
  </entry>
</search>
