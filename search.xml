<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apple Opensource 下载Apple开源项目</title>
    <url>/2019/08/16/Apple-Opensource/</url>
    <content><![CDATA[<p>在学习OC的过程中，经常需要结合源码一起理解。Apple的很多项目会发布在<a href="https://opensource.apple.com/">Apple Open Source</a>上，比如macOS、Xcode、iOS等的各个release版本都能在上面找到。</p>
<span id="more"></span>

<p>这里示例Objective-C的源码获取方式：<br><a href="https://opensource.apple.com/source/objc4/">源码的在线浏览：</a><a href="https://opensource.apple.com/source/objc4/">https://opensource.apple.com/source/objc4/</a></p>
<p><a href="https://opensource.apple.com/tarballs/objc4/">获取tar包：</a><a href="https://opensource.apple.com/tarballs/objc4/">https://opensource.apple.com/tarballs/objc4/</a></p>
<p><a href="https://developer.apple.com/download/more/">开发工具的更多版本:</a><a href="https://developer.apple.com/download/more/">https://developer.apple.com/download/more/</a> </p>
<p>接下来就可以尽情学习啦~</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>Apple Opensource</tag>
      </tags>
  </entry>
  <entry>
    <title>Arm指令</title>
    <url>/2019/09/04/Arm%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>指令集是CPU设计的灵魂，了解指令的作用对于逆向工作来说十分有益。</p>
<span id="more"></span>
<h1 id="传输数据指令"><a href="#传输数据指令" class="headerlink" title="传输数据指令"></a>传输数据指令</h1><p>CPSR状态寄存器：</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-baqh{text-align:center;vertical-align:top}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 622px">
<colgroup>
<col style="width: 78px">
<col style="width: 40px">
<col style="width: 46px">
<col style="width: 67px">
<col style="width: 27px">
<col style="width: 27px">
<col style="width: 27px">
<col style="width: 40px">
<col style="width: 36px">
<col style="width: 35px">
<col style="width: 44px">
<col style="width: 31px">
<col style="width: 31px">
<col style="width: 31px">
<col style="width: 31px">
<col style="width: 31px">
</colgroup>
  <tr>
    <th class="tg-c3ow" colspan="4">条件码标志</th>
    <th class="tg-baqh" colspan="4">保留</th>
    <th class="tg-baqh" colspan="8">控制位</th>
  </tr>
  <tr>
    <td class="tg-c3ow">31</td>
    <td class="tg-c3ow">30</td>
    <td class="tg-c3ow">29</td>
    <td class="tg-baqh">28</td>
    <td class="tg-baqh">27</td>
    <td class="tg-baqh">26</td>
    <td class="tg-baqh">25</td>
    <td class="tg-baqh">24-8</td>
    <td class="tg-baqh">7</td>
    <td class="tg-baqh">6</td>
    <td class="tg-baqh">5</td>
    <td class="tg-baqh">4</td>
    <td class="tg-baqh">3</td>
    <td class="tg-baqh">2</td>
    <td class="tg-baqh">1</td>
    <td class="tg-baqh">0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">N</td>
    <td class="tg-c3ow">Z</td>
    <td class="tg-c3ow">C</td>
    <td class="tg-baqh">V</td>
    <td class="tg-baqh"></td>
    <td class="tg-baqh"></td>
    <td class="tg-baqh"></td>
    <td class="tg-baqh"></td>
    <td class="tg-baqh">I</td>
    <td class="tg-baqh">F</td>
    <td class="tg-baqh">T</td>
    <td class="tg-baqh">M4</td>
    <td class="tg-baqh">M3</td>
    <td class="tg-baqh">M2</td>
    <td class="tg-baqh">M1</td>
    <td class="tg-baqh">M0</td>
  </tr>
  <tr>
    <td class="tg-c3ow">Less than</td>
    <td class="tg-c3ow">Zero</td>
    <td class="tg-c3ow">Carry</td>
    <td class="tg-baqh">Overflow</td>
    <td class="tg-baqh"></td>
    <td class="tg-baqh"></td>
    <td class="tg-baqh"></td>
    <td class="tg-baqh"></td>
    <td class="tg-baqh">IRQ</td>
    <td class="tg-baqh">FIQ</td>
    <td class="tg-baqh">State</td>
    <td class="tg-baqh" colspan="5">Mode bits</td>
  </tr>
</table>
数据处理指令语法

<p><code>&lt;操作&#123;&lt;cond&gt;&#125;&#123;S&#125;&gt;  &lt;Rd&gt;, &lt;Rn&gt;, &lt;Operand2&gt;</code></p>
<p>&lt;操作码&gt; &lt;目标寄存器Rd&gt; &lt;第一操作寄存器Rn&gt; &lt;第二操作数Operand2&gt;</p>
<p>第一个位置必须是寄存器，第二操作数可以是寄存器，也可以是立即数</p>
<h2 id="数据传送指令-MOV-MVN"><a href="#数据传送指令-MOV-MVN" class="headerlink" title="数据传送指令 MOV,MVN"></a>数据传送指令 MOV,MVN</h2><p>指令的几种形式：</p>
<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
</style>
<table class="tg" style="undefined;table-layout: fixed; width: 464px">
<colgroup>
<col style="width: 171px">
<col style="width: 104px">
<col style="width: 189px">
</colgroup>
  <tr>
    <th class="tg-0pky" colspan="3">从另一个寄存器、被移位的寄存器或将一个立即数加载到目的寄存器</th>
  </tr>
  <tr>
    <td class="tg-0pky">mov 寄存器、 立即数</td>
    <td class="tg-0pky">mov r0,#0x1</td>
    <td class="tg-0pky">r0 = 0x1</td>
  </tr>
  <tr>
    <td class="tg-0pky">mov 寄存器、 寄存器</td>
    <td class="tg-0pky">mov r2, r1</td>
    <td class="tg-0pky">r2 = r1</td>
  </tr>
  <tr>
    <td class="tg-0pky" colspan="3">取反后再传值,比MOV多了一步取反</td>
  </tr>
  <tr>
    <td class="tg-0lax">mov 寄存器、 立即数</td>
    <td class="tg-0lax">mvn r0,#0x1</td>
    <td class="tg-0lax">r0 = ~0x1</td>
  </tr>
  <tr>
    <td class="tg-0lax">mov 寄存器、 寄存器</td>
    <td class="tg-0lax">mvn r2, r1</td>
    <td class="tg-0lax">r2 = ~r1</td>
  </tr>
</table>

<p>movx 其中 x 可以是下面的字符:</p>
<p>l用于32位的长字值<br>w用于16位的字值   把 16 位立即数放到寄存器的低16位，高16位清0</p>
<p>t用于16位的字值     把 16 位立即数放到寄存器的高16位，低 16位不影响<br>b用于8位的字节值</p>
<h2 id="算术运算指令-ADD-ADC-SUB-SBC-MUL"><a href="#算术运算指令-ADD-ADC-SUB-SBC-MUL" class="headerlink" title="算术运算指令 ADD/ADC , SUB/SBC , MUL"></a>算术运算指令 ADD/ADC , SUB/SBC , MUL</h2><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;ADD加法指令</span><br><span class="line">mov r0, #1</span><br><span class="line">mov r1, #1</span><br><span class="line">add r2, r1, r0　　;r2 = r1 + r0</span><br><span class="line">add r2, r1, #2　　;r2 = r1 + 2</span><br><span class="line">;ADC带进位加法指令,即除了加两个数以外,还要把CPSR的C值也要带进来</span><br><span class="line">ADDS R0,R1,R2; R0=R1+R2,ADDS中S表示把进位结果写入CPSR</span><br><span class="line">ADC R5,R3,R4 ;R5=R3+R4+C</span><br></pre></td></tr></table></figure>
<h3 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;SUB减法指令</span><br><span class="line">mov r0, #5</span><br><span class="line">mov r1, #3</span><br><span class="line">sub r2, r0, r1　　;r2 = r0 - r1</span><br><span class="line">sub r2, r1, #2　　;r2 = r1 - 2</span><br><span class="line">;SBC带进位减法指令,即除了加两个数以外,还要把CPSR的C值也要带进来,类似ADC</span><br><span class="line">SUBS R0,R1,R2; R0=R1-R2,SUBS中S表示把进位结果写入CPSR</span><br><span class="line">SBC R5,R3,R4 ;R5=R3-R4-C</span><br></pre></td></tr></table></figure>
<h3 id="MUL"><a href="#MUL" class="headerlink" title="MUL"></a>MUL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;MUL 乘法指令</span><br><span class="line">MUL R0,R1,R2; R0=R1*R2</span><br><span class="line">MUL R0,R1,#3 ;R0=R1*3</span><br></pre></td></tr></table></figure>

<h2 id="位操作指令-AND-ORR-TST-BIC"><a href="#位操作指令-AND-ORR-TST-BIC" class="headerlink" title="位操作指令 AND,ORR, TST,BIC"></a>位操作指令 AND,ORR, TST,BIC</h2><h3 id="AND-与操作"><a href="#AND-与操作" class="headerlink" title="AND 与操作"></a>AND 与操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND R0,R1,R2; R0=R1 &amp; R2</span><br><span class="line">AND R0,R1,#0xFF ;R0=R1 &amp; 0xFF</span><br></pre></td></tr></table></figure>
<h3 id="ORR-或操作"><a href="#ORR-或操作" class="headerlink" title="ORR 或操作"></a>ORR 或操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ORR R0,R1,R2; R0=R1 | R2</span><br><span class="line">ORR R0,R1,#0xFF ;R0=R1 | 0xFF</span><br></pre></td></tr></table></figure>
<h3 id="TST-测试某一位是否为1-并把结果写入CPSR-供下一句使用"><a href="#TST-测试某一位是否为1-并把结果写入CPSR-供下一句使用" class="headerlink" title="TST 测试某一位是否为1,并把结果写入CPSR,供下一句使用"></a>TST 测试某一位是否为1,并把结果写入CPSR,供下一句使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TST R1,#0xffe;   等同于if(R1 &amp; 0xffe)</span><br><span class="line">TST R1,#%1;测试最低位是否为1,%表示二进制</span><br></pre></td></tr></table></figure>
<h3 id="BIC-清位操作"><a href="#BIC-清位操作" class="headerlink" title="BIC 清位操作"></a>BIC 清位操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BIC   R0，R0，＃0xF          ； 等同于 R0 &amp;=~(0xF)</span><br><span class="line">BIC   R0，R0，＃％1011   ； 该指令清除 R0 中的位 0 1  3，其余的位保持;   %表示是二进制,0x表示十六进制</span><br></pre></td></tr></table></figure>

<h1 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h1><p>cmp是比较指令,cmp的功能相当于减法指令。它不保存结果，只是影响相应的标志位。其他的指令通过识别这些被影响的标志位来得知比较结果。</p>
<p>cmp指令格式:   cmp 操作对象1, 操作对象2</p>
<p>不同大小数进行cmp指令时的结果：</p>
<ol>
<li><p>cmp eax, eax (两数相等)</p>
</li>
<li><p>cmp  eax, ebx (eax - ebx = 03h)  </p>
</li>
<li><p>cmp  al, bl (al - bl = -03h)  </p>
</li>
</ol>
<p>我们怎么判断大小呢？若执行指令后</p>
<p>（1）ZF</p>
<p>  ZF=1 ，则说明两个数相等，因为zero为1说明结果为0。</p>
<p>（2）CF</p>
<p>当无符号时：</p>
<p>CF=1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1 &lt; oprd2</p>
<p>CF=0 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1&gt;oprd2</p>
<p>当有符号时：</p>
<p>若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1&gt;oprd2</p>
<p>若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1 &lt; oprd2</p>
<p>若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1 &lt; oprd2</p>
<p>若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1 &gt; oprd2</p>
<h1 id="beq-amp-bnq"><a href="#beq-amp-bnq" class="headerlink" title="beq &amp; bnq"></a>beq &amp; bnq</h1><h2 id="beq指令"><a href="#beq指令" class="headerlink" title="beq指令"></a>beq指令</h2><p>beq指令格式:   beq  地址</p>
<p>若标志位ZF为1，则跳转；若为0，则不跳转 （若前面有cmp指令，则意味着相等跳转，不等执行下一步）</p>
<h2 id="bnq指令"><a href="#bnq指令" class="headerlink" title="bnq指令"></a>bnq指令</h2><p>bnq指令格式:   bnq  地址</p>
<p>若标志位ZF为0，则跳转；若为1，则不跳转 （若前面有cmp指令，则意味着不等跳转，相等执行下一步）</p>
<h1 id="寄存器入栈及出栈指令-POP-PUSH"><a href="#寄存器入栈及出栈指令-POP-PUSH" class="headerlink" title="寄存器入栈及出栈指令 POP PUSH"></a>寄存器入栈及出栈指令 POP PUSH</h1><p>实现低寄存器、可选的 LR 寄存器入栈寄存器、可选的 PC寄存器出栈操作，堆栈地址由 SP 寄存设置,堆栈是满递减堆栈.</p>
<p>指令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH &#123;reglist[,LR]&#125;               reglist 入栈/出栈低寄存器列表,即 R0~R7        LR 入栈时的可选寄存器</span><br><span class="line">POP &#123;reglist[,PC]&#125;                 PC 出栈时的可选寄存器</span><br></pre></td></tr></table></figure>
<h1 id="STR指令"><a href="#STR指令" class="headerlink" title="STR指令"></a>STR指令</h1><p>STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。</p>
<p>指令格式： STR{条件} 源寄存器，&lt;存储器地址&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STR R0，[R1]，＃8             ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。</span><br><span class="line">STR R0，[R1，＃8]             ；将R0中的字数据写入以R1＋8为地址的存储器中。”</span><br><span class="line">str     r1, [r0]                       ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中</span><br></pre></td></tr></table></figure>

<h1 id="条件指令"><a href="#条件指令" class="headerlink" title="条件指令"></a>条件指令</h1><p><a href="https://www.anquanke.com/post/id/86422">https://www.anquanke.com/post/id/86422</a></p>
<h1 id="特殊的跟0的比较跳转指令"><a href="#特殊的跟0的比较跳转指令" class="headerlink" title="特殊的跟0的比较跳转指令"></a>特殊的跟0的比较跳转指令</h1><p>大于等于0（BGEZ），大于0（BGTZ），小于等于0（BLEZ），还有小于0（BLTZ）</p>
<h1 id="分支指令将一个寄存器的值跟0比较"><a href="#分支指令将一个寄存器的值跟0比较" class="headerlink" title="分支指令将一个寄存器的值跟0比较"></a>分支指令将一个寄存器的值跟0比较</h1><p>BEQ,BGE,BGT,BLE,BLT,BNE</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++预处理指令</title>
    <url>/2019/08/16/C:C++%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<p>预处理指令是我们写在程序代码中的给预处理器(preprocessor)的命令，该指令将在编译器进行编译之前对源代码做某些转换。预处理指令以#号开头（# 号必须是该行除了任何空白字符外的第一个字符），#后是指令关键字，在关键字和# 号之间允许存在任意个数的空白字符，整行语句构成了一条预处理指令。</p>
<p>使用预处理功能便于程序的修改、阅读、移植和调试，也便于实现模块化程序设计。</p>
<span id="more"></span>

<h1 id="常见的预处理指令"><a href="#常见的预处理指令" class="headerlink" title="常见的预处理指令"></a>常见的预处理指令</h1><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#</td>
<td align="left">空指令，无任何效果</td>
</tr>
<tr>
<td align="left">#include</td>
<td align="left">包含一个源代码文件</td>
</tr>
<tr>
<td align="left">#define</td>
<td align="left">定义宏</td>
</tr>
<tr>
<td align="left">#undef</td>
<td align="left">取消已定义的宏</td>
</tr>
<tr>
<td align="left">#if</td>
<td align="left">如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#ifdef</td>
<td align="left">如果宏已经定义，则编译下面代码</td>
</tr>
<tr>
<td align="left">#ifndef</td>
<td align="left">如果宏没有定义，则编译下面代码</td>
</tr>
<tr>
<td align="left">#elif</td>
<td align="left">如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#endif</td>
<td align="left">结束一个#if……#else条件编译块</td>
</tr>
</tbody></table>
<h1 id="include"><a href="#include" class="headerlink" title="#include"></a>#include</h1><p>当预处理器找到一个#include 指令时，它用指定文件的全部内容替换这条语句。声明包含一个文件有两种方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;file&quot;  or   #include &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>两种表达的唯一区别是编译器应该在什么路经下寻找指定的文件。</p>
<ul>
<li><p>第一种情况下，文件名被写在双引号中，编译器首先在包含这条指令的文件所在的目录下进行寻找，如果找不到指定文件，编译器再到被配置的默认路径下（也就是标准头文件路径下）进行寻找。</p>
</li>
<li><p>如果文件名是在尖括号 &lt;&gt; 中，编译器会直接到默认标准头文件路径下寻找。</p>
</li>
</ul>
<h1 id="define"><a href="#define" class="headerlink" title="#define"></a>#define</h1><p>  #define可以被用来生成宏定义常量(defined constantants 或 macros)，它的形式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define [MacroName] [MacroValue]</span><br></pre></td></tr></table></figure>
<p>它的作用是定义一个叫做name 的宏定义，然后每当在程序中遇到这个名字的时候，它就会被value代替。</p>
<p>取消宏则是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#undef [MacroName]</span><br></pre></td></tr></table></figure>
<h2 id="简单的define定义"><a href="#简单的define定义" class="headerlink" title="简单的define定义"></a>简单的define定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MAXTIME 1000</span><br></pre></td></tr></table></figure>
<p>一个简单的MAXTIME就定义好了，它代表1000，假设在程序里面写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(i &lt; MAXTIME)&#123;.........&#125;</span><br></pre></td></tr></table></figure>
<p>编译器在处理这个代码之前会对MAXTIME进行处理替换为1000。</p>
<p>这种定义看起来相似于普通的常量定义CONST，但也有着不同，由于define的定义更像是简单的文本替换，而不是作为一个量来使用，这个问题在以下反映的尤为突出。</p>
<h2 id="define的“函数定义”"><a href="#define的“函数定义”" class="headerlink" title="define的“函数定义”"></a>define的“函数定义”</h2><p>define能够像函数那样接受一些參数，例如以下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define max(x,y) (x)&gt;(y)?(x):(y);</span><br></pre></td></tr></table></figure>
<p>这个定义就将返回两个数中较大的那个，看到了吗？由于这个“函数”没有类型检查，就好像一个函数模板似的，当然，它绝对没有模板那么安全就是了。能够作为一个简单的模板来使用而已。</p>
<p>可是这样做的话存在隐患，样例例如以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define Add(a,b) a+b;</span><br></pre></td></tr></table></figure>
<p>在一般使用的时候是没有问题的，可是假设遇到如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c * Add(a,b) * d</span><br></pre></td></tr></table></figure>
<p>的时候就会出现故障，代数式的本意是a+b然后去和c，d相乘，可是由于使用了define（它仅仅是一个简单的替换），所以式子实际上变成了：c*a + b*d</p>
<p>另外举一个样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define pin (int*);</span><br><span class="line">pin a,b;</span><br></pre></td></tr></table></figure>
<p>本意是a和b都是int型指针，可是实际上变成int* a,b; a是int型指针，而b是int型变量。<br>这是应该使用typedef来取代define，这样a和b就都是int型指针了。<br>所以我们在定义的时候，养成一个良好的习惯，建议全部的层次都要加括号。</p>
<h2 id="define的单行定义"><a href="#define的单行定义" class="headerlink" title="define的单行定义"></a>define的单行定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define A(x) T_##x</span><br><span class="line">#define B（x) #@x</span><br><span class="line">#define C（x) #x</span><br></pre></td></tr></table></figure>
<p>我们如果：x=1，则有：</p>
<p>A(1)——&gt; T_1 （T_##x,##符号是记号粘黏符号，将前后的字符粘黏起来。）<br>B(1)——&gt; ‘1’ （ #@x , #@ 符号会将宏的参数进行字符串字面量化，并且加‘’号）<br>C(1)——&gt; “1” （ #x ,#符号会将宏的参数进行字符串字面量化，并且加””号）</p>
<h2 id="define的多行定义"><a href="#define的多行定义" class="headerlink" title="define的多行定义"></a>define的多行定义</h2><p>define能够替代多行的代码，比如MFC中的宏定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define MACRO(arg1, arg2)  do&#123;   \ </span><br><span class="line">   \ </span><br><span class="line">stmt1;   \ </span><br><span class="line">stmt2;   \ </span><br><span class="line">   \ </span><br><span class="line">&#125;   while(0) </span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>使用#define声明多行宏函数与声明单行宏函数没有本质区别；</li>
<li>多行声明时，回车换行前要加上字符‘\’，即“[enter]”，注意字符‘\’后要紧跟回车键，中间不能有空格或其他字符。</li>
<li>另外，在Linux操作系统中 “[enter]”称为跳脱字符，意思是一行写不完的时候可以使用跳脱字符换行，但对于操作系统而言，它认为你并没有换行。</li>
</ol>
<h2 id="define和typedef的差别"><a href="#define和typedef的差别" class="headerlink" title="define和typedef的差别"></a>define和typedef的差别</h2><p>typedef是一种用来声明自定义数据类型,配合各种原有数据类型达到简化编程目的的类型定义关键字，可以使用typedef为已有数据类型取别名。</p>
<p><strong>两者的区别：</strong></p>
<ol>
<li>执行时间不同</li>
</ol>
<ul>
<li>关键字 typedef 在编译阶段有效, 犹豫是在编译阶段, 因此 typededf 有类型检查的功能.</li>
<li>define 是宏定义, 发生在预处理阶段, 也就是编译之前, 它只是进行简单而机械的字符串替换, 而不进行任何检查.</li>
</ul>
<ol start="2">
<li>功能不同</li>
</ol>
<ul>
<li>typedef 用来定义类型的别名, 这些类型不止包含内部类型(init,char等), 还包括自定义类型(如struct), 可以起到使类型易于记忆的功能.如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int (*PF) (const char *, const char *); </span><br><span class="line">//定义一个指向函数的指针的数据类型PF，其中函数返回值为int，参数为const char *. 这个就和定义 Block 很像了</span><br></pre></td></tr></table></figure></li>
<li>typedef 可定义机器无关的类型，如，你可以定义一个浮点类型，在目标机器上它可以获得最高的精度。如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef long double REAL; </span><br><span class="line"></span><br><span class="line">//在不支持 long double 的机器上，该 typedef 看起来会是下面这样：</span><br><span class="line"></span><br><span class="line">typedef double REAL; </span><br><span class="line"></span><br><span class="line">//并且，在连 double 都不支持的机器上，该 typedef 看起来会是这样：</span><br><span class="line"></span><br><span class="line">typedef float REAL; </span><br></pre></td></tr></table></figure></li>
<li>define 不止可以为类型取别名, 还可以定义常量, 变量, 编译开关等.</li>
</ul>
<ol start="3">
<li>作用域不同</li>
</ol>
<ul>
<li>#define 没有作用域的限制, 只要是之前预定义过的宏, 在以后的程序中都可以使用。而 typedef 有自己的作用域.<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void fun() &#123;</span><br><span class="line">  #define A int</span><br><span class="line">&#125;</span><br><span class="line">void gun() &#123;</span><br><span class="line">//在这里也可以使用A，因为宏替换没有作用域，</span><br><span class="line">//但如果上面用的是typedef，那这里就不能用A ，不过一般不在函数内使用typedef</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>对指针的操作不同</li>
</ol>
<ul>
<li>二者修饰指针类型时, 作用不同<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Typedef int * pint；  </span><br><span class="line">#define PINT int *  </span><br><span class="line">Const pint p；//p不可更改，p指向的内容可以更改，相当于 int * const p;  </span><br><span class="line">Const PINT p；//p可以更改，p指向的内容不能更改，相当于 const int *p；或 int const *p；  </span><br><span class="line">pint s1, s2; //s1和s2都是int型指针  </span><br><span class="line">PINT s3, s4; //相当于int * s3，s4；只有一个是指针。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="条件编译——-ifdef-ifndef-if-endif-else-and-elif"><a href="#条件编译——-ifdef-ifndef-if-endif-else-and-elif" class="headerlink" title="条件编译——#ifdef, #ifndef, #if, #endif, #else and #elif"></a>条件编译——#ifdef, #ifndef, #if, #endif, #else and #elif</h1><p>这些指令可以使程序的一部分在某种条件下被忽略。</p>
<h2 id="ifdef"><a href="#ifdef" class="headerlink" title="#ifdef"></a>#ifdef</h2><p> #ifdef 可以使一段程序只有在某个指定常量已经被定义了的情况下才被编译，无论被定义的值是什么。它的操作是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef name</span><br><span class="line">// code here</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef MAX_WIDTH</span><br><span class="line">char str[MAX_WIDTH];</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>在这个例子中，语句char str[MAX_WIDTH]; 只有在宏定义常量MAX_WIDTH 已经被定义的情况下才被编译器考虑，不管它的值是什么。如果它还没有被定义，这一行代码则不会被包括在程序中。</p>
<h2 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a>#ifndef</h2><p> #ifndef 起相反的作用：在指令#ifndef 和 #endif 之间的代码只有在某个常量没有被定义的情况下才被编译，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef MAX_WIDTH</span><br><span class="line">#define MAX_WIDTH 100</span><br><span class="line">#endif</span><br><span class="line">char str[MAX_WIDTH];</span><br></pre></td></tr></table></figure>
<p>这个例子中，如果当处理到这段代码的时候MAX_WIDTH 还没有被定义，则它会被定义为值100。而如果它已经被定义了，那么它会保持原值 (因为#define 语句这一行不会被执行) 。</p>
<h2 id="if-else-和-elif"><a href="#if-else-和-elif" class="headerlink" title="#if, #else 和 #elif"></a>#if, #else 和 #elif</h2><p>指令#if, #else 和 #elif (elif = else if) 用来使得其后面所跟的程序部分只有在特定条件下才被编译。这些条件只能够是常量表达式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if MAX_WIDTH&gt;200</span><br><span class="line">#undef MAX_WIDTH</span><br><span class="line">#define MAX_WIDTH 200</span><br><span class="line"></span><br><span class="line">#elsif MAX_WIDTH&lt;50</span><br><span class="line">#undef MAX_WIDTH</span><br><span class="line">#define MAX_WIDTH 50</span><br><span class="line"></span><br><span class="line">#else</span><br><span class="line">#undef MAX_WIDTH</span><br><span class="line">#define MAX_WIDTH 100</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">char str[MAX_WIDTH];</span><br></pre></td></tr></table></figure>
<p>注意看这一连串的指令 #if, #elsif 和 #else 是怎样以 #endif 结尾的。</p>
<h2 id="常常使用宏来调试代码"><a href="#常常使用宏来调试代码" class="headerlink" title="常常使用宏来调试代码:"></a>常常使用宏来调试代码:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 0</span><br><span class="line">///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)</span><br><span class="line">#else</span><br><span class="line">///&lt; 新的代码(或函数)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#ifndef JOE_DEBUG</span><br><span class="line">///&lt; 新的代码(或函数)</span><br><span class="line">#else</span><br><span class="line">///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)</span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line">#ifdef Q_DEBUG</span><br><span class="line">///&lt; 新的代码(或函数)</span><br><span class="line">#else</span><br><span class="line">///&lt; 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="line"><a href="#line" class="headerlink" title="#line"></a>#line</h1><p>当我们编译一段程序的时候，如果有错误发生，编译器会在错误前面显示出错文件的名称以及文件中的第几行发生的错误。</p>
<p>指令#line 可以使我们对这两点进行控制，也就是说当出错时显示文件中的行数以及我们希望显示的文件名。它的格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#line number &quot;filename&quot;</span><br></pre></td></tr></table></figure>
<p>这里number 是将会赋给下一行的新行数。它后面的行数从这一点逐个递增。</p>
<p>filename 是一个可选参数，用来替换自此行以后出错时显示的文件名，直到有另外一个#line指令替换它或直到文件的末尾。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#line 1 &quot;assigning variable&quot;</span><br><span class="line">int a?;</span><br></pre></td></tr></table></figure>
<p>这段代码将会产生一个错误，显示为在文件”assigning variable”, line 1 。</p>
<h1 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h1><p>这个指令将中断编译过程并返回一个参数中定义的出错信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef __cplusplus</span><br><span class="line">#error A C++ compiler is required</span><br><span class="line">#endif</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 这个例子中如果__cplusplus没有被定义就会中断编译过程。</p>
<h1 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a>#pragma</h1><p>这个指令是用来对编译器进行配置的，针对你所使用的平台和编译器而有所不同。要了解更多信息，请参考你的编译器手册。<br>如果你的编译器不支持某个#pragma的特定参数，这个参数会被忽略，不会产生出错。</p>
<h1 id="预定义宏-Predefined-macro-names"><a href="#预定义宏-Predefined-macro-names" class="headerlink" title="预定义宏 (Predefined macro names)"></a>预定义宏 (Predefined macro names)</h1><p>以下宏名称在任何时候都是定义好的：</p>
<table>
<thead>
<tr>
<th align="left">macro</th>
<th align="left">value</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LINE</td>
<td align="left">整数值，表示当前正在编译的行在源文件中的行数。</td>
</tr>
<tr>
<td align="left">FILE</td>
<td align="left">字符串，表示被编译的源文件的文件名。</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">一个格式为 “Mmm dd yyyy” 的字符串，存储编译开始的日期。</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">一个格式为 “hh:mm:ss” 的字符串，存储编译开始的时间。</td>
</tr>
<tr>
<td align="left"><strong>STDC</strong></td>
<td align="left">如果编译器接受标准C，那么值为1. （整型）</td>
</tr>
<tr>
<td align="left">__cplusplus</td>
<td align="left">整数值，所有C++编译器都定义了这个常量为某个值。如果这个编译器是完全遵守C++标准的，它的值应该等于或大于199711L，具体值取决于它遵守的是哪个版本的标准。</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h1><p><a href="https://www.cnblogs.com/zi-xing/p/4550246.html">https://www.cnblogs.com/zi-xing/p/4550246.html</a><br><a href="https://www.cnblogs.com/lcchuguo/p/4005360.html">https://www.cnblogs.com/lcchuguo/p/4005360.html</a><br><a href="https://www.kancloud.cn/kancloud/cplusplus/62276">https://www.kancloud.cn/kancloud/cplusplus/62276</a><br><a href="http://blog.sina.com.cn/s/blog_4fc2fb600102yds4.html">http://blog.sina.com.cn/s/blog_4fc2fb600102yds4.html</a><br><a href="https://www.jianshu.com/p/53ac91a23979">https://www.jianshu.com/p/53ac91a23979</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Frida在iOS平台进行OC函数hook的常用方法</title>
    <url>/2019/08/12/Frida/</url>
    <content><![CDATA[<p>frida是一款基于python + java 的hook框架，可运行在Android、iOS、Linux、Windows、MAC OS X各平台，主要使用动态二进制插桩（dynamic binary instrumentation ,DBI）技术。</p>
<p>动态二进制插桩技术，可以在不影响程序动态执行结果的前提下，按照用户的分析需求，在程序执行过程中插入特定分析代码，实现对程序动态执行过程的监控与分析。目前，应用广泛的动态二进制分析平台有Pin，DynamoRIO和Frida等。</p>
<p>这篇文章针对已经对Frida有过了解的初学者，对Frida的实际操作中常用方法进行总结。如果你还没有使用过Frida，可以先阅读Frida的<a href="https://www.frida.re/docs/home/">官方文档</a>，里面很详细地说明了Frida的功能和使用方式。</p>
<span id="more"></span>

<h1 id="Python脚本的撰写"><a href="#Python脚本的撰写" class="headerlink" title="Python脚本的撰写"></a>Python脚本的撰写</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import frida</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">#进程名</span><br><span class="line">process_name = &#x27;myprocess&#x27;</span><br><span class="line">#导入的js脚本</span><br><span class="line">js_file_name = &#x27;myhookjs.js&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 自定义回调函数</span><br><span class="line">数据通过send（message [，data]）传递给python的on_message（消息，数据）函数，其中我们前面已经介绍过了，</span><br><span class="line">第一个参数是一个python字典类型，其中的message[&#x27;payload&#x27;]存放的就是第一个参数内容</span><br><span class="line"></span><br><span class="line">def on_message(message, data):</span><br><span class="line">    if message[&#x27;type&#x27;] == &#x27;send&#x27;:</span><br><span class="line">        print(message[&#x27;payload&#x27;])</span><br><span class="line">    elif message[&#x27;type&#x27;] == &#x27;error&#x27;:</span><br><span class="line">        print(message[&#x27;stack&#x27;])</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"># hook逻辑脚本</span><br><span class="line">def get_js_code():</span><br><span class="line">    js_file = open(js_file_name)  # type: BinaryIO</span><br><span class="line">    return js_file.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#start here</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 注入进程,attach传入进程名称（字符串）或者进程号（整数）</span><br><span class="line">	process_id   =  0</span><br><span class="line">	device = frida.get_usb_device()</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"># 循环等待，根据进程名查找进程pid。找到执行hook</span><br><span class="line">	while True:</span><br><span class="line">		try:</span><br><span class="line">			process1 = device.get_process(process_name)</span><br><span class="line">			process_id = process1.pid</span><br><span class="line">      </span><br><span class="line">      #也可用</span><br><span class="line"> 			#pid = device.spawn([“com.android.chrome”])</span><br><span class="line">      </span><br><span class="line">			print(process_id)</span><br><span class="line">			break</span><br><span class="line">		except:</span><br><span class="line">			pass</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">	session = device.attach(process_id)</span><br><span class="line">  # 指定JavaScript脚本</span><br><span class="line">	#script = session.create_script(get_js_code()% int(sys.argv[1], 16)))</span><br><span class="line">  script = session.create_script(get_js_code())</span><br><span class="line">	script.on(&#x27;message&#x27;, on_message)    </span><br><span class="line">	script.load()</span><br><span class="line">  # 读取返回输入</span><br><span class="line">	sys.stdin.read()</span><br><span class="line">  </span><br><span class="line">  #int()函数把字符串表示的16进制数转换成整数</span><br><span class="line">	#上面的jscode % int(sys.argv[1], 16)是python格式化字符串的语法</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Frida-hook-Object-C"><a href="#Frida-hook-Object-C" class="headerlink" title="Frida hook Object-C"></a>Frida hook Object-C</h1><h2 id="attach方法"><a href="#attach方法" class="headerlink" title="attach方法"></a>attach方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">var className = &quot;className&quot;;</span><br><span class="line">var funcName = &quot;functionName&quot;;</span><br><span class="line">var hook = eval(&#x27;ObjC.classes.&#x27; + className + &#x27;[&quot;&#x27; + funcName + &#x27;&quot;]&#x27;);</span><br><span class="line"></span><br><span class="line">#Interceptor.attach(target, callbacks)</span><br><span class="line">#target是NativePointer指定要拦截调用的函数的地址</span><br><span class="line">#如果从Frida API获取地址（例如Module.getExportByName()），Frida将处理详细信息</span><br><span class="line"></span><br><span class="line">Interceptor.attach(hook.implementation,&#123;</span><br><span class="line"></span><br><span class="line">#回调函数给出一个参数  args，可用于读取或写入参数作为NativePointer对象数组</span><br><span class="line">		onEnter: function(args)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">#给定一个参数的回调函数，该参数 retval是NativePointer包含原始返回值的衍生对象</span><br><span class="line">#请注意，此对象在onLeave调用中循环使用，因此请勿在回调之外存储和使用它。如果需要存储包含的值，请进行深层复制，例如：ptr(retval.toString())</span><br><span class="line">		onLeave: function(retval)</span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="查看参数类型"><a href="#查看参数类型" class="headerlink" title="查看参数类型"></a>查看参数类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#objc的函数，第0个参数是id，第1个参数是SEL，真正的参数从args[2]开始</span><br><span class="line">console.log(&quot;Type of arg[2] -&gt; &quot; + new ObjC.Object(args[2]).$className)</span><br></pre></td></tr></table></figure>
<h2 id="参数（返回值）NS与js类型转换"><a href="#参数（返回值）NS与js类型转换" class="headerlink" title="参数（返回值）NS与js类型转换"></a>参数（返回值）NS与js类型转换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#log String</span><br><span class="line">var myString = new ObjC.Object(args[2]);</span><br><span class="line">console.log(&quot;String argument: &quot; + myString.toString());</span><br><span class="line"></span><br><span class="line">#NSString(NCFString) to String </span><br><span class="line">  var NSString = new ObjC.Object(args[2]);</span><br><span class="line">  var str = NSString.UTF8String();</span><br><span class="line"></span><br><span class="line">#replace js String</span><br><span class="line">  str = str.replace(/BJP/,&quot;HZH&quot;);</span><br><span class="line">#log String</span><br><span class="line">  console.log(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#NSNumber to Int</span><br><span class="line">  var myNumber = args[3].toInt32();</span><br><span class="line">  console.log(myNumber);</span><br><span class="line">  </span><br><span class="line">#Converting NSData to String</span><br><span class="line">		var data = new ObjC.Object(args[2]);</span><br><span class="line">		var myString = data.bytes().readUtf8String(data.length());</span><br><span class="line">		console.log(myString);</span><br><span class="line"> #Converting NSData to Base64String   </span><br><span class="line">		var myString = new ObjC.Object(args[2]); var base = myString.base64EncodedStringWithOptions_(0)</span><br><span class="line">		console.log(&quot;String argument: &quot; + base);    </span><br><span class="line">    </span><br><span class="line">Tip: 2nd argument (number of bytes) is not required if the string data is null-terminated.</span><br><span class="line"></span><br><span class="line">#Converting NSData to Binary Data</span><br><span class="line">var data = new ObjC.Object(args[2]);</span><br><span class="line">data.bytes().readByteArray(data.length());</span><br></pre></td></tr></table></figure>

<h2 id="替换参数"><a href="#替换参数" class="headerlink" title="替换参数"></a>替换参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str =&quot;hello&quot;;</span><br><span class="line">var newstring = ObjC.classes.NSString.stringWithString_(str);	</span><br><span class="line">args[2] =  newstring;</span><br></pre></td></tr></table></figure>
<h2 id="替换返回值"><a href="#替换返回值" class="headerlink" title="替换返回值"></a>替换返回值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用整数1337替换返回值</span><br><span class="line">retval.replace(1337)</span><br><span class="line">#用指针替换</span><br><span class="line">retval.replace(ptr(&quot;0x1234&quot;))</span><br></pre></td></tr></table></figure>

<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var st = Memory.allocUtf8String(&quot;TESTMEPLZ!&quot;);</span><br><span class="line"></span><br><span class="line">#In NativeFunction param 2 is the return value type,</span><br><span class="line">#and param 3 is an array of input types</span><br><span class="line">var f = new NativeFunction(hook.implementation, &#x27;pointer&#x27;, [&#x27;pointer&#x27;,&#x27;char&#x27;,&#x27;pointer&#x27;]);</span><br><span class="line">#f(st,0,NSString1);</span><br></pre></td></tr></table></figure>
<h2 id="通过一个函数获得其他函数地址进行hook"><a href="#通过一个函数获得其他函数地址进行hook" class="headerlink" title="通过一个函数获得其他函数地址进行hook"></a>通过一个函数获得其他函数地址进行hook</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var className = &quot;DTURLRequestOperation&quot;;</span><br><span class="line">var funcName = &quot;- rpcV1Sign:newSign:request: &quot;;</span><br><span class="line">var hook = eval(&#x27;ObjC.classes.&#x27; + className + &#x27;[&quot;&#x27; + funcName + &#x27;&quot;]&#x27;);    </span><br><span class="line">var rpcV1SignAddr = hook.implementation;</span><br><span class="line">console.log(&#x27;rpcV1SignAddr: &#x27; + rpcV1SignAddr );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">var className2 = &quot;DTURLRequestOperation&quot;;</span><br><span class="line">var funcName2 = &quot;- avmpSign: &quot;;</span><br><span class="line">var hook2 = eval(&#x27;ObjC.classes.&#x27; + className2 + &#x27;[&quot;&#x27; + funcName2 + &#x27;&quot;]&#x27;);    </span><br><span class="line">var avmpSignAddr = hook2.implementation;</span><br><span class="line">console.log(&#x27;avmpSignAddr: &#x27; + avmpSignAddr );</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#add的这个偏移是通过IDA的静态地址相减得到的</span><br><span class="line">var avmpSignAddr = rpcV1SignAddr.add(0x1DCE);</span><br><span class="line">console.log(&#x27;avmpSignAddr: &#x27; + avmpSignAddr);</span><br><span class="line">Interceptor.attach(avmpSignAddr, &#123;</span><br><span class="line">    onEnter: function(args)&#123;</span><br><span class="line">    	console.log(&quot;onEnter&quot;);</span><br><span class="line">        console.log(args[0]);</span><br><span class="line">        console.log(args[1]);</span><br><span class="line">    &#125;,</span><br><span class="line">    onLeave: function(retval)&#123;</span><br><span class="line">    	console.log(&quot;onLeave&quot;);</span><br><span class="line">        console.log(retval);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title>Homebrew安装与使用</title>
    <url>/2019/08/19/Home-brew%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://brew.sh/">Homebrew</a>是一款MacOS平台下自由及开放源代码的软件包管理系统，用以简化macOS系统上的软件安装过程。可以理解为MacOS版的yum或apt-get吧</p>
<span id="more"></span>

<h2 id="Homebrew安装"><a href="#Homebrew安装" class="headerlink" title="Homebrew安装"></a>Homebrew安装</h2><p>Homebrew是基于Ruby的，安装过程也非常很简单，只需执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<p>Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序，之后在终端就可以使用 brew 命令了。</p>
<h2 id="Homebrew使用"><a href="#Homebrew使用" class="headerlink" title="Homebrew使用"></a>Homebrew使用</h2><h3 id="常见的Homebrew命令"><a href="#常见的Homebrew命令" class="headerlink" title="常见的Homebrew命令"></a>常见的Homebrew命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看brew的帮助</span><br><span class="line">brew –help</span><br><span class="line"> </span><br><span class="line">//查看Homebrew版本</span><br><span class="line">brew -v</span><br><span class="line">//安装软件</span><br><span class="line">brew install &lt;packageName&gt;</span><br><span class="line"> </span><br><span class="line">//卸载软件</span><br><span class="line">brew uninstall &lt;packageName&gt;</span><br><span class="line"> </span><br><span class="line">//搜索软件</span><br><span class="line">brew search &lt;packageName&gt;</span><br><span class="line"> </span><br><span class="line">//显示已经安装软件列表</span><br><span class="line">brew list</span><br><span class="line"> </span><br><span class="line">//更新软件，把所有的Formula目录更新，并且会对本机已经安装并有更新的软件用*标明。</span><br><span class="line">brew update</span><br><span class="line"> </span><br><span class="line">//更新某具体软件</span><br><span class="line">brew upgrade &lt;packageName&gt;</span><br><span class="line"> </span><br><span class="line">//查看软件信息</span><br><span class="line">brew [info | home] [FORMULA...]</span><br><span class="line"> </span><br><span class="line">//删除程序，和upgrade一样，单个软件删除和所有程序老版删除。</span><br><span class="line">brew cleanup &lt;packageName&gt;</span><br><span class="line">brew cleanup</span><br><span class="line"> </span><br><span class="line">//查看那些已安装的程序需要更新</span><br><span class="line"></span><br><span class="line">brew outdated</span><br></pre></td></tr></table></figure>
<h3 id="brew卸载软件及依赖"><a href="#brew卸载软件及依赖" class="headerlink" title="brew卸载软件及依赖"></a>brew卸载软件及依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ brew tap beeftornado/rmtree</span><br><span class="line"></span><br><span class="line">$ brew rmtree &lt;package&gt;</span><br></pre></td></tr></table></figure>
<h3 id="brew安装指定版本软件"><a href="#brew安装指定版本软件" class="headerlink" title="brew安装指定版本软件"></a>brew安装指定版本软件</h3><p>首先把Homebrew克隆下来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Homebrew/homebrew-core</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log master -- Formula/qemu.rb</span><br></pre></td></tr></table></figure>
<p>在提交记录里查找到需要的的提交版本,如qemu2.12.0的提交版本为:commit 22ee44faa55709ca466b5b17330ca72a55a2e8dd</p>
<p>将版本回滚到需要的版本，如将qemu版本回滚到2.12.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout 22ee44faa55709ca466b5b17330ca72a55a2e8dd </span><br></pre></td></tr></table></figure>
<p>将qemu.rb拷贝出来，执行<code>brew install /Path/qemu.rb</code> 安装</p>
<h3 id="切换brew源"><a href="#切换brew源" class="headerlink" title="切换brew源"></a>切换brew源</h3><p>如果brew的速度太慢可以切换brew源，<a href="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git">清华源</a>：<a href="https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git">https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</a></p>
<p>通过以下操作进行替换和还原</p>
<ol>
<li>替换  brew.git/ homebrew-core.git仓库地址<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 替换成清华的 brew.git 仓库地址:</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"></span><br><span class="line"># 替换成清华的 homebrew-core.git 仓库地址:</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure></li>
<li> 还原 brew.git/ homebrew-core.git 仓库地址<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 还原为官方提供的 brew.git 仓库地址</span><br><span class="line">cd &quot;$(brew --repo)&quot;</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/brew.git</span><br><span class="line"></span><br><span class="line"># 还原为官方提供的 homebrew-core.git 仓库地址</span><br><span class="line">cd &quot;$(brew --repo)/Library/Taps/homebrew/homebrew-core&quot;</span><br><span class="line">git remote set-url origin https://github.com/Homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line">#更新</span><br><span class="line">brew update</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title>Hook技术的原理和实现</title>
    <url>/2019/09/12/Hook%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>Mac10.14编译Lineage16.0 for Xiaomi6(sagit)</title>
    <url>/2021/03/10/Mac10-14%E7%BC%96%E8%AF%91Lineage16-0-for-Xiaomi6-sagit/</url>
    <content><![CDATA[<p>由于内网服务器各种不方便，最后选择购入1T的移动SSD在本地编译了。虚拟机的话需要本机至少24G内存，条件不满足；而且安卓代码对MAC的支持比较友好了，所以决定就在mac环境下编译啦</p>
<p>lineage16.0不再支持小米6，因此换成17.1 ：<a href="https://www.lineageoslog.com/16.0/sagit">https://www.lineageoslog.com/16.0/sagit</a></p>
<span id="more"></span>

<h1 id="准备磁盘"><a href="#准备磁盘" class="headerlink" title="准备磁盘"></a>准备磁盘</h1><p>三星T5 SSD 使用MAC的磁盘工具重新挂载后抹除 ，使磁盘<font color="red">可写</font>，可<font color="red">区分大小写</font></p>
<h1 id="repo工具下载及添加到环境变量"><a href="#repo工具下载及添加到环境变量" class="headerlink" title="repo工具下载及添加到环境变量"></a>repo工具下载及添加到环境变量</h1><p>使用<a href="https://mirrors.tuna.tsinghua.edu.cn/help/lineageOS/">清华的镜像源</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">​</span><br><span class="line">mkdir ~/bin</span><br><span class="line">​</span><br><span class="line">#本地下载repo，使用jumper的上传下到服务器上</span><br><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; /bin/repo/</span><br><span class="line">chmod a+x ~/bin/repo</span><br><span class="line">​</span><br><span class="line">export REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#x27;</span><br><span class="line">export PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure>
<h1 id="代码同步"><a href="#代码同步" class="headerlink" title="代码同步"></a>代码同步</h1><ol>
<li>创建一个大小写敏感的分区,或者创建一个大小写敏感的镜像文件,用来存放 同步下来的源码.</li>
<li>进入存放源码的路径</li>
<li>在当前路径下初始化源码仓库:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/lineageOS/LineageOS/android.git -b lineage-16.0</span><br></pre></td></tr></table></figure>

<p>打开<code>.repo/manifest.xml</code>，将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;remote name=&quot;github&quot; </span><br><span class="line">        fetch=&quot;..&quot; </span><br><span class="line">        review=&quot;review.lineageos.org&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;remote name=&quot;github&quot; </span><br><span class="line">        fetch=&quot;https://github.com/&quot; /&gt; </span><br><span class="line">&lt;remote name=&quot;lineage&quot; </span><br><span class="line">        fetch=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/lineageOS/&quot; </span><br><span class="line">        review=&quot;review.lineageos.org&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;remote name=&quot;aosp&quot; </span><br><span class="line">        fetch=&quot;https://android.googlesource.com&quot;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;remote name=&quot;aosp&quot; </span><br><span class="line">        fetch=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/AOSP&quot;</span><br></pre></td></tr></table></figure>
<p>将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;default revision=&quot;...&quot; </span><br><span class="line">         remote=&quot;github&quot;</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;default revision=&quot;...&quot; </span><br><span class="line">         remote=&quot;lineage&quot;</span><br></pre></td></tr></table></figure>

<h2 id="同步源码树（以后只需执行这条命令来同步）："><a href="#同步源码树（以后只需执行这条命令来同步）：" class="headerlink" title="同步源码树（以后只需执行这条命令来同步）："></a>同步源码树（以后只需执行这条命令来同步）：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo sync -j8 -c</span><br><span class="line">​</span><br><span class="line">#若出现error: Exited sync due to fetch errors</span><br><span class="line">#使用</span><br><span class="line">repo sync -j8 -f --force-sync</span><br><span class="line">​</span><br><span class="line">#若出现bundle错误</span><br><span class="line">#使用</span><br><span class="line">repo sync -j8 --no-clone-bundle</span><br></pre></td></tr></table></figure>
<h2 id="快速同步"><a href="#快速同步" class="headerlink" title="快速同步"></a>快速同步</h2><p>或直接下载repo包，解压后cd到lineage目录 直接执行<code>repo sync -l</code>提取源码</p>
<h1 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install findutils</span><br><span class="line">brew install gpg</span><br><span class="line">brew install Imagemagick</span><br><span class="line">​</span><br><span class="line">#sed</span><br><span class="line">brew install gnu-sed   </span><br><span class="line">export PATH=/usr/local/opt/findutils/libexec/gnubin:/usr/local/opt/gnu-sed/libexec/gnubin:$PATH</span><br><span class="line">​</span><br><span class="line">#安装 Xcode 命令行工具：</span><br><span class="line">xcode-select --install</span><br><span class="line">​</span><br><span class="line">#通过 macports.org 安装 MacPorts。</span><br><span class="line">#https://www.macports.org/install.php</span><br><span class="line">​</span><br><span class="line">export PATH=/opt/local/bin:$PATH</span><br><span class="line">​</span><br><span class="line">#通过 MacPorts 获取 Make、Git 和 GPG 程序包：</span><br><span class="line">sudo port -d sync</span><br><span class="line">POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg</span><br><span class="line">​</span><br><span class="line">#设置文件描述符数量上限</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">#添加此行</span><br><span class="line"># set the number of open files to be 1024</span><br><span class="line">ulimit -S -n 1024</span><br><span class="line">​</span><br><span class="line">​</span><br><span class="line">#优化编译环境</span><br><span class="line">brew install Ccache</span><br><span class="line">​</span><br><span class="line">在源代码树的根目录下执行以下命令：</span><br><span class="line">export USE_CCACHE=1</span><br><span class="line">export CCACHE_DIR=/Volumes/Samsung_T5/android/build_cache/.ccache</span><br><span class="line">export CCACHE_COMPRESS=1</span><br><span class="line">ccache -M 100G</span><br><span class="line">​</span><br><span class="line">#error</span><br><span class="line">export ALLOW_MISSING_DEPENDENCIES=true</span><br></pre></td></tr></table></figure>
<h2 id="idea源码阅读"><a href="#idea源码阅读" class="headerlink" title="idea源码阅读"></a>idea源码阅读</h2><p>源码根目录执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mmma development/tools/idegen/</span><br><span class="line">#在/out/host/darwin-x86/framework下生成idegen.jar</span><br></pre></td></tr></table></figure>

<h3 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h3><p>出现error 缺少macos10.14的sdk，到<a href="https://github.com/phracker/MacOSX-SDKs/releases/tag/10.15">https://github.com/phracker/MacOSX-SDKs/releases/tag/10.15</a> 下载 ,放到/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs下。</p>
<p>出现error:device/xiaomi/sagit/rro_overlays/SagitWifiOverlay/Android.bp:1:1: unrecognized module type “runtime_resource_overlay”，把/device/xiaomi/sagit/rro_overlays/SagitWifiOverlay 目录删除。</p>
<p>遇到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install error：python@3.9: undefined method `on_macos&#x27; for #&lt;PourBottleCheck:0x00007f86e80a3220&gt;</span><br></pre></td></tr></table></figure>
<p>执行 <code>brew update -v</code></p>
<p>运行无误生成  out/host/darwin-x86/framework/idegen.jar</p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd croot</span><br><span class="line">​</span><br><span class="line">./development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>
<p>会在源代码根目录生成下列文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 用于IntelliJ IDEA的项目配置文件</span><br><span class="line">android.ipr</span><br><span class="line">android.iml</span><br><span class="line">​</span><br><span class="line">// 用于Eclipse的项目配置文件</span><br><span class="line">.classpath</span><br></pre></td></tr></table></figure>
<p>使用IntelliJ IDEA，则打开工程，浏览选择刚才生成的android.ipr文件即可。</p>
<h1 id="xiaomi6-vendor包"><a href="#xiaomi6-vendor包" class="headerlink" title="xiaomi6 vendor包"></a>xiaomi6 vendor包</h1><p><a href="https://github.com/rim99/android_proprietary_vendor_xiaomi_sagit">android_proprietary_vendor_xiaomi_sagit</a></p>
<p><a href="https://github.com/MoKee/android_vendor_xiaomi_msm8998-common">android_vendor_xiaomi_msm8998-common</a></p>
<p>放到vendor/xiaomi/ 目录下 目录名分别为 msm8998-common 和sagit<br><a href="https://wiki.lineageos.org/devices/dipper/build#extract-proprietary-blobs">https://wiki.lineageos.org/devices/dipper/build#extract-proprietary-blobs</a></p>
<p><a href="https://wiki.lineageos.org/extracting_blobs_from_zips.html">从设备提取</a></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>修改.repo/local_manifest/roomservice.xml ,增加以下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;project name=&quot;LineageOS/android_device_xiaomi_sagit&quot; path=&quot;device/xiaomi/sagit&quot; remote=&quot;github&quot; /&gt;</span><br><span class="line">&lt;project name=&quot;LineageOS/android_device_xiaomi_msm8998-common&quot; path=&quot;device/xiaomi/msm8998-common&quot; remote=&quot;github&quot; /&gt;</span><br><span class="line">&lt;project name=&quot;LineageOS/android_kernel_xiaomi_msm8998&quot; path=&quot;kernel/xiaomi/msm8998&quot; remote=&quot;github&quot; /&gt;</span><br><span class="line">&lt;project name=&quot;xiaomi-msm8998/vendor_xiaomi&quot; path=&quot;vendor/xiaomi&quot; remote=&quot;github&quot;  /&gt;</span><br></pre></td></tr></table></figure>
<p>再<code>repo sync</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source build/envsetup.sh</span><br><span class="line">​</span><br><span class="line">breakfast sagit</span><br><span class="line">​</span><br><span class="line">croot</span><br><span class="line">​</span><br><span class="line">brunch sagit </span><br></pre></td></tr></table></figure>
<p>如果出现python相关的错，记得把python切换到python2</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Android</tag>
        <tag>Lineage</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下使用Charles进行HTTP/HTTPS抓包</title>
    <url>/2021/01/19/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8Charles%E8%BF%9B%E8%A1%8CHTTP-HTTPS%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<p>Charles是MacOS上的常用的抓包工具，常用于移动端的网络抓包分析。本文将介绍如何使用Charles对安卓/iOS设备的HTTP/HTTPS包进行抓取。</p>
<span id="more"></span>

<h1 id="Charles安装与配置"><a href="#Charles安装与配置" class="headerlink" title="Charles安装与配置"></a>Charles安装与配置</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>最新的Charles工具，下载地址：<a href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a></p>
<h2 id="配置代理端口号"><a href="#配置代理端口号" class="headerlink" title="配置代理端口号"></a>配置代理端口号</h2><p>Proxy -&gt; Proxy Settings -&gt; Port，port可以随便指定，这里取8888</p>
<h2 id="配置HTTPS证书"><a href="#配置HTTPS证书" class="headerlink" title="配置HTTPS证书"></a>配置HTTPS证书</h2><h3 id="添加SSL-Proxying"><a href="#添加SSL-Proxying" class="headerlink" title="添加SSL Proxying"></a>添加SSL Proxying</h3><p>Proxy -&gt; SSL Proxying Settings -&gt;勾选“Enable SSL Proxying”，并点击下方的Add，可以这样配置：</p>
<h3 id="安装Charles证书到Mac"><a href="#安装Charles证书到Mac" class="headerlink" title="安装Charles证书到Mac"></a>安装Charles证书到Mac</h3><p>Help–&gt;SSL Proxying→Install Charles Root Certificate </p>
<p>此时会启动“钥匙串访问”APP，搜索框搜所刚安装好的证书，证书名字：Charles Proxy CA。</p>
<p>选中该证书，点击显示简介</p>
<p>更改证书信任权限。更改为始终信任，并关闭窗口输入密码保存</p>
<p>移动复制该证书到“系统”里面</p>
<p>结束！可以抓包了</p>
<h1 id="Android-设置"><a href="#Android-设置" class="headerlink" title="Android 设置"></a>Android 设置</h1><h2 id="Android代理设置"><a href="#Android代理设置" class="headerlink" title="Android代理设置"></a>Android代理设置</h2><p>以小米+lineageOS为例</p>
<p>设置 -&gt; WI-FI -&gt; 网络详情 -&gt; 编辑</p>
<p>配置代理，IP设为电脑的IP，端口输入之前设置的端口（此为8888），点击存储</p>
<p>（mac 查看ip：ifconfig en0 ）</p>
<h2 id="Android-7-0-以下设置"><a href="#Android-7-0-以下设置" class="headerlink" title="Android 7.0 以下设置"></a>Android 7.0 以下设置</h2><p>打开Safari浏览器，访问：<code>chls.pro/ssl</code></p>
<p>手机会提示下载文件，点击安装</p>
<h2 id="Android-7-0-以上设置"><a href="#Android-7-0-以上设置" class="headerlink" title="Android 7.0 以上设置"></a>Android 7.0 以上设置</h2><p>Android 7.0及以上为何不能抓取到Https请求的明文数据？</p>
<p>其实Charles上显示确实抓到了包，但是当我们看抓包的详细数据时会发现报错:<br> “You may need to configure your browser or application to trust the Charles Root Certificate. See SSL Proxying in the Help menu”。</p>
<p>Charles说手机端没有信任Charles的根证书，但是我们手机上已经安装了Charles根证书了，为什么会这样？</p>
<p>原来在Android 7.0(API 24 ) ，有一个名为“Network Security Configuration”的新安全功能。这个新功能的目标是允许开发人员在不修改应用程序代码的情况下自定义他们的网络安全设置。如果应用程序运行的系统版本高于或等于24，并且targetSdkVersion&gt;=24，则只有系统(system)证书才会被信任。所以用户(user)导入的Charles根证书是不被信任的。</p>
<h3 id="方法一：将证书提升为系统证书"><a href="#方法一：将证书提升为系统证书" class="headerlink" title="方法一：将证书提升为系统证书"></a>方法一：将证书提升为系统证书</h3><p>参考：<a href="https://blog.csdn.net/doctor_who2004/article/details/105718889">android 7.0以上charles https抓包</a></p>
<p>将手机进行Root</p>
<p>将下载的pem证书文件传到到电脑上，并执行以下命令得到证书的md5值</p>
<p><code>openssl x509 -subject_hash_old -in &lt;file_name&gt;</code></p>
<p>第一行： 即为md5值。</p>
<p>将charles-proxy-ssl-proxying-certificate.pem重命名为:<code>&lt;8位md值&gt;.&lt;0&gt;</code>，这里的md5值为上一步得到的。</p>
<p>Android系统根目录下的证书名字格式如下：<code>&lt;8位md值&gt;.&lt;0&gt;</code></p>
<p>将上面步骤产生证书push到手机目录：<code>/system/etc/security/cacerts</code></p>
<p>push中如果遇到错误 例如remount of the / superblock failed: Permission denied或者file only read等。</p>
<p>解决办法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb root</span><br><span class="line">$ adb disable-verity</span><br><span class="line">$ adb reboot</span><br><span class="line">$ adb root</span><br></pre></td></tr></table></figure>

<p>在 设置-&gt;安全-&gt;加密与凭据-&gt;信任的凭据 的系统标签页看到你新加入的证书，将其启用即可顺利抓包</p>
<p>按照系统证书的方法，遇到问题：read-only file system android</p>
<p>尝试adb root ，报错 adbd cannot run as root in production builds 安装adbd Insecure 依然不行</p>
<h3 id="方法二：利用VirtualXposed"><a href="#方法二：利用VirtualXposed" class="headerlink" title="方法二：利用VirtualXposed"></a>方法二：利用VirtualXposed</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/162823763">Android 7.0+使用VirtualXposed+Charles进行抓包</a></p>
<p>注意，0.18.2以后的VirtualXposed 不支持32位app</p>
<h1 id="iOS-设置"><a href="#iOS-设置" class="headerlink" title="iOS 设置"></a>iOS 设置</h1><h2 id="iPhone代理设置"><a href="#iPhone代理设置" class="headerlink" title="iPhone代理设置"></a>iPhone代理设置</h2><p>设置→WIFI –&gt;点击Wi-Fi旁边的ⓘ</p>
<p>滑到底部，点击配置代理</p>
<p>配置代理，IP设为电脑的IP，端口输入之前设置的端口（此为8888），点击存储</p>
<p>（mac 查看ip：ifconfig en0 ）</p>
<h2 id="iPhone证书安装"><a href="#iPhone证书安装" class="headerlink" title="iPhone证书安装"></a>iPhone证书安装</h2><p>打开Safari浏览器，访问：chls.pro/ssl，此时电脑上连接提示，点击allow允许</p>
<p>手机会提示下载描述文件，点击允许</p>
<p>安装完成后，点击 设置–&gt;通用→关于本机，下拉到底部，点击证书 信任设置，把刚信任开关打开。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下编译V8</title>
    <url>/2020/07/15/Mac%E4%B8%8B%E7%BC%96%E8%AF%91V8/</url>
    <content><![CDATA[<p>V8是一个由Google开发的开源JavaScript引擎，用于Google Chrome及Chromium中。由于需要使用到V8，来在自己的C++项目中执行js，因此想要学习了解下V8的实现原理。打算先在Mac本地上编译运行起来，之后再尝试交叉编译。</p>
<span id="more"></span>

<h1 id="下载V8源码"><a href="#下载V8源码" class="headerlink" title="下载V8源码"></a>下载V8源码</h1><p>参考<a href="https://v8.dev/docs/source-code#using-git">官方手册</a></p>
<p>注意：不要直接从v8仓库使用git clone命令下载代码，这样下载下来的代码是无效的，会缺失很多东西，要使用官方提供的工具depot_tools</p>
<h2 id="安装-depot-tools"><a href="#安装-depot-tools" class="headerlink" title="安装 depot_tools"></a>安装 depot_tools</h2><p>所需的 gn (配置生成工具) 和 nijia (构建工具) 都在这个仓库里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Clone depot_tools 仓库 </span><br><span class="line">$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"># 导出环境变量</span><br><span class="line">$ export PATH=&quot;$PATH:/path/to/depot_tools&quot;</span><br></pre></td></tr></table></figure>
<h2 id="下载所需依赖"><a href="#下载所需依赖" class="headerlink" title="下载所需依赖"></a>下载所需依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$mkdir v8 &amp;&amp; cd v8</span><br><span class="line"># 配置 v8 仓库</span><br><span class="line">$ gclient config https://chromium.googlesource.com/v8/v8</span><br><span class="line"># 需要科学上网，然后等待很长一段时间...</span><br><span class="line">$ gclient sync</span><br></pre></td></tr></table></figure>
<p>结束后会发现有v8库文件的文件夹</p>
<h2 id="修改mini-SDK"><a href="#修改mini-SDK" class="headerlink" title="修改mini-SDK"></a>修改mini-SDK</h2><p>由于对要求 MAC OSX SDK&gt;10.15，而我的xcode带的是10.12。所以需要修改</p>
<p>查看sdk版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Xcode中添加的SDK版本</span><br><span class="line">$xcodebuild -showsdks</span><br></pre></td></tr></table></figure>
<p>v8/build/config/mac/mac_sdk_overrides.gni文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_sdk_min_from_env = getenv(&quot;FORCE_MAC_SDK_MIN&quot;)</span><br><span class="line">declare_args() &#123;</span><br><span class="line">  # Minimum supported version of the Mac SDK.</span><br><span class="line">  if (_sdk_min_from_env == &quot;&quot;) &#123;</span><br><span class="line">    mac_sdk_min = &quot;10.15&quot; # 将这里修改成了10.12</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mac_sdk_min = _sdk_min_from_env</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>参考<a href="https://v8.dev/docs/build-gn">官方手册</a></p>
<h2 id="方式一：gm脚本"><a href="#方式一：gm脚本" class="headerlink" title="方式一：gm脚本"></a>方式一：gm脚本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#配置别名：</span><br><span class="line">$ alias gm=/path/to/v8/tools/dev/gm.py</span><br><span class="line">$ gm x64.release</span><br><span class="line">$ gm x64.release.check</span><br></pre></td></tr></table></figure>
<h2 id="方式二：手动编译"><a href="#方式二：手动编译" class="headerlink" title="方式二：手动编译"></a>方式二：手动编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成ninja文件</span><br><span class="line">$ gn args out/foo</span><br><span class="line">或指定参数</span><br><span class="line">$ gn gen out/foo --args=&#x27;is_debug=false target_cpu=&quot;x64&quot; v8_target_cpu=&quot;arm64&quot; use_goma=true&#x27;</span><br><span class="line">​</span><br><span class="line">#或使用v8gen脚本</span><br><span class="line">#配置别名：</span><br><span class="line">$ alias v8gen=/path/to/v8/tools/dev/v8gen.py</span><br><span class="line">$ v8gen -b &#x27;V8 Linux64 - debug builder&#x27; -m client.v8 foo</span><br><span class="line">或：</span><br><span class="line">$ v8gen foo</span><br><span class="line">​</span><br><span class="line">$ v8gen x64.release.sample</span><br><span class="line">​</span><br><span class="line">#使用ninja来编译：</span><br><span class="line">$ ninja -C out/foo</span><br><span class="line">如果要在c++中嵌入v8，使用下面的</span><br><span class="line">$ ninja -C out.gn/x64.release.sample v8_monolith</span><br><span class="line">​</span><br></pre></td></tr></table></figure>


<h2 id="替换libtool"><a href="#替换libtool" class="headerlink" title="替换libtool"></a>替换libtool</h2><p>这里我编译出错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[48/1364] LIBTOOL-STATIC obj/libv8_libbase.a</span><br><span class="line">FAILED: obj/libv8_libbase.a</span><br><span class="line">rm -f obj/libv8_libbase.a &amp;&amp; TOOL_VERSION=1594099062 python ../../build/toolchain/mac/filter_libtool.py /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool -static -D  -o obj/libv8_libbase.a -filelist obj/libv8_libbase.a.rsp</span><br><span class="line">error: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool: unknown option character `D&#x27; in: -D</span><br><span class="line">Usage: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool -static [-] file [...] [-filelist listfile[,dirname]] [-arch_only arch] [-sacLT] [-no_warning_for_no_symbols]</span><br></pre></td></tr></table></figure>
<p>看样子是xcode的libtool工具出错，将新版本xcode(11.5)里带的libtool拷贝到原来的xcode 的/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/libtool目录下成功解决问题</p>
<h2 id="移除i18n"><a href="#移除i18n" class="headerlink" title="移除i18n"></a>移除i18n</h2><p>遇到报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FAILED: obj/v8_base_without_compiler/js-number-format.o</span><br></pre></td></tr></table></figure>
<p>icu67 移除了 getAllFieldPositions 这个 API，需要后续添加一个 icu67.1 的 patch</p>
<p>因为用不到国际化的模块，将 i18n 从编译选项中移除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编辑配置</span><br><span class="line">$ gn args out.gn/x64.release.sample</span><br><span class="line"># 增加一行：</span><br><span class="line"># v8_enable_i18n_support = false</span><br><span class="line"># 再次构建</span><br><span class="line">$ ninja -C out.gn/x64.release.sample v8_monolith</span><br></pre></td></tr></table></figure>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>编译一下 samples/hello-world.cc</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ samples/hello-world.cc -o hello-world \</span><br><span class="line">-I. -I./include \</span><br><span class="line">-L./out.gn/x64.release.sample/obj -lv8_monolith \</span><br><span class="line">-std=c++11</span><br></pre></td></tr></table></figure>
<p>执行一下，如果有如下输出就是编译成功了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./hello-world</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">Hello, World!</span><br><span class="line">3 + 4 = 7</span><br></pre></td></tr></table></figure>
<h1 id="编译引用v8库的-cc文件"><a href="#编译引用v8库的-cc文件" class="headerlink" title="编译引用v8库的.cc文件"></a>编译引用v8库的.cc文件</h1><p>G++命令</p>
<p>sample：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ -I. -Iinclude samples/hello-world.cc -o hello_world -lv8_monolith -Lout.gn/x64.release.sample/obj/ -pthread -std=c++0x</span><br></pre></td></tr></table></figure>
<p>命令解释：</p>
<p>-std= 决定使用的语言标准，当编译C和C++的时候该选择支持配置。 上述命令中的<code>c++0x</code>表示： 语言标准使用即将发布的ISO c++ 0x标准的工作草案。此选项支持可能包含在c++ 0x中的实验性特性。工作草案在不断地变化，如果GCC的未来版本不属于c++ 0x标准，那么由这个标志启用的任何特性都可能被删除。 更多标准请参考：g++</p>
<p>-pthread 使用POSIX线程库添加对多线程的支持。此选项为预处理器和链接器设置标志。它不影响编译器生成的目标代码的线程安全性，也不影响与其提供的库的线程安全性。这些是特定于HP-UX的标志。 </p>
<p>-I dir 将目录dir添加到要搜索头文件的目录列表中。在系统标准包含目录之前，搜索由**-I*<em>指定的目录。如果目录</em>dir<em>是标准的系统包含目录，则忽略该选项，以确保不会破坏系统目录的默认搜索顺序和对系统头文件的特殊处理。如果</em>dir*以”=”开头，则”=”将被sysroot前缀替换。 </p>
<p>-o file 指定输出文件。这与将file指定为cpp的第二个非选项参数相同。gcc 对第二个非选项参数的有另一种解释，因此必须使用-o指定输出文件</p>
<p> -llibrary -l library 链接时搜索名为library的库。(第二种指定库文件的方式仅适用于POSIX遵从性，不建议使用。) 在命令中编写这个选项的位置会有所不同;链接器按照指定的顺序搜索和处理库和目标文件。因此,<code>foo.o -lz bar.o</code>是在文件foo.o之后搜索库z。但在bar.o之前。如果bar.o是引用到了z库中的函数，这些函数是不能被加载。 链接器搜索库的标准目录列表，实际上是一个名为<code>liblibrary.a</code>的文件。然后链接器使用这个文件，就好像它是通过名称精确指定的一样。 </p>
<p>搜索的目录包括几个标准系统目录，以及您使用-L指定的任何目录。 通常以这种方式找到的文件是库文件——其成员是目标文件的归档文件。链接器通过扫描成员来处理存档文件，这些成员定义了到目前为止已经引用但尚未定义的符号。但是，如果找到的文件是一个普通的对象文件，则以通常的方式链接它。</p>
<p> -Ldir 添加<code>dir</code>目录到搜索目录列表中去供<code>-l</code>使用</p>
<h1 id="交叉编译-V8-for-Raspberry-Pi"><a href="#交叉编译-V8-for-Raspberry-Pi" class="headerlink" title="交叉编译 V8 for Raspberry Pi"></a>交叉编译 V8 for Raspberry Pi</h1><h2 id="下载toolchain-for-RPi-on-MAC"><a href="#下载toolchain-for-RPi-on-MAC" class="headerlink" title="下载toolchain for RPi on MAC"></a>下载<a href="https://github.com/MikeMitterer/xc-gcc_4.9.3_mac_rpi">toolchain for RPi on MAC</a></h2><p>用法：</p>
<ol>
<li>直接解压 </li>
<li>加入环境变量<code>export PATH=$PATH:/Users/guomengyuan/Downloads/xc-gcc_4.9.3_mac_rpi-master/arm-rpi-linux-gnueabihf/bin</code></li>
<li>修改名称，将所有的arm-rpi-linux-xxx 改为arm-linux-xxx</li>
</ol>
<h2 id="gn构建ninja文件"><a href="#gn构建ninja文件" class="headerlink" title="gn构建ninja文件"></a>gn构建ninja文件</h2><p><code>gn gen out.gn/arm --args=&#39;is_debug=false is_component_build=true symbol_level=0 target_os=&quot;linux&quot; target_cpu=&quot;arm&quot; v8_target_cpu=&quot;arm&quot;&#39;</code></p>
<h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><p><code>ninja -C out.gn/arm</code></p>
<h1 id="v8引擎基本概念简述"><a href="#v8引擎基本概念简述" class="headerlink" title="v8引擎基本概念简述"></a>v8引擎基本概念简述</h1><h2 id="isolate"><a href="#isolate" class="headerlink" title="isolate"></a>isolate</h2><p>表示的一个独立的V8虚拟机，拥有自己的堆栈。所以才取名isolate，意为“隔离”。在v8中使用以下语法进行初始化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Isolate* isolate = Isolate::New(create_params); </span><br></pre></td></tr></table></figure>
<h2 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h2><p>handle是指向对象的指针，在V8中，所有的对象都通过handle来引用，handle主要用于V8的垃圾回收机制。在 V8 中，handle 分为两种：持久化 (Persistent)handle 和本地 (Local)handle，持久化 handle 存放在堆上，而本地 handle 存放在栈上。比如我要使用本地句柄，句柄指向的内容是一个string，那么你要这么定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Local&lt;String&gt; source = String::NewFromUtf8(isolate, &quot;&#x27;Hello&#x27; + &#x27;, World&#x27;&quot;, NewStringType::kNormal).ToLocalChecked();</span><br></pre></td></tr></table></figure>
<p>鉴于一个个释放Handle比较麻烦，v8又提供了HandleScope来批量处理，你可以在handle之前声明好：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HandleScope handle_scope(isolate);</span><br></pre></td></tr></table></figure>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>context 是一个执行器环境，使用 context 可以将相互分离的 JavaScript 脚本在同一个 V8 实例中运行，而互不干涉。在运行 JavaScript 脚本是，需要显式的指定 context 对象。创建上下文，需要这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个上下文 </span><br><span class="line">Local&lt;Context&gt; context = Context::New(isolate); </span><br><span class="line">// 进入上下文编译和运行脚本 </span><br><span class="line">Context::Scope context_scope(context); </span><br></pre></td></tr></table></figure>
<h2 id="V8的数据类型"><a href="#V8的数据类型" class="headerlink" title="V8的数据类型"></a>V8的数据类型</h2><p>由于 C++ 原生数据类型与 JavaScript 中数据类型有很大差异，因此 V8 提供了 Data 类，从 JavaScript 到 C++，从 C++ 到 JavaScrpt 都会用到这个类及其子类，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String::NewFromUtf8(info.GetIsolate(), &quot;version&quot;).ToLocalChecked() </span><br></pre></td></tr></table></figure>
<p>这里的String便是V8的数据类型。再比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v8::Integer::New(info.GetIsolate(), 10); </span><br></pre></td></tr></table></figure>
<h2 id="对象模板和函数模板"><a href="#对象模板和函数模板" class="headerlink" title="对象模板和函数模板"></a>对象模板和函数模板</h2><p>这两个模板类用以定义 JavaScript 对象和 JavaScript 函数。我们在后续的小节部分将会接触到模板类的实例。通过使用 ObjectTemplate，可以将 C++ 中的对象暴露给脚本环境，类似的，FunctionTemplate 用以将 C++ 函数暴露给脚本环境，以供脚本使用。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://www.cnblogs.com/wolfx/p/5920141.html">https://www.cnblogs.com/wolfx/p/5920141.html</a><br><a href="https://juejin.im/post/5d91a4d4f265da5b5f756c22">https://juejin.im/post/5d91a4d4f265da5b5f756c22</a><br><a href="https://gist.github.com/Jiab77/e59841227d1f9c7d2877862ced673ec6">https://gist.github.com/Jiab77/e59841227d1f9c7d2877862ced673ec6</a><br><a href="https://github.com/google/shaka-packager/issues/763">https://github.com/google/shaka-packager/issues/763</a><br><a href="https://groups.google.com/forum/#!topic/v8-users/LTppUbqNrzI">https://groups.google.com/forum/#!topic/v8-users/LTppUbqNrzI</a><br><a href="https://www.douban.com/note/754801799/">豆瓣LLVM</a><br><a href="https://github.com/abhiTronix/raspberry-pi-cross-compilers">rpi交叉编译工具</a><br><a href="https://my.oschina.net/wolfcs/blog/726696">gn参数</a><br><a href="http://blog.hszofficial.site/introduce/2018/02/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8E%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/">http://blog.hszofficial.site/introduce/2018/02/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8E%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>V8</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac更新bash至4.0以上</title>
    <url>/2019/09/20/Mac%E6%9B%B4%E6%96%B0bash%E8%87%B34-0%E4%BB%A5%E4%B8%8A/</url>
    <content><![CDATA[<p>Mac自带的bash为3.2版本，而最新的bash是5.0一上了。这导致bash无法支持新特性，而且执行脚本时也会提示bash要升级。</p>
<span id="more"></span>

<h3 id="升级方法"><a href="#升级方法" class="headerlink" title="升级方法"></a>升级方法</h3><p>查看bash版本<code> bash --version</code><br>执行<code>brew install bash</code></p>
<p>此时，bash虽然安装了，但是/bin/bash的版本依然没有改变。<br>这是因为mac系统禁止更改系统目录的权限，引入sip机制，需要先关闭，修改，再打开这一系列操作</p>
<h3 id="打开和关闭sip"><a href="#打开和关闭sip" class="headerlink" title="打开和关闭sip"></a>打开和关闭sip</h3><p>关闭sip</p>
<ol>
<li>重启系统，然后按住Command+R</li>
<li>出现界面之后，在最上方菜单栏选择Utilities menu中Terminal</li>
<li>在Terminal中输入csrutil disable关闭SIP</li>
<li>重启reboot </li>
</ol>
<h3 id="加入软链接"><a href="#加入软链接" class="headerlink" title="加入软链接"></a>加入软链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mv /bin/bash  /bin/bash.origin</span><br><span class="line">sudo ln -s /usr/local/bin/bash /bin/bash</span><br></pre></td></tr></table></figure>

<p>修改完成之后，查看版本是否更改。<br>更改后重新打开sip，打开时执行<code>csrutil enable </code></p>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode的各种坑</title>
    <url>/2019/09/12/Xcode%E7%9A%84%E5%90%84%E7%A7%8D%E5%9D%91/</url>
    <content><![CDATA[<p>作为一个iOS萌新，使用Xcode的过程真是一言难尽，遇到各种奇怪的耽误事儿的问题。这里就占个楼专门总结使用中碰到的问题，以后遇到了也有的参考。</p>
<span id="more"></span>

<h2 id="什么？还需要开发者账号？"><a href="#什么？还需要开发者账号？" class="headerlink" title="什么？还需要开发者账号？"></a>什么？还需要开发者账号？</h2><p>第一次使用Xcode的时候，我以为它和VS、Eclipse什么的一样就是一个简单的开发环境。后来才知道苹果对开发者管控的很严格，开发者需要注册开发者账号才能具备签名打包工程，发布到Apple Store的资格。</p>
<p>一般来说，开发者需要到<a href="https://developer.apple.com/">苹果开发者网站</a>注册开发者账号。<br>具体的流程为：</p>
<ol>
<li>注册apple id  (注意国籍中国 + 年龄&gt;18)</li>
<li>加入apple developer计划  </li>
<li>根据自己的身份进行填写注册</li>
<li>完成付款，个人是每年99刀</li>
</ol>
<p>在这之后就可以创建证书和包了</p>
<p>不过自15年之后，也就是Xcode7.x之后，开发者可以用中间的apple id申请一个免费的开发账号。不过这个账号只有测试功能，且权限有限，只支持三个测试设备，用的时候要很节省。</p>
<h2 id="Bundle-Identifier？那是什么东西？"><a href="#Bundle-Identifier？那是什么东西？" class="headerlink" title="Bundle Identifier？那是什么东西？"></a>Bundle Identifier？那是什么东西？</h2><p>在我刚开始尝试OC的时候，我就像自己学习C或Java一样，疯狂建了一堆类似“TEST”、“HelloWorld”、“MyFirstApp”这样的OC工程。<br>建工程之前会让你填写Team或者Bundle Identifier之类的信息，年轻的我以为这只是一些工程或者组织信息描述，就随手填了名字。<br>没想到，在我疯狂建了各种名字的工程之后，突然有天再新建时提示我Bundle Identifier满了…<br>原来一个账号的Bundle Identifier是有限的，尤其是上架之后不能与其他人的重复。满了之后再想用只能等之前的过期了。<br>另外，测试设备的数量也是有限的，占用了之后只能等每年Apple清理掉了。</p>
<h2 id="打开工程时一直loading转圈？"><a href="#打开工程时一直loading转圈？" class="headerlink" title="打开工程时一直loading转圈？"></a>打开工程时一直loading转圈？</h2><p>有一天，我打开一个大工程时，Xcode一直右下角在loading。而且只能通过杀死进程的方法才能关掉。<br>解决办法:<a href="https://www.jianshu.com/p/e67e71072f7c">Xcode打开工程假死</a><br>不过我当时好像是把整个工程都删了，文件夹清理一遍才好。</p>
<h2 id="添加账号时一直loading转圈？"><a href="#添加账号时一直loading转圈？" class="headerlink" title="添加账号时一直loading转圈？"></a>添加账号时一直loading转圈？</h2><p>这个问题是最让我烦躁的，填了账户密码之后就一直转圈，一点反应没有。<br>有人说是因为验证的服务器有问题，不过我试了之后发现输了错误的密码之后是有错误提示的。说明验证是能验证的，应该是接下来的步骤卡死。<br>这个问题在某一天突然解决，又在某一天突然出现，毫无防备。</p>
<p>如果在虚拟机上出现该问题，参考文章<a href="https://8biiit.github.io/2019/09/20/%E8%A7%A3%E5%86%B3Mac%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88VirtualBox%EF%BC%89%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86Xcode%E7%9A%84%E5%BC%80%E5%8F%91%E8%B4%A6%E5%8F%B7%E9%97%AE%E9%A2%98/">解决Mac虚拟机（VirtualBox）无法登陆Xcode的开发账号问题</a></p>
<h2 id="使用低版本SDK"><a href="#使用低版本SDK" class="headerlink" title="使用低版本SDK"></a>使用低版本SDK</h2><p>有时在开发中，我们升级Xcode为较高的版本，或者由于mac系统版本限制只能使用某个较高版本的Xcode，而可其支持的最低版本iOS SDK却比我们需要的版本高。<br>这时就需要将较低版本的SDK移过来。<br>首先，从旧版本Xcode中将SDK拷贝出来，路径为:<br><code>Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs</code><br>然后将其拷贝到新版本的对应位置<br>再打开<code>/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Info.plist</code>文件<br>改变MinimumSDKVersion的值，重启Xcode会识别大于等于MinimumSDKVersion的所有SDK</p>
<h2 id="Xcode版本和Mac-OS版本的限制"><a href="#Xcode版本和Mac-OS版本的限制" class="headerlink" title="Xcode版本和Mac OS版本的限制"></a>Xcode版本和Mac OS版本的限制</h2><p>Xcode要求的最低Mac版本，以及对应的SDK、模拟器、swift版本<br>参考：<a href="https://developer.apple.com/cn/support/xcode/">Xcode Support</a></p>
<h2 id="低版本Xcode不支持高版本iOS真机调试（14-0）"><a href="#低版本Xcode不支持高版本iOS真机调试（14-0）" class="headerlink" title="低版本Xcode不支持高版本iOS真机调试（14.0）"></a>低版本Xcode不支持高版本iOS真机调试（14.0）</h2><p>下载新版本的调试包，解压到以下路径：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport</code></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>debugserver + lldb 动态调试</title>
    <url>/2019/08/16/debugserver-lldb-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="配置debugserver"><a href="#配置debugserver" class="headerlink" title="配置debugserver"></a>配置debugserver</h2><p>debugserver运行在的iOS上，顾名思义，它作为服务端，实际执行LLDB（作为客户端）传过来的命令，再把执行结果反馈给LLDB，显示给用户，即所谓的“远程调试”。在默认情况下，iOS设备上并没有安装debugserver，只有在设备连接过一次的Xcode，并在窗口→设备菜单中添加此设备后，debugserver才会被Xcode中安装到iOS版的“/开发人员的/ usr / bin中/”目录下。</p>
<span id="more"></span>

<h3 id="将debugserver从手机传到mac"><a href="#将debugserver从手机传到mac" class="headerlink" title="将debugserver从手机传到mac"></a>将debugserver从手机传到mac</h3><p>使用iproxy工具，将当前连接设备的22端口（SSH）映射到电脑的2222端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iproxy 2222 22</span><br></pre></td></tr></table></figure>
<p>SSH到usb设备上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -p2222 root@127.0.0.1</span><br></pre></td></tr></table></figure>
<p>传输文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -P2222 root@127.0.0.1:/Developer/usr/bin/debugserver ~/Desktop</span><br></pre></td></tr></table></figure>
<h3 id="给debugserver瘦身"><a href="#给debugserver瘦身" class="headerlink" title="给debugserver瘦身"></a>给debugserver瘦身</h3><p>对照表格找到设备的ARM信息<br><img src="/.io//arm.jpg" alt="iPhone对应arm架构"><br>例如iphone为5c,执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lipo -thin armv7s ~/debugserver -output ~/debugserver</span><br></pre></td></tr></table></figure>

<h3 id="给debugserver添加权限"><a href="#给debugserver添加权限" class="headerlink" title="给debugserver添加权限"></a>给debugserver添加权限</h3><p>安装ldid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install ldid</span><br></pre></td></tr></table></figure>
<p>下载ent.xml到MACOS目录，然后运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldid -Sent.xml debugserver</span><br></pre></td></tr></table></figure>
<p>注意“-S”选项与“Sent.xml”之间是没有空格的，Sent.xml是设置二进制授权的文件，没有的话可以去网上找找，也可在工程中找entitlements文件获得。</p>
<h3 id="将经过处理的debugserver拷回手机"><a href="#将经过处理的debugserver拷回手机" class="headerlink" title="将经过处理的debugserver拷回手机"></a>将经过处理的debugserver拷回手机</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -P2222 ~/debugserver root@127.0.0.1:/usr/bin/debugserver</span><br></pre></td></tr></table></figure>
<h2 id="连接进程"><a href="#连接进程" class="headerlink" title="连接进程"></a>连接进程</h2><h3 id="通过端口号调试"><a href="#通过端口号调试" class="headerlink" title="通过端口号调试"></a>通过端口号调试</h3><p>ssh到ios上，执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure>
<p>查看pid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debugserver *:1234 -a  prossesname/pid  </span><br></pre></td></tr></table></figure>
<h3 id="文件方式启动，不需端口号"><a href="#文件方式启动，不需端口号" class="headerlink" title="文件方式启动，不需端口号"></a>文件方式启动，不需端口号</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">debugserver -x frontboard   *:1234   /var/containers/Bundle/Application/1452A4F7-C5B1-4654-9CDC-4D94C3C94F47/MTPotal.app</span><br></pre></td></tr></table></figure>
<h3 id="把本地端口映射到苹果端口"><a href="#把本地端口映射到苹果端口" class="headerlink" title="把本地端口映射到苹果端口"></a>把本地端口映射到苹果端口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iproxy 1234 1234</span><br></pre></td></tr></table></figure>
<h2 id="在Mac系统上用LLDB远程调试"><a href="#在Mac系统上用LLDB远程调试" class="headerlink" title="在Mac系统上用LLDB远程调试"></a>在Mac系统上用LLDB远程调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">process connect connect://localhost:1234</span><br></pre></td></tr></table></figure>
<p>这条命令执行耗时比较长，需要耐心等一会</p>
<h3 id="常用lldb命令"><a href="#常用lldb命令" class="headerlink" title="常用lldb命令"></a>常用lldb命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看地址</span><br><span class="line">image list -o -f</span><br><span class="line">#查看类内地址</span><br><span class="line">po [className _shortMethodDescription]</span><br><span class="line">#设置断点</span><br><span class="line">br s -a 0x452C96</span><br><span class="line">#删除所有断点</span><br><span class="line">br del </span><br><span class="line">#禁用第3个断点（启用en）</span><br><span class="line">br dis 3</span><br><span class="line"></span><br><span class="line">-c 用来设置断点条件</span><br><span class="line">-o 来设置单次断点</span><br></pre></td></tr></table></figure>
<p>更多命令查看<a href="https://lldb.llvm.org/use/map.html">手册</a></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://iosre.com/t/debugserver-lldb-gdb/65">http://iosre.com/t/debugserver-lldb-gdb/65</a><br><a href="http://zhz.io/2018/07/05/%E9%82%A3%E4%B8%AALLDB%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/">http://zhz.io/2018/07/05/%E9%82%A3%E4%B8%AALLDB%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E5%90%97/</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>debugserver</tag>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS with Extension砸壳全过程</title>
    <url>/2019/10/10/iOS-with-Extension%E7%A0%B8%E5%A3%B3%E5%85%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>一部越狱的手机</li>
<li><a href="https://github.com/stefanesser/dumpdecrypted">dumpdecrypted</a>或<a href="https://github.com/AloneMonkey/frida-ios-dump">frida-ios-dump</a>(砸壳使用)</li>
<li>class-dump（导出砸壳后的二进制包的头文件）</li>
<li>Cycript(Cydia)（在越狱手机的越狱市场下载，安装）</li>
<li>OpenSSH(Cydia) （在越狱手机的越狱市场下载，安装）</li>
<li>Frida(Cydia) （在越狱手机的越狱市场下载，安装）</li>
</ol>
<span id="more"></span>

<h2 id="重要步骤"><a href="#重要步骤" class="headerlink" title="重要步骤"></a>重要步骤</h2><h3 id="在APPStore中下载正版的应用到手机上"><a href="#在APPStore中下载正版的应用到手机上" class="headerlink" title="在APPStore中下载正版的应用到手机上"></a>在APPStore中下载正版的应用到手机上</h3><p>以下以搜狗输入法为例（手机ios10.3.3   型号iphone 5c）</p>
<h3 id="ssh至手机，并查看路径"><a href="#ssh至手机，并查看路径" class="headerlink" title="ssh至手机，并查看路径"></a>ssh至手机，并查看路径</h3><p>转发手机22端口到主机2222端口 <code>iproxy 2222 22</code></p>
<p>ssh至手机 <code>ssh -p2222 root@127.0.0.1</code></p>
<p>查找 进程信息（此时app和extension都要打开）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -e | grep Sogou </span><br><span class="line"></span><br><span class="line">cycript -p SogouInput</span><br></pre></td></tr></table></figure>

<h3 id="dumpdecrypted砸壳"><a href="#dumpdecrypted砸壳" class="headerlink" title="dumpdecrypted砸壳"></a>dumpdecrypted砸壳</h3><p>下载并编译dumpdecrypted  <code>cd dumpdecrypted &amp;&amp; make</code></p>
<p>为dumpdecrypted.dylib签名<br><code>codesign -fs &quot;iPhone Developer: my.guo@foxmail.com (WJ79M49LT4)&quot; dumpdecrypted.dylib</code></p>
<p>将dumpdecrypted.dylib拷贝到/usr/bin<br><code>sudo scp dumpdecrypted.dylib root@10.2.200.186:/usr/bin</code></p>
<p>执行以下命令为可执行文件砸壳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib     /var/containers/Bundle/Application/EFE80EA8-BF4D-49C9-A342-B22357CA1A93/SogouInput.app/SogouInput</span><br></pre></td></tr></table></figure>
<p>为extension砸壳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DYLD_INSERT_LIBRARIES=dumpdecrypted.dylib     /var/containers/Bundle/Application/EFE80EA8-BF4D-49C9-A342-B22357CA1A93/SogouInput.app/PlugIns/com.sogou.sogouinput.BaseKeyboard.appex/com.sogou.sogouinput.BaseKeyboard</span><br></pre></td></tr></table></figure>

<p>结果会在执行目录下生成可执行文件.decrypted文件</p>
<p>将文件拷贝回电脑  <code>sudo scp root@127.0.0.1:/SogouInput.decrypted  ~/Desktop</code></p>
<h3 id="frida-ios-dump-砸壳"><a href="#frida-ios-dump-砸壳" class="headerlink" title="frida-ios-dump 砸壳"></a>frida-ios-dump 砸壳</h3><p>按照说明配置环境</p>
<p>修改dump.py 中的user等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User = &#x27;root&#x27;</span><br><span class="line">Password = &#x27;*****&#x27;</span><br><span class="line">Host = &#x27;localhost&#x27;</span><br><span class="line">Port = 2222</span><br></pre></td></tr></table></figure>
<p>开始砸壳</p>
<p><code>sudo ./dump.py com.sogou.sogouinput</code></p>
<h2 id="查看可执行文件是否成功砸壳"><a href="#查看可执行文件是否成功砸壳" class="headerlink" title="查看可执行文件是否成功砸壳"></a>查看可执行文件是否成功砸壳</h2><p><code>otool -l 可执行文件路径 | grep cryptid</code><br>结果为1加密了，0没有加密</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>dump</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS应用ipa重签名</title>
    <url>/2019/08/21/iOS%E5%BA%94%E7%94%A8ipa%E9%87%8D%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<p>作为一项安全措施，Apple要求其信任的开发人员对在其设备上运行的所有代码进行数字签名。有时我们需要对第三方包进行修改后重新安装，因此需要进行重签名通过验证。</p>
<span id="more"></span>

<h3 id="使用Xcode重签名"><a href="#使用Xcode重签名" class="headerlink" title="使用Xcode重签名"></a>使用Xcode重签名</h3><ol>
<li><p>新建一个工程编译</p>
</li>
<li><p>获得这个新工程的签名<br> 查看位置：product-&gt;app-&gt;在path中打开</p>
</li>
<li><p>   用要签名的app替换掉工程app，把要签名的app的名字改为工程名字</p>
</li>
<li><p>   把要签名app的info.plist里的buddleid 改为工程的bundleid</p>
</li>
<li><p>使用要签名的证书对app进行签名 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">codesign -fs &quot;iPhone Developer: amor.diavolo@icloud.com (K239F7Y6DD)&quot; MTPotal.app</span><br></pre></td></tr></table></figure>
<p> 查看本机证书： <code>security find-identity -v -p codesigning</code></p>
</li>
<li><p>在xcode中run，将会把签名后的app安装在真机上，此时可看到ui界面，也可lldb进行调试。</p>
</li>
</ol>
<h3 id="使用Monkeydev自动签名"><a href="#使用Monkeydev自动签名" class="headerlink" title="使用Monkeydev自动签名"></a>使用Monkeydev自动签名</h3><ol>
<li>创建一个<a href="https://github.com/AloneMonkey/MonkeyDev">MonkeyDev</a>项目</li>
<li>把砸了壳的IPA包放到Target目录下</li>
<li>直接运行就可以跑到手机上了</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS虚拟定位</title>
    <url>/2020/12/07/iOS%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<p>虚拟定位指利用软硬件更改手机系统的定位数据，从而使目标app获取错误的定位信息。一般用于黑产、游戏外挂、社交软件打卡等。<br>这里提供一种简单的修改iOS设备定位的方法。</p>
<span id="more"></span>

<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul>
<li>iphone (iOS 14.1)</li>
<li>lightning线</li>
<li>MAC电脑</li>
</ul>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>下载和iOS版本对应的Developer Disk Image <a href="https://github.com/xushuduo/Xcode-iOS-Developer-Disk-Image/releases">14.3-4.2</a> 、<a href="https://github.com/mspvirajpatel/Xcode_Developer_Disk_Images/releases">14.3-11.3</a></li>
<li>安装<a href="https://github.com/libimobiledevice/libimobiledevice">libimobiledevice</a></li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li>使用lightning线连接手机和电脑</li>
<li>运行<code>ideviceimagemounter</code>命令挂载Developer Disk Image</li>
<li>运行<code>idevicesetlocation</code>命令设置GPS坐标 </li>
<li>使用完成后运行<code>idevicesetlocation reset</code>解除设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#example</span><br><span class="line">idevicesetlocation -- 32.036354 118.785575</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Virtual Location</tag>
      </tags>
  </entry>
  <entry>
    <title>使用yolo3-tf2训练自己的数据集</title>
    <url>/2021/02/07/%E4%BD%BF%E7%94%A8yolo3-tf2%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<p>You only look once (YOLO) 是一个实时目标检测模型。YOLO3在保持速度优势的前提下，提升了预测精度，尤其是加强了对小物体的识别能力。<br>本文将介绍如何使用yolo3 + tensorflow2.x训练自己的数据集。</p>
<span id="more"></span>

<h1 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h1><h2 id="下载yolo工程"><a href="#下载yolo工程" class="headerlink" title="下载yolo工程"></a>下载yolo工程</h2><p>yolov3-tf2地址：<a href="https://github.com/zzh8829/yolov3-tf2">https://github.com/zzh8829/yolov3-tf2</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone  https://github.com/zzh8829/yolov3-tf2 yolov3-tf2</span><br><span class="line">cd yolov3-tf2</span><br></pre></td></tr></table></figure>

<h2 id="建立conda环境"><a href="#建立conda环境" class="headerlink" title="建立conda环境"></a>建立conda环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Tensorflow CPU</span><br><span class="line">conda env create -f conda-cpu.yml</span><br><span class="line">conda activate yolov3-tf2-cpu</span><br><span class="line">​</span><br><span class="line"># Tensorflow GPU</span><br><span class="line">conda env create -f conda-gpu.yml</span><br><span class="line">conda activate yolov3-tf2-gpu</span><br></pre></td></tr></table></figure>

<h2 id="下载权重文件并验证"><a href="#下载权重文件并验证" class="headerlink" title="下载权重文件并验证"></a>下载权重文件并验证</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://pjreddie.com/media/files/yolov3.weights -O data/yolov3.weights</span><br><span class="line">python convert.py</span><br><span class="line">python detect.py --image ./data/meme.jpg # Sanity check</span><br></pre></td></tr></table></figure>

<h2 id="制作VOC数据集"><a href="#制作VOC数据集" class="headerlink" title="制作VOC数据集"></a>制作VOC数据集</h2><p>目录：</p>
<ul>
<li>VOC<ul>
<li>Annotations #存放xml文件，可使用LabelImg生成        </li>
<li>JPEGImages #存放图片</li>
<li>ImageSets  <ul>
<li>Main<ul>
<li>test.txt    </li>
<li>train.txt    </li>
<li>trainval.txt    </li>
<li>val.txt</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>执行python make.py 在Main 下生成四个txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -*- coding：utf-8 -*-</span><br><span class="line">​</span><br><span class="line">import os  </span><br><span class="line">import random  </span><br><span class="line">​</span><br><span class="line">trainval_percent = 0.6    # 自己设定（训练集+验证集）所占（训练集+验证集+测试集）的比重  </span><br><span class="line">train_percent = 0.7       # 自己设定（训练集）所占（训练集+验证集）的比重</span><br><span class="line">xmlfilepath = &#x27;Annotations&#x27;     #注意自己地址是否正确</span><br><span class="line">txtsavepath = &#x27;ImageSets/Main&#x27;   #注意自己地址是否正确</span><br><span class="line">total_xml = os.listdir(xmlfilepath)  </span><br><span class="line">​</span><br><span class="line">num = len(total_xml)  </span><br><span class="line">print(num)</span><br><span class="line">list = range(num)  </span><br><span class="line">tv = int(num*trainval_percent)  </span><br><span class="line">tr = int(tv*train_percent)  </span><br><span class="line">trainval = random.sample(list,tv)  </span><br><span class="line">train = random.sample(trainval,tr)  </span><br><span class="line">​</span><br><span class="line">ftrainval = open(&#x27;ImageSets/Main/trainval.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">ftest = open(&#x27;ImageSets/Main/test.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">ftrain = open(&#x27;ImageSets/Main/train.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">fval = open(&#x27;ImageSets/Main/val.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line">​</span><br><span class="line">for i in list:  </span><br><span class="line">    name = total_xml[i][:-4]+&#x27;\n&#x27;  </span><br><span class="line">    #print(name)</span><br><span class="line">    if i in trainval:  </span><br><span class="line">        ftrainval.write(name)  </span><br><span class="line">        if i in train:  </span><br><span class="line">            ftrain.write(name)  </span><br><span class="line">        else:  </span><br><span class="line">            fval.write(name)  </span><br><span class="line">    else:  </span><br><span class="line">        ftest.write(name)  </span><br><span class="line">​</span><br><span class="line">ftrainval.close()  </span><br><span class="line">ftrain.close()  </span><br><span class="line">fval.close()  </span><br><span class="line">ftest.close()</span><br><span class="line">print(&#x27;Done&#x27;)</span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<h2 id="建立标签-names文件"><a href="#建立标签-names文件" class="headerlink" title="建立标签.names文件"></a>建立标签.names文件</h2><p>在data文件夹下，写入的就是自己要训练的类别</p>
<h2 id="生成tfrecord文件"><a href="#生成tfrecord文件" class="headerlink" title="生成tfrecord文件"></a>生成tfrecord文件</h2><p>训练集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python tools/voc2012.py \</span><br><span class="line">  --data_dir &#x27;./data/voc-5h&#x27; \</span><br><span class="line">  --split train \</span><br><span class="line">  --output_file ./data/voc5h_train.tfrecord \</span><br><span class="line">  --classes ./data/voc-5h.names</span><br></pre></td></tr></table></figure>
<p>测试集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python tools/voc2012.py \</span><br><span class="line">  --data_dir &#x27;./data/voc-5h&#x27; \</span><br><span class="line">  --split val \</span><br><span class="line">  --output_file ./data/voc5h_val.tfrecord \</span><br><span class="line">  --classes ./data/voc-5h.names</span><br></pre></td></tr></table></figure>

<h1 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h1><h2 id="进行迁移训练"><a href="#进行迁移训练" class="headerlink" title="进行迁移训练"></a>进行迁移训练</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python train.py \</span><br><span class="line">  --dataset ./data/voc5h_train.tfrecord \</span><br><span class="line">  --val_dataset ./data/voc5h_val.tfrecord \</span><br><span class="line">  --classes ./data/voc-5h.names \</span><br><span class="line">  --num_classes 181 \</span><br><span class="line">  --mode fit --transfer darknet \</span><br><span class="line">  --batch_size 16 \</span><br><span class="line">  --epochs 10 \</span><br><span class="line">  --weights ./checkpoints/yolov3.tf \</span><br><span class="line">  --weights_num_classes 80</span><br></pre></td></tr></table></figure>

<h2 id="使用随机权重进行训练"><a href="#使用随机权重进行训练" class="headerlink" title="使用随机权重进行训练"></a>使用随机权重进行训练</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python train.py \</span><br><span class="line">  --dataset ./data/voc5h_train.tfrecord \</span><br><span class="line">  --val_dataset ./data/voc5h_val.tfrecord \</span><br><span class="line">  --classes ./data/voc-5h.names \</span><br><span class="line">  --num_classes 181 \</span><br><span class="line">  --mode fit --transfer none \</span><br><span class="line">  --batch_size 16 \</span><br><span class="line">  --epochs 50 \</span><br></pre></td></tr></table></figure>

<h1 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h1><h2 id="从图像中检测"><a href="#从图像中检测" class="headerlink" title="从图像中检测"></a>从图像中检测</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python detect.py \</span><br><span class="line">  --classes ./data/voc-5h.names \</span><br><span class="line">  --num_classes 181 \</span><br><span class="line">  --weights ./checkpoints/yolov3_train_5.tf \</span><br><span class="line">  --image ./data/street.jpg</span><br></pre></td></tr></table></figure>

<h2 id="从验证集中检测"><a href="#从验证集中检测" class="headerlink" title="从验证集中检测"></a>从验证集中检测</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python detect.py \</span><br><span class="line">  --classes ./data/voc-5h.names \</span><br><span class="line">  --num_classes 181 \</span><br><span class="line">  --weights ./checkpoints/yolov3_train_5.tf \</span><br><span class="line">  --tfrecord ./data/voc5h_val.tfrecord</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>CV</tag>
        <tag>yolo3</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>theos安装、环境配置</title>
    <url>/2019/08/16/theos%E5%AE%89%E8%A3%85%E3%80%81%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a href="https://github.com/theos/theos">Theos</a> 是一个越狱开发工具包，安装方法可以参考 <a href="https://github.com/theos/theos/wiki">Wiki</a>。</p>
<span id="more"></span>

<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><h3 id="安装-dpkg"><a href="#安装-dpkg" class="headerlink" title="安装 dpkg"></a>安装 dpkg</h3><p>dpkg(Debian Packager) 是 Theos 依赖工具之一，可以使用 dpkg 制作 deb，Theos 开发的插件都会以 deb 的格式进行发布，在安装 Theos 之前需要安装 dpkg.</p>
<p>安装借助于<a href="https://brew.sh/">Homebrew</a>安装，确保先安装 Homebrew。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install dpkg</span><br></pre></td></tr></table></figure>

<h3 id="安装-ldid"><a href="#安装-ldid" class="headerlink" title="安装 ldid"></a>安装 ldid</h3><p><a href="http://iphonedevwiki.net/index.php/Ldid">ldid</a>是越狱祖师爷Saurik开发的一款二进制授权管理软件，可以对越狱应用进行SHA1运算生成授权，让软件包可以在iPhone上执行。Theos 开发中，iOS 文件的签名使用 ldid 工具完成，代替了 XCode 中的 Codesign。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install ldid</span><br></pre></td></tr></table></figure>

<h2 id="安装Thoes"><a href="#安装Thoes" class="headerlink" title="安装Thoes"></a>安装Thoes</h2><p>将 Theos 安装在 /opt/theos 目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo Git clone --recursive https://github.com/theos/theos.git /opt/theos</span><br><span class="line">//recursive表示递归</span><br></pre></td></tr></table></figure>
<h2 id="将-opt-theos-权限改为自己"><a href="#将-opt-theos-权限改为自己" class="headerlink" title="将 /opt/theos 权限改为自己"></a>将 /opt/theos 权限改为自己</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo chown $(id -u):$(id -g) /opt/theos</span><br></pre></td></tr></table></figure>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p> 在~./bash_profile中加上:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export THEOS=/opt/theos</span><br><span class="line">export PATH=/opt/theos/bin/:$PATH</span><br></pre></td></tr></table></figure>
<p>执行一遍source命令使得环境变量生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>
<h2 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nic.pl</span><br></pre></td></tr></table></figure>
<p>New Instance Creator开始执行则已经安装成功</p>
<h2 id="Theos升级到最新版"><a href="#Theos升级到最新版" class="headerlink" title="Theos升级到最新版"></a>Theos升级到最新版</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule update –recursive</span><br></pre></td></tr></table></figure>
<h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="http://iosre.com/t/theos/4928">http://iosre.com/t/theos/4928</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>theos</tag>
      </tags>
  </entry>
  <entry>
    <title>图片处理</title>
    <url>/2021/01/29/%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>图片的预处理在机器学习中是一个重要且有效的步骤，可以使图片转换成适应模型的格式，也可进行数据增强和数据归一化等。<br>本文将对常用的图片处理方法进行归纳。</p>
<span id="more"></span>

<h1 id="OpenCV-Python方法"><a href="#OpenCV-Python方法" class="headerlink" title="OpenCV-Python方法"></a>OpenCV-Python方法</h1><p>教程：<a href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html">https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_tutorials.html</a></p>
<p>opencv以BGR模式加载图片。</p>
<p>使用需 <code>import cv2</code></p>
<h2 id="读写展示图片"><a href="#读写展示图片" class="headerlink" title="读写展示图片"></a>读写展示图片</h2><h3 id="读本地图片"><a href="#读本地图片" class="headerlink" title="读本地图片"></a>读本地图片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.imread(filepath,flags)</span><br><span class="line">​</span><br><span class="line">#参数一：工作路径or完整路径  参数二：读取这幅图片方式，可省略</span><br><span class="line">#参数二：</span><br><span class="line">#cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略alpha通道，实际取值为1</span><br><span class="line">#cv2.IMREAD_GRAYSCALE：读入灰度图片，实际取值为0</span><br><span class="line">#cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括alpha通道</span><br><span class="line">​</span><br><span class="line">exp:</span><br><span class="line">#读取工作路径下彩色图片</span><br><span class="line">cv2.imread(&quot;1.jpg&quot;)</span><br><span class="line">​</span><br><span class="line">#读取完整路径下灰度图片</span><br><span class="line">cv2.imread(&quot;/Users/mabelguo/1.jpg&quot;,0)</span><br></pre></td></tr></table></figure>
<h3 id="写图片到本地"><a href="#写图片到本地" class="headerlink" title="写图片到本地"></a>写图片到本地</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.imwrite(filepath,img)</span><br><span class="line">​</span><br><span class="line">#若保存为png，则保留alpha通道；保存为jpg，丢失alpha通道</span><br><span class="line">​</span><br><span class="line">exp:</span><br><span class="line">cv2.imwrite(&quot;1.png&quot;,img)</span><br><span class="line">````</span><br><span class="line">### 窗体展示图片</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#展示窗体，窗口自适应图片的大小<br>cv2.imshow(windowName,img)<br>#参数一：窗体标题 参数二：图像<br>​<br>​<br>#等待键盘输入，否则窗体一闪而过<br>cv2.waitKey(0)<br>#销毁所有窗口<br>cv2.destroyAllWindows()<br>​<br>#可调整大小窗口<br>cv2.namedWindow(windowName,flag)<br>#如果我们想放大缩小窗口，必须单独用cv2.namedWindow(),并通过flag参数指定窗口模式为cv2.WINDOW_NORMAL,默认为cv2.WINDOW_AUTOSIZE.<br>​<br>flag:<br>窗口大小可以改变：   cv2.WINDOW_NORMAL , cv2.WINDOW_GUI_NORMAL<br>窗口大小不可以改变： cv2.WINDOW_AUTOSIZE<br>窗口大小自适应比例： cv2.WINDOW_FREERATIO<br>窗口大小保持比例：   cv2.WINDOW_KEEPRATIO<br>显示色彩变成暗色：   cv2.WINDOW_GUI_EXPANDED<br>​<br>exp:<br>cv2.namedWindow(“lena”,0)<br>cv2.imshow(“lena”,img)<br>cv2.waitKey(0)<br>cv2.destroyAllWindows()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 图像标注</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#画直线<br>cv2.line()<br>cv2.line(img, pt1, pt2, color[, thickness[, lineType[, shift]]])<br>​<br>img，背景图<br>pt1，直线起点坐标<br>pt2，直线终点坐标<br>color，当前绘画的颜色。如在BGR模式下，传递(255,0,0)表示蓝色画笔。灰度图下，只需要传递亮度值即可。<br>thickness，画笔的粗细，线宽。若是-1表示画封闭图像，如填充的圆。默认值是1.<br>​<br>​<br>#画圈<br>cv2.circle()<br>cv2.circle(img, center, radius, color[, thickness[, lineType[, shift]]])<br>​<br>img，背景图<br>center，圆心<br>radius，半径<br>color，颜色<br>thickness，线粗细<br>​</p>
<p>#画矩形<br>cv2.rectangle()<br>cv2.rectangle(img, pt1, pt2, color[, thickness[, lineType[, shift]]])<br>​</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 图片常见预处理</span><br><span class="line">### 利用numpy创建一张新的图片</span><br><span class="line">OpenCV的基础数据类型为numpy.ndarray，numpy.ndarray中的每个元素的dtype应该为numpy.uint8。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>import cv2<br>import numpy as np<br>​<br>#创建三通道黑色图片<br>img = np.zeros([w, h, 3], np.uint8)<br>​<br>#创建三通道白色图片<br>img = np.zeros([w, h, 3], np.uint8) + 255<br>​<br>#创建四通道黑色透明图片（需保存为png才能看到透明度）<br>img = np.zeros([w, h, 4], np.uint8)<br>​<br>#由于opencv 颜色通道顺序为BGR<br>蓝色通道为：img[:, :, 0]<br>绿色通道为：img[:, :, 1]<br>红色通道为：img[:, :, 2]<br>透明度通道为：img[:, :, 3] </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 颜色空间转换</span><br></pre></td></tr></table></figure>
<p>image = cv2.imread(“1.png”)<br>​<br>#从BGR转到HSV颜色空间<br>image_hsv = cv2.cvtColor(image,cv2.COLOR_BGR2HSV)<br>​<br>#从彩色图转灰度图<br>image_ = cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)<br>​<br>#从BGR转到RGB颜色空间<br>image_hsv = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 图像去噪</span><br></pre></td></tr></table></figure>
<p>#高斯滤波<br>cv2.GaussianBlur()<br>​<br>cv2.GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]])<br>@param: src: nparray<br>          input image.<br>@param: ksize: (int,int)<br>          Gaussian kernel size. ksize.width and ksize.height can differ<br>          but they both must be positive and odd.<br>          Or, they can be zero’s and then they are computed from sigma* .<br>@param: sigmaX: float<br>          Gaussian kernel standard deviation in X direction.<br>@param: sigmaY: float<br>          Gaussian kernel standard deviation in Y direction;<br>          if sigmaY is zero, it is set to be equal to sigmaX,<br>          if both sigmas are zeros, they are computed from ksize.width and ksize.height.<br>          To fully control the result,<br>          it is recommended to specify all of ksize, sigmaX, and sigmaY.</p>
<p>#exp<br>#可以自己构建高斯核<br>cv2.getGaussianKernel()<br>#也可以直接做模糊<br>blur = cv2.GaussianBlur(img, (6, 6), 1, 0)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 二值化</span><br><span class="line">cv2.threshold()</span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line"></span><br><span class="line">cv2.threshold (src, thresh, maxval, type)</span><br><span class="line"></span><br><span class="line">src：源图片，必须是单通道</span><br><span class="line"></span><br><span class="line">thresh：阈值，取值范围0～255</span><br><span class="line"></span><br><span class="line">maxval：填充色，取值范围0～255</span><br><span class="line"></span><br><span class="line">type：阈值类型，见下表</span><br><span class="line"></span><br><span class="line">| 阈值 | 小于阈值的像素点| 大于阈值的像素点| </span><br><span class="line">| :--------:   | :----- | :----  |</span><br><span class="line">| 0| 置0| 置填充色| </span><br><span class="line">| 1| 置填充色| 置0| </span><br><span class="line">| 2| 保持原色| 置灰色| </span><br><span class="line">| 3| 置0| 保持原色| </span><br><span class="line">| 4| 保持原色| 置0| </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ret, binary = cv2.threshold(gray, 80, 255, cv2.THRESH_BINARY_INV) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 形态学处理</span><br><span class="line">### 腐蚀</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>import cv2<br>import numpy as np<br>​<br>img = cv2.imread(‘j.png’,0)<br>kernel = np.ones((5,5), np.uint8)<br>erosion = cv2.erode(img,kernel,iterations=1)<br>​</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 膨胀</span><br><span class="line"></span><br><span class="line">把分隔对象连起来很有用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dilation = cv2.dilate(img,kernel,iterations=1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 开运算：先腐蚀后膨胀</span><br><span class="line"></span><br><span class="line">cv2.morphologyEx()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>opening = cv2.morphologyEx(img,cv2.MORPH_OPEN,kernel)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 闭运算：先膨胀后腐蚀</span><br><span class="line"></span><br><span class="line">用来关闭前景对象里的小洞或小黑点很有用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>closing = cv2.morphologyEx(img,cv2.MORPH_CLOSE,kernel)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 形态梯度：物体的轮廓</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>gradient = cv2.morphologyEx(img,cv2.MORPH_GRADIENT,kernel)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 进阶方法</span><br><span class="line">### 查找、绘制轮廓函数</span><br><span class="line">cv2.findContours()</span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line"></span><br><span class="line">cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]])</span><br><span class="line"></span><br><span class="line">| image| 源图像，一个8位单通道图像| </span><br><span class="line">|------------- | -------------|</span><br><span class="line">| contours| 检测到的轮廓| </span><br><span class="line">| hierarchy| 轮廓级别信息。Hierarchy为可选输出变量| </span><br><span class="line">| mode| 轮廓检索模式| </span><br><span class="line">| method| 轮廓近似法| </span><br><span class="line">| offset| 每个轮廓点移动的偏移量，可选参数，cv::Point()类型| </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>binary, contours, hierarchy = cv2.findContours(binary, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv2.drawContours()</span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line"></span><br><span class="line">image = cv.drawContours(image, contours, contourIdx, color[, thickness[, lineType[, hierarchy[, maxLevel[, offset]]]]])</span><br><span class="line"></span><br><span class="line">函数参数：</span><br><span class="line"></span><br><span class="line">|image|输入：源图像。单通道或3通道图像。|</span><br><span class="line">|------------- | -------------|</span><br><span class="line">|contours|输入：待绘制的轮廓|</span><br><span class="line">|contourIdx|输入：待绘制的轮廓序号，-1为绘制所有轮廓。|</span><br><span class="line">|color|输入：轮廓颜色|</span><br><span class="line">|thickness|输入：轮廓粗细。int型变量，默认为1，值越大越粗|</span><br><span class="line">|lineType|输入：绘制轮廓的线型。|</span><br><span class="line">|hierarchy|输入：待绘制的轮廓级别。|</span><br><span class="line">|maxLevel|输入：待绘制的轮廓最大级别。|</span><br><span class="line">|method|输入：轮廓近似法|</span><br><span class="line">|offset|输入：每个轮廓点移动的偏移量，可选参数。|</span><br><span class="line"></span><br><span class="line">### 模板检测</span><br><span class="line">cv2.matchTemplate()</span><br><span class="line"></span><br><span class="line">函数原型：</span><br><span class="line"></span><br><span class="line">cv2.matchTemplate(image, templ, method, result=None, mask=None)</span><br><span class="line"></span><br><span class="line">image：待搜索图像</span><br><span class="line"></span><br><span class="line">templ：模板图像</span><br><span class="line"></span><br><span class="line">result：匹配结果</span><br><span class="line"></span><br><span class="line">method：计算匹配程度的方法</span><br><span class="line"></span><br><span class="line">关于匹配方法，使用不同的方法产生的结果的意义可能不太一样，有些返回的值越大表示匹配程度越好，而有些方法返回的值越小表示匹配程度越好。</span><br><span class="line"></span><br><span class="line">关于参数 method：</span><br><span class="line"></span><br><span class="line">CV_TM_SQDIFF 平方差匹配法：该方法采用平方差来进行匹配；最好的匹配值为0；匹配越差，匹配值越大。</span><br><span class="line"></span><br><span class="line">CV_TM_CCORR 相关匹配法：该方法采用乘法操作；数值越大表明匹配程度越好。</span><br><span class="line"></span><br><span class="line">CV_TM_CCOEFF 相关系数匹配法：1表示完美的匹配；-1表示最差的匹配。</span><br><span class="line"></span><br><span class="line">CV_TM_SQDIFF_NORMED 归一化平方差匹配法</span><br><span class="line"></span><br><span class="line">CV_TM_CCORR_NORMED 归一化相关匹配法</span><br><span class="line"></span><br><span class="line">CV_TM_CCOEFF_NORMED 归一化相关系数匹配法</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#导入所需库文件<br>import cv2<br>import numpy as np<br>​<br>#加载原始RGB图像<br>img_rgb = cv2.imread(“photo.jpg”) #创建一个原始图像的灰度版本，所有操作在灰度版本中处理，然后在RGB图像中使用相同坐标还原<br>img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)<br>#加载将要搜索的图像模板<br>template = cv2.imread(‘face.jpg’,0)<br>#记录图像模板的尺寸<br>w, h = template.shape[::-1]<br>​<br>#使用matchTemplate对原始灰度图像和图像模板进行匹配<br>res = cv2.matchTemplate(img_gray,template,cv2.TM_CCOEFF_NORMED)<br>#设定阈值 threshold = 0.7<br>#res大于70%<br>loc = np.where( res &gt;= threshold)<br>​<br>#使用灰度图像中的坐标对原始RGB图像进行标记<br>for pt in zip(*loc[::-1]):<br>  cv2.rectangle(img_rgb, pt, (pt[0] + w, pt[1] + h), (7,249,151), 2)<br>​<br>#显示图像<br>cv2.imshow(‘Detected’,img_rgb)<br>cv2.waitKey(0)<br>cv2.destroyAllWindows()<br>​</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 图片常见统计学处理</span><br><span class="line">### 直方图计算</span><br><span class="line">cv.calcHist()函数</span><br><span class="line"></span><br><span class="line">cv.calcHist（images，channels，mask，histSize，ranges ）</span><br><span class="line"></span><br><span class="line">images：uint8或float32类型的源图像,以方括号传入，如：[img]。</span><br><span class="line"></span><br><span class="line">channels：计算直方图的通道的索引，也以方括号给出。灰度图像，值为[0]。彩色图B/G/R分别传入[0]/[1]/[2]。</span><br><span class="line"></span><br><span class="line">mask：图像掩码。计算整幅图写None。若要查找图像特定区域的直方图，则必须为此创建一个掩码图像并将其作为掩码。</span><br><span class="line"></span><br><span class="line">histSize：也叫bins,子区段数目，如果我们统计0-255每个像素值，bins=256；如果划分区间，比如0-15, 16-31…240-255这样16个区间，bins=16。</span><br><span class="line"></span><br><span class="line">ranges：要计算的像素值范围，一般为[0,256)</span><br><span class="line"></span><br><span class="line">如：hist = cv2.calcHist([img], [0], None, [256], [0, 256])</span><br><span class="line"></span><br><span class="line"># Matplotlib方法</span><br><span class="line">## 绘制直方图</span><br><span class="line">Matplotlib.pyplot.hist()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>import cv2<br>import numpy as np<br>from matplotlib import pyplot as plt<br>​<br>img = cv2.imread(‘home.jpg’,0)<br>plt.hist(img.ravel(),256,[0,256])<br>plt.show()<br>```</p>
]]></content>
      <categories>
        <category>CV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>机器学习</tag>
        <tag>预处理</tag>
      </tags>
  </entry>
  <entry>
    <title>小米6刷Magisk全流程</title>
    <url>/2020/05/29/%E5%B0%8F%E7%B1%B36%E5%88%B7Magisk%E5%85%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><a href="https://github.com/topjohnwu/Magisk">Magisk</a>是一款开源安卓定制工具，支持 Android 5.0以上的操作系统。 </p>
<span id="more"></span>
<h1 id="解锁bootloader"><a href="#解锁bootloader" class="headerlink" title="解锁bootloader"></a>解锁bootloader</h1><p>需要：sim卡 ，<a href="http://www.miui.com/unlock/download.html">mi手机解锁工具</a></p>
<p>首先手机进入开发者模式（miui版本连击7次），进入解锁状态(需要sim卡联网)</p>
<p>绑定小米账号和设备(需验证码)，申请解锁设备</p>
<p>windows下载并运行mi手机解锁工具，登录小米账号</p>
<p>小米6手机关机后，同时长按音量“-”和电源，进入fastboot状态（界面出现一个兔子）</p>
<p>手机通过usb与电脑连接</p>
<p>点击解锁手机</p>
<p>解锁成功</p>
<h1 id="刷入第三方twrp-recovery"><a href="#刷入第三方twrp-recovery" class="headerlink" title="刷入第三方twrp recovery"></a>刷入第三方twrp recovery</h1><p>找到小米6对应的<a href="https://twrp.me/xiaomi/xiaomimi6.html">twrp recovery版本</a>，下载到本地</p>
<p>手机打开usb调试</p>
<p>终端运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#进入fastboot</span><br><span class="line">adb reboot bootloader</span><br><span class="line">#刷入img</span><br><span class="line">fastboot flash recovery twrp.img</span><br><span class="line">#重启</span><br><span class="line">fastboot reboot</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进入recovery</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot boot twrp.img</span><br></pre></td></tr></table></figure>

<p>注意：有可能会进到自带的Mi recovery，这样就得重新刷。尽量重启后在进入小米的系统之前就进入twrp。</p>
<p>小米进recovery的按钮是同时按音量“+”和电源</p>
<h1 id="lt-可选：刷入lineage-gt"><a href="#lt-可选：刷入lineage-gt" class="headerlink" title="&lt;可选：刷入lineage &gt;"></a>&lt;可选：刷入lineage &gt;</h1><p>下载lineage 的<a href="https://download.lineageos.org/">固件</a></p>
<p>进入 twrp recovery</p>
<p>把固件传入手机 <code>adb push lineage.zip /sdcard/</code></p>
<p>twrp 里install  固件（不选校验，选之后重启）</p>
<p>重启后如果有个绿色的弧线，说明进到lineage里了</p>
<h1 id="刷入Magisk"><a href="#刷入Magisk" class="headerlink" title="刷入Magisk"></a>刷入Magisk</h1><p>magisk push 到手机上，使用twrp安装。</p>
<p>重启后手机上出现magisk manager</p>
<p>若magisk manager一直显示要更新，可以把更新通道换为其他的：</p>
<p>进入”设置”，选择自定义通道输入这个链接:<br><a href="https://qianyegroup.gitee.io/magiskbuilds/updates/custom.json">https://qianyegroup.gitee.io/magiskbuilds/updates/custom.json</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Magisk</tag>
      </tags>
  </entry>
  <entry>
    <title>某三消游戏逆向(1)——lua脚本解密</title>
    <url>/2021/04/12/%E6%9F%90%E4%B8%89%E6%B6%88%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<p>目前手游游戏所用的引擎，常见的框架有cocos2d，Unity3d，unrealengine等。Lua由于其简单的语言结构和语法，用于很多游戏引擎。<br>这次以某常见三消游戏为例，来进行逆向工作。</p>
<h1 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h1><h2 id="确定分析对象"><a href="#确定分析对象" class="headerlink" title="确定分析对象"></a>确定分析对象</h2><p>解压apk安装包，进入./lib目录，都是.so的底层库。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lib39285EFA.so   //移动安全联盟 OAID SDK 广告服务等           </span><br><span class="line">libsgcore.so   //快手</span><br><span class="line">libBugly.so      //腾讯Bugly crash监控     </span><br><span class="line">libhegame.so       //游戏逻辑 </span><br><span class="line">libtobEmbedEncrypt.so  //bytedance广告</span><br><span class="line">libCtaApiLib.so      //极光JVerification Android SDK    </span><br><span class="line">libtquic.so   //quic协议？</span><br><span class="line">libShanYCore.so //闪验Flutter</span><br><span class="line">libiconv.so      //多语言编码  </span><br><span class="line">libtraeimp-rtmp.so  //腾讯云移动直播</span><br><span class="line">libbuffer_pg.so     //字节</span><br><span class="line">libindoor.so  //百度室内定位       </span><br><span class="line">libtxffmpeg.so  //ffmpeg</span><br><span class="line">libc++_shared.so     </span><br><span class="line">libkwad_common.so    </span><br><span class="line">libtxplayer.so  //腾讯云短视频</span><br><span class="line">libcostquic.so    //quic协议？  </span><br><span class="line">libliteavsdk.so  //移动直播sdk    </span><br><span class="line">libtxsdl.so     //腾讯sdl？</span><br><span class="line">libfile_lock_pg.so    </span><br><span class="line">liblocSDK7b.so      //百度定位？</span><br><span class="line">libweibosdkcore.so   //微博</span><br><span class="line">libmarsstn.so     //微信Mars 跨平台基础架构组件   </span><br><span class="line">libzbarjni.so    //Zbar读取条码</span><br><span class="line">libmarsxlog.so  //微信Mars 跨平台基础架构组件 </span><br><span class="line">libnms.so   //对象检测</span><br></pre></td></tr></table></figure>
<p>用ida打开可疑的libhegame.so 看到函数的名字有大量的lua ，可以知道开心消消乐使用的lua引擎（和网上搜索得到的信息一致）<br>assert/src 目录下是lua脚本，有经过加密，需要对.so文件进行分析找到密钥。</p>
<h2 id="分析libhegame-so"><a href="#分析libhegame-so" class="headerlink" title="分析libhegame.so"></a>分析libhegame.so</h2><p>方法名里搜索“lua”，可以看到都是jni的方法。</p>
<p>查看<code>j_Java_com_happyelements_test_TestService_initLua</code> 方法，一路跟进<code>sub_6EA84</code>。</p>
<p>可以看到初始化lua的方法应该是<code>com/happyelements/android/LuaHelper</code>类里的<code>initLuaEnv() </code>方法.</p>
<p>全文搜索“load_lua”，可以看到方法<code>sub_106B0C()</code>,根据调试信息可以看出此方法为加载lua文件的地方。</p>
<p>其中<code>sub_569864</code> 为读取lua文件，<code>sub_95C00</code> 为解码，<code>sub_97670</code>为解压缩</p>
<p><code>sub_95C00 -&gt; sub_95C18</code>  从调试信息 推测<code>sub_95C18</code>为openssl的EVP解码算法。</p>
<h1 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h1><h2 id="frida-hook-sub-95C00方法"><a href="#frida-hook-sub-95C00方法" class="headerlink" title="frida hook sub_95C00方法"></a>frida hook sub_95C00方法</h2><p>js脚本内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function get_func_addr(module, offset) &#123;</span><br><span class="line"> </span><br><span class="line">   var base_addr = Module.findBaseAddress(module);</span><br><span class="line">   console.log(&quot;base_addr: &quot; + base_addr);</span><br><span class="line"> </span><br><span class="line">   console.log(hexdump(ptr(base_addr), &#123;</span><br><span class="line">            length: 16,</span><br><span class="line">            header: true,</span><br><span class="line">            ansi: true</span><br><span class="line">        &#125;))</span><br><span class="line"> </span><br><span class="line">   var func_addr = base_addr.add(offset);</span><br><span class="line">   if (Process.arch == &#x27;arm&#x27;)</span><br><span class="line">      return func_addr.add(1);  //如果是32位地址+1</span><br><span class="line">   else</span><br><span class="line">      return func_addr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//var func_addr = get_func_addr(&#x27;libhegame.so&#x27;, 0x97670); </span><br><span class="line">var func_addr = get_func_addr(&#x27;libhegame.so&#x27;, 0x95C00); </span><br><span class="line">console.log(&#x27;func_addr: &#x27; + func_addr);</span><br><span class="line"> </span><br><span class="line">console.log(hexdump(ptr(func_addr), &#123;</span><br><span class="line">            length: 16,</span><br><span class="line">            header: true,</span><br><span class="line">            ansi: true</span><br><span class="line">        &#125;))</span><br><span class="line"> </span><br><span class="line">Interceptor.attach(ptr(func_addr), &#123;</span><br><span class="line">   onEnter: function(args) &#123;</span><br><span class="line"> </span><br><span class="line">      console.log(&quot;onEnter&quot;);</span><br><span class="line">      var num1 = args[0];</span><br><span class="line">      var num2 = args[1];</span><br><span class="line"> </span><br><span class="line">      console.log(&quot;num1: &quot; + num1);</span><br><span class="line">      console.log(&quot;num2: &quot; + num2);</span><br><span class="line"></span><br><span class="line">     console.log(hexdump(ptr(num1), &#123;</span><br><span class="line">        length: 16,</span><br><span class="line">        header: true,</span><br><span class="line">        ansi: true</span><br><span class="line">    &#125;))</span><br><span class="line"> </span><br><span class="line">   &#125;,</span><br><span class="line">   onLeave: function(retval) &#123;</span><br><span class="line"> </span><br><span class="line">      console.log(&quot;onLeave&quot;);</span><br><span class="line">      //retval.replace(3);  //返回值替换成3</span><br><span class="line">      console.log(&quot;return: &quot; + retval);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到密钥为<code>e9 74 7d 92 cc 32 2e 7d 11 2e 7c 34 51 d7 b3 6a</code></p>
<h2 id="解码lua文件"><a href="#解码lua文件" class="headerlink" title="解码lua文件"></a>解码lua文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#coding=UTF-8</span><br><span class="line">import Crypto</span><br><span class="line">import zlib</span><br><span class="line">from  Crypto.Cipher import AES</span><br><span class="line">def decdata(c):</span><br><span class="line">    key=b&#x27;\xe9\x74\x7d\x92\xcc\x32\x2e\x7d\x11\x2e\x7c\x34\x51\xd7\xb3\x6a&#x27;</span><br><span class="line">    iv=c[0:16]</span><br><span class="line">    main_data=c[16:]</span><br><span class="line">    cryptor = AES.new(key,AES.MODE_CBC,iv) </span><br><span class="line">    pad_compress_data=cryptor.decrypt(main_data)</span><br><span class="line">    str_len=len(pad_compress_data)</span><br><span class="line">    pad=pad_compress_data[-1]</span><br><span class="line">    compress_data=pad_compress_data[0:str_len-pad]</span><br><span class="line">    plain_text = zlib.decompress(compress_data)</span><br><span class="line">    return plain_text</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>Android</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Mac虚拟机（VirtualBox）无法登陆Xcode的开发账号问题</title>
    <url>/2019/09/20/%E8%A7%A3%E5%86%B3Mac%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88VirtualBox%EF%BC%89%E6%97%A0%E6%B3%95%E7%99%BB%E9%99%86Xcode%E7%9A%84%E5%BC%80%E5%8F%91%E8%B4%A6%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题表现形式"><a href="#问题表现形式" class="headerlink" title="问题表现形式"></a>问题表现形式</h2><p>登陆时输入正确的账户和密码，界面一直在loading状态，输入错误的密码会提示密码错误。<br>与此同时，在网页上可以成功登陆苹果开发者网站，说明不是网络或与服务器连接上出现问题。</p>
<span id="more"></span>

<h2 id="出现问题的原因"><a href="#出现问题的原因" class="headerlink" title="出现问题的原因"></a>出现问题的原因</h2><p>在登陆app atore 或添加Xcode账户的时候，需要验证apple id。苹果在验证时会检查机器的smbios 信息，如果不是 mac 机器，就不让登录，虚拟机也不行。<br>进入虚拟机后，点击左上角-关于本机 可查看虚拟机固件情况。<br>如果是未经修饰的虚拟机，下面序列号等信息都为空</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>在VirtualBox的配置文件中有“ExtraData”部分，可以通过修改配置文件的方法，伪造出虚假的smbios信息。</p>
<h3 id="如何获得虚假的smbios信息"><a href="#如何获得虚假的smbios信息" class="headerlink" title="如何获得虚假的smbios信息"></a>如何获得虚假的smbios信息</h3><p>可以通过下载Chameleon-Wizard 软件或者Clover Configurator软件进行配置。<br>配置方法比较傻瓜，选一个想要的型号，就会自动生成。最后保存为一个plist文件，需要的信息都在里面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ExtraDataItem name=&quot;GUI/InformationWindowGeometry&quot; value=&quot;0,45,1440,800,max&quot;/&gt;</span><br><span class="line">&lt;ExtraDataItem name=&quot;GUI/LastCloseAction&quot; value=&quot;PowerOff&quot;/&gt;</span><br><span class="line">&lt;ExtraDataItem name=&quot;GUI/LastNormalWindowPosition&quot; value=&quot;623,199,512,405&quot;/&gt;</span><br><span class="line">&lt;ExtraDataItem name=&quot;GUI/LastScaleWindowPosition&quot; value=&quot;400,194,640,480&quot;/&gt;</span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiBoardProduct&quot; value=&quot;Mac-06Fxxxx93F0323C5&quot;/&gt;</span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiBoardSerial&quot; value=&quot;C025xxxx0CDGDQPCB&quot;/&gt;  </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiSystemFamily&quot; value=&quot;MacBook Pro&quot;/&gt;         </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiSystemProduct&quot; value=&quot;MacBookPro11,4&quot;/&gt;           </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiSystemSerial&quot; value=&quot;C02PQ4ZBG8WL&quot;/&gt;</span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiSystemUuid&quot; value=&quot;CAFECAFE-xxxx-CAFE-CAFE-DECAFFDECAFF&quot;/&gt;           </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiOEMVBoxVer&quot; value=&quot;string:1&quot;/&gt;     </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiOEMVBoxRev=&quot; value=&quot;string:.23456&quot;/&gt;  </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiBIOSVersion&quot; value=&quot;MBP114.88Z.F000.B00.1906140921&quot;/&gt;     </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/efi/0/Config/DmiBIOSReleaseDate=&quot; value=&quot;06/14/2019&quot;/&gt;            </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/smc/0/Config/DeviceKey&quot; value=&quot;ourhardworkbythesewordsguardedpleasedontsteal(c)AppleComputerInc&quot;/&gt;</span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal/Devices/smc/0/Config/GetKeyFromRealSMC&quot; value=&quot;1&quot;/&gt;     </span><br><span class="line">&lt;ExtraDataItem name=&quot;VBoxInternal2/SharedFoldersEnableSymlinksCreate/vagrant&quot; value=&quot;1&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="通过配置命令修改信息"><a href="#通过配置命令修改信息" class="headerlink" title="通过配置命令修改信息"></a>通过配置命令修改信息</h3><p>cd至virtualbox目录下<br>执行 <code>VBoxManage setextradata &quot;OSName&quot; &quot;VBoxInternal/Devices/efi/0/Config/DmiSystemProduct&quot; &quot;MacBookPro11,3&quot;  </code>  修改SystemProduct信息<br>其他信息类似</p>
<p>在虚拟机已经建立后，这种方法不一定能够成功修改，慎用</p>
<h3 id="通过脚本直接新建虚拟机，在脚本里写上配置参数"><a href="#通过脚本直接新建虚拟机，在脚本里写上配置参数" class="headerlink" title="通过脚本直接新建虚拟机，在脚本里写上配置参数"></a>通过脚本直接新建虚拟机，在脚本里写上配置参数</h3><p>此方法参考开源项目<a href="https://github.com/myspaghetti/macos-guest-virtualbox">macos-guest-virtualbox</a></p>
<p>具体步骤：</p>
<ol>
<li>将工程下载或pull到本地</li>
<li>升级bash到bash4.0 参考<a href="https://8biiit.github.io/2019/09/20/Mac%E6%9B%B4%E6%96%B0bash%E8%87%B34-0%E4%BB%A5%E4%B8%8A/">Mac更新bash至4-0以上</a></li>
<li>安装依赖 bash  coreutils  wget  unzip  dmg2img</li>
<li>按照前面生成的plist信息修改脚本文件</li>
<li>cd 到目录下运行脚本 $ ./macos-guest-virtualbox.sh</li>
<li>一路enter，选择一下os版本，然后看提示信息一路enter<br>最后虚拟机建立好后，可以看到虚拟机的信息已经跟真机类似了，而且跟我们配置的参数一样，后面xcode的账户果然也可以正常登录</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="vmware虚拟机相同问题"><a href="#vmware虚拟机相同问题" class="headerlink" title="vmware虚拟机相同问题"></a>vmware虚拟机相同问题</h3><p>同样的，如果vmware出现相同问题，也可以通过修改配置文件的方法解决，具体参考：<br><a href="https://www.insanelymac.com/forum/topic/292170-how-to-spoof-real-mac-in-vmware/?page=1">https://www.insanelymac.com/forum/topic/292170-how-to-spoof-real-mac-in-vmware/?page=1</a><br><a href="https://www.insanelymac.com/forum/topic/309654-run-vanilla-os-x-el-capitan-sierra-high-sierra-or-mojave-in-virtualbox-5xx-on-a-windows-host/">https://www.insanelymac.com/forum/topic/309654-run-vanilla-os-x-el-capitan-sierra-high-sierra-or-mojave-in-virtualbox-5xx-on-a-windows-host/</a></p>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>Xcode</tag>
        <tag>VirtualBox</tag>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>解决mac上使用VirtualBox建立mac虚拟机分辨率问题</title>
    <url>/2019/08/21/%E8%A7%A3%E5%86%B3mac%E4%B8%8A%E4%BD%BF%E7%94%A8VirtualBox%E5%BB%BA%E7%AB%8Bmac%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%88%86%E8%BE%A8%E7%8E%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>mac主机使用virtualbox安装mac虚拟机经常出现分辨率问题，虚拟机 关于本机-&gt;显示器 里可查看可用的分辨率选项很低。<br>那么如何将虚拟机的分辨率调整至1920x1080,或是2880x1800呢？</p>
<span id="more"></span>

<p>首先将VirtualBox全部关闭<br>终端进入VirtualBox.app路径下<br>执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VBoxManage setextradata &quot;mac10.10.5&quot; CustomVideoMode1 2880x1800x32  #数组间的符号为小写字母x, 下同</span><br><span class="line">VBoxManage setextradata &quot;mac10.10.5&quot; VBoxInternal2/EfiGraphicsResolution 2880x1800</span><br></pre></td></tr></table></figure>
<p>引号内为虚拟机名称，可通过<code>VBoxManage list -s vms</code>命令查看</p>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>Mach-O文件详解</title>
    <url>/2019/08/09/Mach-O%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Mach-O是什么"><a href="#Mach-O是什么" class="headerlink" title="Mach-O是什么"></a>Mach-O是什么</h1><p>Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。类似于windows上的PE文件以及linux上的ELF文件。作为 a.out 格式的替代品，Mach-O提供更多的可扩展性和更快的符号表信息存取。大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS 是使用这种格式作为本地可执行文件、库和对象代码的例子。</p>
<span id="more"></span>

<p>Mach-O文件包含固定大小的头部(Header),几个可变大小的加载命令(LoadCommands)，一个或多个代码段(Segment)，每个代码段可以包含一个或多个代码区(Section)。</p>
<h1 id="胖二进制文件"><a href="#胖二进制文件" class="headerlink" title="胖二进制文件"></a>胖二进制文件</h1><p>为了使文件能运行在多个平台，出现了胖二进制文件(Fat Binary)，又叫通用二进制文件(Universal Binary)。使用lipo命令可以列出胖文件中的体系结构类型。胖二进制文件实际上是一个包装器(Wrapper)，一种将用于多种体系结构的Mach-O文件连接起来的简单存档。</p>
<p>胖二进制文件由胖头部(Fat Header)以及后面的 Mach-O 文件组成。胖头部包含一个幻数，后接一个整数值，表示二进制文件驻留在胖文件中的体系结构数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define FAT_MAGIC  0xcafebabe</span><br><span class="line">#define FAT_CIGAM  0xbebafeca  /* NXSwapLong(FAT_MAGIC) */</span><br><span class="line"> </span><br><span class="line">struct fat_header &#123;</span><br><span class="line">    uint32_t    magic;      /* FAT_MAGIC                        标记，表示是Fat的文件类型，是固定的0xcafebabe或者是0xbebafeca  */</span><br><span class="line">    uint32_t    nfat_arch;  /* number of structs that follow    包含了多个少Mach-O文件        */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再后面是一系列胖体系结构指示符(fat_arch)，每个指示符用于胖文件中包含的一种体系结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct fat_arch &#123;</span><br><span class="line">    cpu_type_t  cputype;    /* cpu specifier (int)              支持的CPU类型，一般有ARMV7，ARM64，X86，X86_64这几种类型  */</span><br><span class="line">    cpu_subtype_t   cpusubtype; /* machine specifier (int)      子CPU类型*/</span><br><span class="line">    uint32_t    offset;     /* file offset to this object file  当前架构的 Mach-O 文件的数据相对于文件开头的偏移位置 */</span><br><span class="line">    uint32_t    size;       /* size of this object file         数据的大小*/</span><br><span class="line">    uint32_t    align;      /* alignment as a power of 2        数据的内存对齐边界 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>offset 在armv7中是16384(0x4000)，arm64中是4294967296 （0x10000 0000）</p>
<p>注意：尽管胖文件中的Mach-O文件遵循其所在体系结构的字节序，但fat_header和fat_arch总是大端字节储存。 MacOS是小端序的。</p>
<h2 id="合并和瘦身"><a href="#合并和瘦身" class="headerlink" title="合并和瘦身"></a>合并和瘦身</h2><p>Xcode 在编译 iOS 程序可以选择同时支持 ARMV7 和 ARM64，编译 macOS 程序也可以选择同时支持 x86 和 x86_64，但是如果一个程序需要同时支持 iOS 和 macOS 的时候，Xcode 不能自动生成，可以使用 lipo 命令手动对文件进行合并。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$lipo -create test_iPhone test_macOS -output test_all</span><br></pre></td></tr></table></figure>

<p>由于每个 CPU 平台都是单独的一个 Mach-O 文件，然后合成的 Fat 文件，所以体积会变大，比如某个程序我们只需要支持 ARM64，就可以把其他平台给移除掉，这样就能起到 “瘦身” 的作用，使用 lipo 命令移除其他平台。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$lipo -thin arm64 ~/debugserver -output ~/debugserver</span><br></pre></td></tr></table></figure>

<h1 id="Mach-O结构"><a href="#Mach-O结构" class="headerlink" title="Mach-O结构"></a>Mach-O结构</h1><p>Mach-O 没有类似于 XML、YAML、JSON 等诸如此类的特殊格式，它只是一个二进制字节流，被划分为了有意义的数据块。这些块包含元信息，比如，字节顺序、cpu 类型、块的大小，等等。</p>
<p>典型的 Mach-O 文件包含三个区域：</p>
<ul>
<li>Header-包含该二进制文件的一般信息：字节顺序、（魔数）、cpu 类型、LoadCommands的数量等等。</li>
<li>LoadCommands -它是一张包含很多内容的表，内容包括区域的位置、符号表、动态符号表等。每个加载指令都包含一个元信息，比如指令类型、名称、在二进制文件中的位置等等。加载Mach-O文件时会使用这里的数据来确定内存的分布</li>
<li>Data-通常是对象文件中最大的部分。每一个segment的具体数据都保存在这里。主要包含代码、数据，例如符号表，动态符号表等等。</li>
</ul>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>Headers的主要作用就是帮助系统迅速的定位Mach-O文件的运行环境，以下是mach_header与mach_header_64的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The 32-bit mach header appears at the very beginning of the object file for</span><br><span class="line"> * 32-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header &#123;</span><br><span class="line">  uint32_t  magic;    /* mach magic number identifier    和 fat_hader 里的 magic 类似，也是一个标记，32 位的值是 MH_MAGIC，64位的值是 MH_CIGAM_64。 */</span><br><span class="line">  cpu_type_t  cputype;  /* cpu specifier                 与 fat_arch 里的 cputype 的含义一样。*/</span><br><span class="line">  cpu_subtype_t cpusubtype; /* machine specifier         与 fat_arch 里的 cpusubtype 的含义一样*/</span><br><span class="line">  uint32_t  filetype; /* type of file                    可执行文件就是 MH_EXECUTE，如果是动态库就是 MH_DYLIB  */</span><br><span class="line">  uint32_t  ncmds;    /* number of load commands         表示 Mach-O 文件中 load command (加载命令)的个数  */</span><br><span class="line">  uint32_t  sizeofcmds; /* the size of all the load commands   表示load command (加载命令) 占用的字节总大小  */</span><br><span class="line">  uint32_t  flags;    /* flags                                 表示dyld加载时文件的标志信息*/</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/* Constant for the magic field of the mach_header (32-bit architectures) */</span><br><span class="line">#define MH_MAGIC  0xfeedface  /* the mach magic number */</span><br><span class="line">#define MH_CIGAM  0xcefaedfe  /* NXSwapInt(MH_MAGIC) */</span><br><span class="line">​</span><br><span class="line">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">  uint32_t  magic;    /* mach magic number identifier */</span><br><span class="line">  cpu_type_t  cputype;  /* cpu specifier */</span><br><span class="line">  cpu_subtype_t cpusubtype; /* machine specifier */</span><br><span class="line">  uint32_t  filetype; /* type of file */</span><br><span class="line">  uint32_t  ncmds;    /* number of load commands */</span><br><span class="line">  uint32_t  sizeofcmds; /* the size of all the load commands */</span><br><span class="line">  uint32_t  flags;    /* flags */</span><br><span class="line">  uint32_t  reserved; /* reserved                                  系统保留字段  */</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span><br><span class="line">#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */</span><br><span class="line">#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */</span><br></pre></td></tr></table></figure>

<p>Mach-O文件不仅仅用来实现可执行文件，同时还用来实现了其他内容。</p>
<p>filetype:<br>​```<br>#define MH_OBJECT 0x1   /* relocatable object file               一个中间的，可重定位的目标文件，也可用于内核扩展(传统具有.o后缀)<em>/<br>#define MH_EXECUTE  0x2   /</em> demand paged executable file        一个标准的按需分页的可执行文件*/<br>#define MH_FVMLIB 0x3   /* fixed VM shared library file          CoreDump <em>/<br>#define MH_CORE   0x4   /</em> core file                             用于存储中止程序的地址空间的文件，包含”核心转储“的核心文件(core file)<em>/<br>#define MH_PRELOAD  0x5   /</em> preloaded executable file <em>/<br>#define MH_DYLIB  0x6   /</em> dynamically bound shared library      一个动态共享库*/<br>#define MH_DYLINKER 0x7   /* dynamic link editor                 一个特殊共享库，是一个动态链接器 <em>/<br>#define MH_BUNDLE 0x8   /</em> dynamically bound bundle file         在运行时以编程方式加载进应用程序中的插件代码*/<br>#define MH_DYLIB_STUB 0x9   /* shared library stub for static <em>/<br>          /</em>  linking only, no section contents <em>/<br>#define MH_DSYM   0xa   /</em> companion file with only debug <em>/<br>          /</em>  sections <em>/<br>#define MH_KEXT_BUNDLE  0xb   /</em> x86_64 kexts                     内核扩展文件*/</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Mach-O headers还包含了一些很重要的dyld的加载参数</span><br><span class="line"></span><br><span class="line">flags:</span><br></pre></td></tr></table></figure>
<p>/* Constants for the flags field of the mach_header <em>/<br>#define    MH_NOUNDEFS 0x1     /</em> the object file has no undefinedreferences    目标文件没有未定义的符号，不存在链接依赖*/<br>#define    MH_INCRLINK 0x2     /* the object file is the output of an<br>                       incremental link against a base file<br>                       and can’t be link edited again <em>/<br>#define MH_DYLDLINK    0x4     /</em> the object file is input for the              目标文件是动态链接输入文件，不能被再次静态链接<br>                       dynamic linker and can’t be staticly<br>                       link edited again <em>/<br>#define MH_BINDATLOAD  0x8     /</em> the object file’s undefined<br>                       references are bound by the dynamic<br>                       linker when loaded. <em>/<br>#define MH_PREBOUND    0x10        /</em> the file has its dynamic undefined<br>                       references prebound. <em>/<br>#define MH_SPLIT_SEGS  0x20        /</em> the file has its read-only and            只读 segments 和 可读写 segments 分离<br>                       read-write segments split <em>/<br>#define MH_LAZY_INIT  0x40    /</em> the shared library init routine is<br>             to be run lazily via catching memory<br>             faults to its writeable segments<br>             (obsolete) <em>/<br>#define MH_TWOLEVEL 0x80    /</em> the image is using two-level name<br>             space bindings */<br>​<br>/*MH_NO_HEAP_EXECUTION 堆内存不可执行<br>MH_PIE  允许随机的地址空间<br>MH_ALLOW_STACK_EXECUTION  栈内存可执行代码，一般是默认关闭的。<br>MH_NO_HEAP_EXECUTION  堆内存无法执行代码<br>*/</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## LoadCommands</span><br><span class="line">Headers 之后就是 Load Commands，其占用的内存和加载命令的总数在 Headers 中已经指出。</span><br><span class="line"></span><br><span class="line">load_command 数据结构:</span><br><span class="line">​```</span><br><span class="line">struct load_command &#123;</span><br><span class="line">  uint32_t cmd;   /* type of load command             加载命令类型 */</span><br><span class="line">  uint32_t cmdsize; /* total size of command in bytes 命令的总大小，以字节为单位*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cmd结构类型:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Constants for the cmd field of all load commands, the type */</span><br><span class="line">#define    LC_SEGMENT  0x1 /* segment of this file to be mapped */</span><br><span class="line">#define    LC_SYMTAB   0x2 /* link-edit stab symbol table info */</span><br><span class="line">#define    LC_SYMSEG   0x3 /* link-edit gdb symbol table info (obsolete) */</span><br><span class="line">#define    LC_THREAD   0x4 /* thread */</span><br><span class="line">#define    LC_UNIXTHREAD   0x5 /* unix thread (includes a stack) */</span><br><span class="line">#define    LC_LOADFVMLIB   0x6 /* load a specified fixed VM shared library */</span><br><span class="line">#define    LC_IDFVMLIB 0x7 /* fixed VM shared library identification */</span><br><span class="line">#define    LC_IDENT    0x8 /* object identification info (obsolete) */</span><br><span class="line">#define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */</span><br><span class="line">#define LC_PREPAGE      0xa     /* prepage command (internal use) */</span><br><span class="line">#define    LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */</span><br><span class="line">#define    LC_LOAD_DYLIB   0xc /* load a dynamically linked shared library */</span><br><span class="line">#define    LC_ID_DYLIB 0xd /* dynamically linked shared lib ident */</span><br><span class="line">#define LC_LOAD_DYLINKER 0xe   /* load a dynamic linker */</span><br><span class="line">#define LC_ID_DYLINKER 0xf /* dynamic linker identification */</span><br><span class="line">#define    LC_PREBOUND_DYLIB 0x10  /* modules prebound for a dynamically */</span><br><span class="line">                /*  linked shared library */</span><br><span class="line">#define    LC_ROUTINES 0x11    /* image routines */</span><br><span class="line">#define    LC_SUB_FRAMEWORK 0x12   /* sub framework */</span><br><span class="line">#define    LC_SUB_UMBRELLA 0x13    /* sub umbrella */</span><br><span class="line">#define    LC_SUB_CLIENT   0x14    /* sub client */</span><br><span class="line">#define    LC_SUB_LIBRARY  0x15    /* sub library */</span><br><span class="line">#define    LC_TWOLEVEL_HINTS 0x16  /* two-level namespace lookup hints */</span><br><span class="line">#define    LC_PREBIND_CKSUM  0x17  /* prebind checksum */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * load a dynamically linked shared library that is allowed to be missing</span><br><span class="line"> * (all symbols are weak imported).</span><br><span class="line"> */</span><br><span class="line">#define    LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)</span><br><span class="line"> </span><br><span class="line">#define    LC_SEGMENT_64   0x19    /* 64-bit segment of this file to be</span><br><span class="line">                   mapped */</span><br><span class="line">#define    LC_ROUTINES_64  0x1a    /* 64-bit image routines */</span><br><span class="line">#define LC_UUID        0x1b    /* the uuid */</span><br><span class="line">#define LC_RPATH       (0x1c | LC_REQ_DYLD)    /* runpath additions */</span><br><span class="line">#define LC_CODE_SIGNATURE 0x1d /* local of code signature */</span><br><span class="line">#define LC_SEGMENT_SPLIT_INFO 0x1e /* local of info to split segments */</span><br><span class="line">#define LC_REEXPORT_DYLIB (0x1f | LC_REQ_DYLD) /* load and re-export dylib */</span><br><span class="line">#define    LC_LAZY_LOAD_DYLIB 0x20 /* delay load of dylib until first use */</span><br><span class="line">#define    LC_ENCRYPTION_INFO 0x21 /* encrypted segment information */</span><br><span class="line">#define    LC_DYLD_INFO    0x22    /* compressed dyld information */</span><br><span class="line">#define    LC_DYLD_INFO_ONLY (0x22|LC_REQ_DYLD)    /* compressed dyld information only */</span><br><span class="line">#define    LC_LOAD_UPWARD_DYLIB (0x23 | LC_REQ_DYLD) /* load upward dylib */</span><br><span class="line">#define LC_VERSION_MIN_MACOSX 0x24   /* build for MacOSX min OS version */</span><br><span class="line">#define LC_VERSION_MIN_IPHONEOS 0x25 /* build for iPhoneOS min OS version */</span><br><span class="line">#define LC_FUNCTION_STARTS 0x26 /* compressed table of function start addresses */</span><br><span class="line">#define LC_DYLD_ENVIRONMENT 0x27 /* string for dyld to treat</span><br><span class="line">                    like environment variable */</span><br><span class="line">#define LC_MAIN (0x28|LC_REQ_DYLD) /* replacement for LC_UNIXTHREAD */</span><br><span class="line">#define LC_DATA_IN_CODE 0x29 /* table of non-instructions in __text */</span><br><span class="line">#define LC_SOURCE_VERSION 0x2A /* source version used to build binary */</span><br><span class="line">#define LC_DYLIB_CODE_SIGN_DRS 0x2B /* Code signing DRs copied from linked dylibs */</span><br><span class="line">#define    LC_ENCRYPTION_INFO_64 0x2C /* 64-bit encrypted segment information */</span><br><span class="line">#define LC_LINKER_OPTION 0x2D /* linker options in MH_OBJECT files */</span><br><span class="line">#define LC_LINKER_OPTIMIZATION_HINT 0x2E /* optimization hints in MH_OBJECT files */</span><br><span class="line">#ifndef __OPEN_SOURCE__</span><br><span class="line">#define LC_VERSION_MIN_TVOS 0x2F /* build for AppleTV min OS version */</span><br><span class="line">#endif /* __OPEN_SOURCE__ */</span><br><span class="line">#define LC_VERSION_MIN_WATCHOS 0x30 /* build for Watch min OS version */</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">结构</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LC_SEGMENT、LC_SEGMENT_64</td>
<td align="left">将 segment 映射到进程的内存空间，</td>
</tr>
<tr>
<td align="center">LC_ID_DYLIB</td>
<td align="left">动态库</td>
</tr>
<tr>
<td align="center">LC_UUID</td>
<td align="left">二进制文件 id，与符号表 uuid 对应，可用作符号表匹配</td>
</tr>
<tr>
<td align="center">LC_LOAD_DYLINKER</td>
<td align="left">启动动态加载器，</td>
</tr>
<tr>
<td align="center">LC_SYMTAB</td>
<td align="left">描述在 __LINKEDIT 段的哪找字符串表、符号表</td>
</tr>
<tr>
<td align="center">LC_CODE_SIGNATURE</td>
<td align="left">代码数字签名等</td>
</tr>
<tr>
<td align="center">LC_THREAD</td>
<td align="left">开启一个MACH线程，但是不分配栈空间</td>
</tr>
<tr>
<td align="center">LC_UNIXTHREAD</td>
<td align="left">开启一个UNIX线程</td>
</tr>
<tr>
<td align="center">LC_ENCRYPTION_INFO</td>
<td align="left">加密二进制文件</td>
</tr>
<tr>
<td align="center">LC_RPATH</td>
<td align="left">程序运行时的查找路径</td>
</tr>
<tr>
<td align="center">LC_VERSION_MIN_IPHONEOS</td>
<td align="left">支持最低的 iOS 版本号</td>
</tr>
<tr>
<td align="center">LC_MAIN</td>
<td align="left">记录了可执行文件的主函数main()的位置</td>
</tr>
</tbody></table>
<p>LC_MAIN加载命令中的Entry Offset字段+基地址（RVA选项下的文件头部地址）= IDA中左侧函数_main的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct entry_point_command &#123;</span><br><span class="line">    uint32_t  cmd;  /* LC_MAIN only used in MH_EXECUTE filetypes */</span><br><span class="line">    uint32_t  cmdsize;  /* 24 */</span><br><span class="line">    uint64_t  entryoff; /* file (__TEXT) offset of main()      main() 函数的文件偏移*/</span><br><span class="line">    uint64_t  stacksize;/* if not zero, initial stack size */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Segment-amp-Section"><a href="#Segment-amp-Section" class="headerlink" title="Segment &amp; Section"></a>Segment &amp; Section</h2><p>加载数据时，主要加载的就是<code>LC_SEGMET</code>或<code>LC_SEGMENT_64</code>。<code>LC_SEGMENT</code>的数据结构是这样的。这里大部分的数据是用来帮助内核将Segment映射到虚拟内存的</p>
<p>segment_command:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct segment_command &#123; /* for 32-bit architectures */</span><br><span class="line">  uint32_t  cmd;    /* LC_SEGMENT */</span><br><span class="line">  uint32_t  cmdsize;  /* includes sizeof section structs */</span><br><span class="line">  char    segname[16];  /* segment name                     段的名称,常见的段名称有 __PAGEZERO、__LINKEDIT、__TEXT、__DATA*/</span><br><span class="line">  uint32_t  vmaddr;   /* memory address of this segment     段要加载的虚拟内存地址 未偏移），由于 ALSR，程序会在进程加上一段偏移量（slide），真实的地址 = vm address + slide*/</span><br><span class="line">  uint32_t  vmsize;   /* memory size of this segment        段所占的虚拟内存的大小*/</span><br><span class="line">  uint32_t  fileoff;  /* file offset of this segment        段数据所有的文件中的偏移地址*/</span><br><span class="line">  uint32_t  filesize; /* amount to map from the file        段数据的大小*/</span><br><span class="line">  vm_prot_t maxprot;  /* maximum VM protection              页面所需要的最高内存保护*/</span><br><span class="line">  vm_prot_t initprot; /* initial VM protection              页面初始的内存保护*/</span><br><span class="line">  uint32_t  nsects;   /* number of sections in segment      标示了Segment中有多少secetion */</span><br><span class="line">  uint32_t  flags;    /* flags                              段的标志信息*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__PAGEZERO : 可执行文件有的，动态库里没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常。这个段的大小，32位上是 0x4000，64位上是 4G。</span><br><span class="line">__TEXT：代码段，里面主要是存放代码的，该段是可读可执行，但是不可写。</span><br><span class="line">__DATA ：数据段，里面主要是存放数据，该段是可读可写，但不可执行。</span><br><span class="line">__LINKEDIT ：用于存放签名信息，该段是只可读，不可写不可执行。 包含需要被动态链接器使用的信息，包括符号表、字符串表、重定位项表等</span><br><span class="line">__OBJC 包含会被Objective Runtime使用到的一些数据</span><br></pre></td></tr></table></figure>

<p>section:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct section &#123; /* for 32-bit architectures */</span><br><span class="line">  char    sectname[16]; /* name of this section               section的名称，最长 16 字节大小*/</span><br><span class="line">  char    segname[16];  /* segment this section goes in       节区所在的段名*/</span><br><span class="line">  uint32_t  addr;   /* memory address of this section         节区所在的内存地址*/</span><br><span class="line">  uint32_t  size;   /* size in bytes of this section          节区所在的大小*/</span><br><span class="line">  uint32_t  offset;   /* file offset of this section          节区所在文件偏移*/</span><br><span class="line">  uint32_t  align;    /* section alignment (power of 2)       节区的内存对齐边界*/</span><br><span class="line">  uint32_t  reloff;   /* file offset of relocation entries    重定位信息的文件偏移*/</span><br><span class="line">  uint32_t  nreloc;   /* number of relocation entries         重定位条目的个数 */</span><br><span class="line">  uint32_t  flags;    /* flags (section type and attributes)  节区的标志属性  如果是 SG_PROTECTED_VERSION_1，表示该段是经过加密的*/</span><br><span class="line">  uint32_t  reserved1;  /* reserved (for offset or index) */</span><br><span class="line">  uint32_t  reserved2;  /* reserved (for count or sizeof) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="TEXT"><a href="#TEXT" class="headerlink" title="TEXT"></a>TEXT</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_text：主程序代码</span><br><span class="line">__cstring: 硬编码的字符串 去重后的C字符串</span><br><span class="line">const  初始化过的常量</span><br><span class="line">__stubs 桩代码 符号桩。本质上是一小段会直接跳入lazybinding的表对应项指针指向的地址的代码。</span><br><span class="line">__stub_helper：辅助函数。上述提到的lazybinding的表中对应项的指针在没有找到真正的符号地址的时候，都指向这。</span><br><span class="line">__symbolstub1：用于动态链接的存根</span><br><span class="line">unwind_info：用于存储处理异常情况信息</span><br><span class="line">__objc_methname：Objective-C的方法名</span><br><span class="line">__objc_classname：Objective-C的类名</span><br><span class="line">__cstring：硬编码的字符串</span><br><span class="line">_DATA </span><br><span class="line">__data 初始化可变的数据</span><br><span class="line">const 没有初始化过的常量</span><br><span class="line">__objc_imageinfo 镜像信息 ，在运行时初始化时 objc_init，调用 load_images 加载新的镜像到 infolist 中</span><br><span class="line">__lazy_symbol：懒加载，延迟加载节，通过dyld_stub_binder辅助链接</span><br><span class="line">_got：存储引用符号的实际地址，类似于动态符号表</span><br><span class="line">__la_symbol_ptr: lazy-binding的指针表，每个表项中的指针一开始指向stub_helper</span><br><span class="line">__nl_symbol_ptr：非lazy-binding的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</span><br><span class="line">__mod_init_func：初始化的全局函数地址，在主要之前被调用  初始化函数，在main之前调用</span><br><span class="line">__mod_term_func：结束函数地址    终止函数，在main返回之后调用</span><br><span class="line">__cfstring：Core Foundation用到的字符串（OC字符串）</span><br><span class="line">__objc_classlist 类列表</span><br><span class="line">__objc_classrefs 引用的类</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-Table-amp-String-Table"><a href="#Symbol-Table-amp-String-Table" class="headerlink" title="Symbol Table &amp; String Table"></a>Symbol Table &amp; String Table</h2><p>Symbol 表的头信息是在 LoadCommand 里的 LC_SYMTAB，其中 symoff 表示符号表的偏移。符号表的结构是一个连续的列表，其中的每一项都是一个 struct nlist。 </p>
<p>nlist：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct nlist &#123;</span><br><span class="line">  union &#123;</span><br><span class="line">    uint32_t n_strx;  /*符号名在字符串表中的偏移量  */</span><br><span class="line">  &#125; n_un;</span><br><span class="line">  uint8_t n_type;</span><br><span class="line">  uint8_t n_sect;      /*节的索引*/</span><br><span class="line">  int16_t n_desc;     </span><br><span class="line">  uint32_t n_value;     /*函数对应的地址*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态库载入信息 Dynamic Loader Info</li>
<li>入口函数 Function Starts</li>
<li>符号表 Symbol Table</li>
<li>动态库符号表 Dynamic Symbol Table</li>
<li>字符串表 String Table</li>
</ul>
<h1 id="Mach-O执行"><a href="#Mach-O执行" class="headerlink" title="Mach-O执行"></a>Mach-O执行</h1><p>当你点击一个icon启动应用程序的时候，系统在内部大致做了如下几件事：</p>
<ul>
<li>内核（OS Kernel）创建一个进程，分配虚拟的进程空间等等，加载动态链接器。</li>
<li>通过动态链接器加载主二进制程序引用的库、绑定符号。</li>
<li>启动程序</li>
</ul>
<h2 id="内核处理流程"><a href="#内核处理流程" class="headerlink" title="内核处理流程"></a>内核处理流程</h2><h3 id="二进制文件加载过程"><a href="#二进制文件加载过程" class="headerlink" title="二进制文件加载过程"></a>二进制文件加载过程</h3><p>下面列出来在加载二进制文件过程中依次调用的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">execve</span><br><span class="line">__mac_execve</span><br><span class="line">exec_activate_image</span><br><span class="line">exec_mach_imgact</span><br><span class="line">load_machfile</span><br><span class="line">parse_machfile</span><br><span class="line">load_dylinker</span><br></pre></td></tr></table></figure>

<h3 id="加载dyld过程"><a href="#加载dyld过程" class="headerlink" title="加载dyld过程"></a>加载dyld过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">load_dylinker&#123;</span><br><span class="line">  get_macho_vnode&#123;</span><br><span class="line">    //读取dyld的fat_header</span><br><span class="line">    vn_rdwr&#123;&#125;</span><br><span class="line">    //读取dyld的mach_header</span><br><span class="line">    vn_rdwr&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parse_machfile&#123;</span><br><span class="line">    //Map the load commands into kernel memory.</span><br><span class="line">    vn_rdwr&#123;&#125;</span><br><span class="line">    load_segment&#123;</span><br><span class="line">      //这里进行了slide偏移, 并且在对_TEXT segment 进行映射时重新定位了, result-&gt;mach_header,  这个的原理像elf的segment加载时, 把elf-header算在第一个segment上.</span><br><span class="line">      map_segment&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dyld处理流程"><a href="#dyld处理流程" class="headerlink" title="dyld处理流程"></a>dyld处理流程</h2><p>dyld 的处理过程在 dyld.cpp, 从 LC_MAIN 拿到地址后转到 <code>dyld.cpp/_main()</code> 执行</p>
<p>一切的开始是dyldbootstrap::start这个函数.它去调用了dyld::main函数.这个函数从外部传入Mach-O的header,在dyld::main中,dyld会去设置运行环境,配置相关的环境变量.</p>
<h3 id="处理环境变量"><a href="#处理环境变量" class="headerlink" title="处理环境变量"></a>处理环境变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  configureProcessRestrictions(mainExecutableMH);</span><br><span class="line">#if __MAC_OS_X_VERSION_MIN_REQUIRED</span><br><span class="line">    if ( gLinkContext.processIsRestricted ) &#123;</span><br><span class="line">    pruneEnvironmentVariables(envp, &amp;apple);</span><br><span class="line">    // set again because envp and apple may have changed or moved</span><br><span class="line">    setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">#endif</span><br><span class="line">  &#123;</span><br><span class="line">    checkEnvironmentVariables(envp);</span><br><span class="line">    defaultUninitializedFallbackPaths(envp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">configureProcessRestrictions //对 ios 和 osx 做了区分, ios 默认不支持任何环境变量</span><br><span class="line">|</span><br><span class="line">checkEnvironmentVariables //检查环境变量, 之后调用下一个函数做处理</span><br><span class="line">|</span><br><span class="line">processDyldEnvironmentVariable //处理环境变量, 设置gLinkContext</span><br></pre></td></tr></table></figure>
<p>这里有一个关键的过程 setContext(mainExecutableMH, argc, argv, envp, apple); 设置上下文需要使用到的全局变量.</p>
<h3 id="解析macho执行文件"><a href="#解析macho执行文件" class="headerlink" title="解析macho执行文件"></a>解析macho执行文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  </span><br><span class="line">    // instantiate ImageLoader for main executable</span><br><span class="line">    sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">    gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">    gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line">从 instantiateFromLoadedImage 开始解析</span><br><span class="line"></span><br><span class="line">instantiateFromLoadedImage</span><br><span class="line">// 检查文件格式, 加载主可执行文件, 记录该image到全局环境变量</span><br><span class="line">instantiateFromLoadedImage:dyld.cpp</span><br><span class="line">&#123;</span><br><span class="line">  // 处理加载命令, 根据加载命令处理加载可执行文件</span><br><span class="line">  ImageLoaderMachO::instantiateMainExecutable:ImageLoaderMachO.cpp</span><br><span class="line">  &#123; </span><br><span class="line">    // 处理, 区分加载命令</span><br><span class="line">    ImageLoaderMachO::sniffLoadCommands:ImageLoaderMachO.cpp</span><br><span class="line">    // 根据加载命令, 开始加载可执行文件  ImageLoaderMachOCompressed::instantiateMainExecutable:ImageLoaderMachOCompressed.cpp</span><br><span class="line">    &#123;</span><br><span class="line">      // 创建ImageLoaderMachOCompressed对象</span><br><span class="line">      ImageLoaderMachOCompressed::instantiateStart:ImageLoaderMachOCompressed.cpp</span><br><span class="line">      // 根据加载命令填充ImageLoaderMachOCompressed对象</span><br><span class="line">      ImageLoaderMachOCompressed::instantiateFinish:ImageLoaderMachOCompressed.cpp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 记录image到全局变量</span><br><span class="line">  addImage:dyld.cpp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载共享动态库"><a href="#加载共享动态库" class="headerlink" title="加载共享动态库"></a>加载共享动态库</h3><p>在环境变量配置完毕后,dyld会去加载共享缓存</p>
<p>加载的步骤是先通过checkShareRegionDisable函数检查是否被关闭,iOS下必须开启共享缓存,如果没有被禁用,那么就会调用mapSharedCache函数去加载,当然实际加载是在该函数内调用的loadDyldCache函数,加载共三种,fast Path(已经加载的不需要再加载),slow path(第一次调用则去加载.mapCacheSystemWide),还有一种是模拟器下(simulator)的.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">​</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide,</span><br><span class="line">​</span><br><span class="line">int argc, const char* argv[], const char* envp[], const char* apple[],</span><br><span class="line">​</span><br><span class="line">uintptr_t* startGlue)</span><br><span class="line">​</span><br><span class="line">&#123;</span><br><span class="line">​</span><br><span class="line"> [...]</span><br><span class="line">​</span><br><span class="line">// load shared cache</span><br><span class="line">​</span><br><span class="line"> checkSharedRegionDisable();</span><br><span class="line">​</span><br><span class="line">#if DYLD_SHARED_CACHE_SUPPORT</span><br><span class="line">​</span><br><span class="line">if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">​</span><br><span class="line"> mapSharedCache(); // 判断是否存在共享动态库, 如果存在直接使用, 否则进行加载, gLinkContext记录共享库地址</span><br><span class="line">​</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">​</span><br><span class="line">dyld_kernel_image_info_t kernelCacheInfo;</span><br><span class="line">​</span><br><span class="line"> bzero(&amp;kernelCacheInfo.uuid[0], sizeof(uuid_t));</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.load_addr = 0;</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.fsobjid.fid_objno = 0;</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.fsobjid.fid_generation = 0;</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.fsid.val[0] = 0;</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.fsid.val[0] = 0;</span><br><span class="line">​</span><br><span class="line"> task_register_dyld_shared_cache_image_info(mach_task_self(), kernelCacheInfo, true, false);</span><br><span class="line">​</span><br><span class="line"> &#125;</span><br><span class="line">​</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>当共享缓存被加载后,接下来,dyld就会继续在main函数中加载我们的主程序也就是我们的可执行文件。我们在方法中找到instantiateFromLoadedImage这个函数,在这个函数里,dyld会实例化我们的可执行文件。它实际上是通过我们传进来的machO的header判断当前cpu是否支持当前我们的machO的架构.如果支持则调用instantiateMainExecutable函数去实例化我们的可执行文件,并添加到imageList中。</p>
<p>当然可执行文件的实例化是在instantiateMainExecutable函数内部实现的,在该函数内部先调用了sniffLoadCommands,这个函数通过读取loadCommand段内的信息去加载。在sniffLoadCommands中严格判断了loadCommands的条数,不能超过255条,依赖的库不能超过4095个。最后该函数会修改Compress值,外部的instantiateMainExecutable函数会通过这个值来决定加载主程序的方式。在主程序被实例化加载后,接下来dyld就会继续在main函数中去加载我们插入的动态库,具体加载函数在loadInsertedDylib里进行。</p>
<h3 id="加载DYLD-INSERT-LIBRARIES的动态库"><a href="#加载DYLD-INSERT-LIBRARIES的动态库" class="headerlink" title="加载DYLD_INSERT_LIBRARIES的动态库"></a>加载DYLD_INSERT_LIBRARIES的动态库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">    // load any inserted libraries</span><br><span class="line">    if  ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</span><br><span class="line">      for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) </span><br><span class="line">        loadInsertedDylib(*lib);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loadInsertedDylib：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loadInsertedDylib:dyld.cpp</span><br><span class="line">&#123;</span><br><span class="line">  load:dyld.cpp</span><br><span class="line">  &#123;</span><br><span class="line">    loadPhase0:dyld.cpp</span><br><span class="line">    loadPhase1:dyld.cpp</span><br><span class="line">    loadPhase2:dyld.cpp</span><br><span class="line">    loadPhase3:dyld.cpp</span><br><span class="line">    loadPhase4:dyld.cpp</span><br><span class="line">    loadPhase5:dyld.cpp</span><br><span class="line">    loadPhase5check:dyld.cpp</span><br><span class="line">    loadPhase5load:dyld.cpp</span><br><span class="line">    loadPhase5stat:dyld.cpp</span><br><span class="line">    loadPhase5load:dyld.cpp</span><br><span class="line">    loadPhase5open:dyld.cpp</span><br><span class="line">    loadPhase6</span><br><span class="line">    &#123;</span><br><span class="line">      checkandAddImage::dyld.cpp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载依赖动态库"><a href="#加载依赖动态库" class="headerlink" title="加载依赖动态库"></a>加载依赖动态库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">    link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">    sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">    if ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">      gLinkContext.bindFlat = true;</span><br><span class="line">      gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从 link 函数开始加载依赖动态库，在link方法中不光是链接我们的插入动态库,还会在函数内通过recursiveLoadLibraries函数循环加载我们的所有的依赖库.在加载后再Rebase每一个都添加上偏移值以得到真正的依赖库的地址也就是重定位。在链接定位后,还是在这个函数中继续对依赖库进行符号绑定,弱绑定等一系列操作,当这些都做完了主程序也就被加载链接完成。跟主程序加载链接一致,dyld当得知插入依赖库长度大于0会遍历加载链接这些库.链接完毕后就会将主程序与这些库绑定起来。</p>
<p>link</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link:dyld.cpp</span><br><span class="line">&#123;</span><br><span class="line">  ImageLoader::link:ImageLoader.cpp</span><br><span class="line">  &#123;</span><br><span class="line">    ImageLoader::recursiveLoadLibraries:ImageLoader.cpp</span><br><span class="line">    &#123;</span><br><span class="line">      ImageLoaderMachO::doGetDependentLibraries:ImageLoader.cpp</span><br><span class="line">      libraryLocator:dyld.cpp</span><br><span class="line">      &#123;</span><br><span class="line">        load:dyld.cpp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这些依赖库的操作全部完成,就会调用initializeMainExecutable函数来初始化我们的主程序!</p>
<p>接下来会调用loadImages函数</p>
<p>load_images调用了call_load_methods，函数内就是循环调用我们的Objc类的load方法。接下来dyld就会调用doModInitFunctions这个函数会调用执行我们程序的特殊函数,比如全局的C++的构造方法.其实实质上就是dyld会读取Mach-O里DATA段中的init_func这个字段进行调用里面的函数。</p>
<p>最终一系列的操作完毕后,dyld就会去查找我们主程序的入口,对应我们Mach-O的LC_MAIN.在找到后返回一个result结果,也就调起了我们主程序的main函数,结束掉dyld_start整个流程。</p>
<p>参考文献: </p>
<p>[1]<a href="https://amywushu.github.io/2017/02/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A7%A3%E8%AF%BB-Mach-O-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html">解读Mach-O文件格式</a></p>
<p>[2]<a href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/#">mach-o格式分析</a></p>
<p>[3]<a href="https://www.exchen.net/mach-o-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90.html#Mach_Header">Mach-O 文件格式解析</a></p>
<p>[4]<a href="https://juejin.im/post/5ab47ca1518825611a406a39">探秘 Mach-O 文件</a></p>
<p>[5]<a href="http://www.bubuko.com/infodetail-2243416.html">http://www.bubuko.com/infodetail-2243416.html</a></p>
<p>[6]<a href="https://www.jianshu.com/p/8498cec10a41">https://www.jianshu.com/p/8498cec10a41</a></p>
<p>[7]<a href="https://satanwoo.github.io/2017/06/13/Macho-1/">https://satanwoo.github.io/2017/06/13/Macho-1/</a></p>
<p>[8]<a href="https://jmpews.github.io/2017/02/27/darwin/PWN%E4%B9%8Bmacho%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">https://jmpews.github.io/2017/02/27/darwin/PWN%E4%B9%8Bmacho%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</a></p>
<p>[9]<a href="https://www.jianshu.com/p/7ad7b3ba7985">https://www.jianshu.com/p/7ad7b3ba7985</a></p>
<p>[10]<a href="https://www.jianshu.com/p/4d86de908721">https://www.jianshu.com/p/4d86de908721</a></p>
<p>[11]<a href="https://juejin.im/post/5c8e6f5c518825458b3ba6a4">https://juejin.im/post/5c8e6f5c518825458b3ba6a4</a>这个写的比较清楚</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Mach-O</tag>
        <tag>Mac OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next博客升级</title>
    <url>/2021/08/01/Hexo-Next%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>本懒懒一直使用<a href="https://hexo.io/zh-cn/">Hexo</a>框架 + <a href="https://theme-next.iissnan.com/">Next</a>主题来搭建博客。最近发现Hexo从4.x升级到了5.x，Next主题也更新了。想着博客好久没更了，抽空也来升级一下（差生文具多，没辙哦）</p>
<span id="more"></span>

<h1 id="升级Hexo"><a href="#升级Hexo" class="headerlink" title="升级Hexo"></a>升级Hexo</h1><p>使用npm升级Hexo，执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 全局升级 hexo-cli</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line"># 检查系统插件</span><br><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br><span class="line"></span><br><span class="line"># 升级系统中的插件</span><br><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line"># 更新全局包</span><br><span class="line">npm update -g</span><br><span class="line"></span><br><span class="line"># 更新生产环境依赖包</span><br><span class="line">npm update --save</span><br><span class="line"></span><br><span class="line"># 查看 Hexo 版本</span><br><span class="line">hexo v</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更新完之后，执行<code>hexo c &amp;&amp; hexo g &amp;&amp; hexo d</code>，并查看博客有无问题。</p>
<p>参考：<a href="https://www.cylong.com/blog/2020/08/10/update-hexo-next/">Hexo 博客和 NexT 主题版本升级</a></p>
<h1 id="更新Next"><a href="#更新Next" class="headerlink" title="更新Next"></a>更新Next</h1><p>NexT主仓库已从 iissnan 名下 迁移至 <a href="https://github.com/theme-next/hexo-theme-next">theme-next</a>组织，不过发现git上还有一个认证过的<a href="https://github.com/next-theme/hexo-theme-next">next-theme</a>，且最近有更新，所以就使用后者的仓库了。（其实是因为前者pull下来有问题）</p>
<p>克隆新仓库到hexo/theme中，命名需异于之前的next</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next  themes/next-reload</span><br></pre></td></tr></table></figure>
<p>这样可以保留之前的next版本，方便出问题的时候一键切换。</p>
<p>在hexo的_config.yml配置文件中将hexo主题设置为新主题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next-reloaded</span><br></pre></td></tr></table></figure>
<h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>站点配置文件路径：<code>hexo/_config.yml</code><br>主题文件配置路径：<code>hexo/themes/next_reload/_config.yml</code></p>
<h2 id="修改站点配置"><a href="#修改站点配置" class="headerlink" title="修改站点配置"></a>修改站点配置</h2><h3 id="站点描述"><a href="#站点描述" class="headerlink" title="站点描述"></a>站点描述</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: #网站标题</span><br><span class="line">subtitle: #副标题</span><br><span class="line">description: #描述</span><br><span class="line">keywords:</span><br><span class="line">author: #作者</span><br><span class="line">language: zh-CN #语言</span><br><span class="line">timezone: #时区</span><br></pre></td></tr></table></figure>

<h3 id="URL和deploy配置"><a href="#URL和deploy配置" class="headerlink" title="URL和deploy配置"></a>URL和deploy配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: http://xxx.github.io #网址</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="修改主题配置"><a href="#修改主题配置" class="headerlink" title="修改主题配置"></a>修改主题配置</h2><h3 id="设置主题模板"><a href="#设置主题模板" class="headerlink" title="设置主题模板"></a>设置主题模板</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse</span><br><span class="line">#scheme: Mist</span><br><span class="line">#scheme: Pisces</span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<h3 id="设置菜单栏"><a href="#设置菜单栏" class="headerlink" title="设置菜单栏"></a>设置菜单栏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="设置社交链接"><a href="#设置社交链接" class="headerlink" title="设置社交链接"></a>设置社交链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://yourname.com/8biiit || fab fa-github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  #Weibo: https://weibo.com/yourname || fab fa-weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || fab fa-google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="设置打赏"><a href="#设置打赏" class="headerlink" title="设置打赏"></a>设置打赏</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Donate (Sponsor) settings</span><br><span class="line"># Front-matter variable (unsupport animation).</span><br><span class="line">reward_settings:</span><br><span class="line">  # If true, a donate button will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: false</span><br><span class="line">  comment: 赞助博主</span><br><span class="line"></span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png #微信二维码</span><br><span class="line">  alipay: /images/alipay.png       #支付宝二维码</span><br><span class="line">  #paypal: /images/paypal.png</span><br><span class="line">  #bitcoin: /images/bitcoin.png</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="设置评论区gitalk"><a href="#设置评论区gitalk" class="headerlink" title="设置评论区gitalk"></a>设置评论区gitalk</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Multiple Comment System Support</span><br><span class="line">comments:</span><br><span class="line">  # Available values: tabs | buttons</span><br><span class="line">  style: tabs</span><br><span class="line">  # Choose a comment system to be displayed by default.</span><br><span class="line">  # Available values: disqus | disqusjs | changyan | livere | gitalk | utterances</span><br><span class="line">  active: gitalk</span><br><span class="line">  # Setting `true` means remembering the comment system selected by the visitor.</span><br><span class="line">  storage: true</span><br><span class="line">  # Lazyload all comment systems.</span><br><span class="line">  lazyload: false</span><br><span class="line">  # Modify texts or order for any navs, here are some examples.</span><br><span class="line">  nav:</span><br><span class="line">    #disqus:</span><br><span class="line">    #  text: Load Disqus</span><br><span class="line">    #  order: -1</span><br><span class="line">    gitalk:</span><br><span class="line">      order: -2</span><br><span class="line"></span><br><span class="line"># Gitalk</span><br><span class="line"># For more information: https://gitalk.github.io</span><br><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: name # GitHub repo owner</span><br><span class="line">  repo: name.github.io # Repository name to store issues</span><br><span class="line">  client_id: x # GitHub Application Client ID</span><br><span class="line">  client_secret: x # GitHub Application Client Secret</span><br><span class="line">  admin_user: name # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  # When the official proxy is not available, you can change it to your own proxy address</span><br><span class="line">  proxy: https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token # This is official proxy adress</span><br><span class="line">  # Gitalk&#x27;s display language depends on user&#x27;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language: zh-CN</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="访问计数"><a href="#访问计数" class="headerlink" title="访问计数"></a>访问计数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true  #开启</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>

<h3 id="许可协议"><a href="#许可协议" class="headerlink" title="许可协议"></a>许可协议</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Creative Commons 4.0 International License.</span><br><span class="line"># See: https://creativecommons.org/about/cclicenses/</span><br><span class="line">creative_commons:</span><br><span class="line">  # Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero</span><br><span class="line">  license: by-nc-sa</span><br><span class="line">  # Available values: big | small</span><br><span class="line">  size: small</span><br><span class="line">  sidebar: true</span><br><span class="line">  post: true</span><br><span class="line">  # You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span><br><span class="line">  # CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span><br><span class="line">  language:</span><br></pre></td></tr></table></figure>

<h1 id="文章设置"><a href="#文章设置" class="headerlink" title="文章设置"></a>文章设置</h1><h2 id="tag分类"><a href="#tag分类" class="headerlink" title="tag分类"></a>tag分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: 2021-01-01 00:00:00</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">categories: Hexo	</span><br><span class="line">---</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p><code>npm install hexo-image-link --save</code><br>（也有说法是hexo-asset-image）</p>
<p>方法一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_posts/post_name/image.jpg</span><br><span class="line">&#123;% asset_img image.jpg This is an image %&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/2021/08/01/Hexo-Next%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7/img.jpg" class title="This is an image">

<p>方法二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![This is an image](img.jpg)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/08/01/Hexo-Next%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7/img.jpg" alt="This is an image"></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg知识库</title>
    <url>/2021/07/01/FFmpeg/</url>
    <content><![CDATA[<p><a href="https://www.ffmpeg.org/">FFmpeg</a>是一个开源免费跨平台的视频和音频流方案，采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。<br>最近做解码相关，需要用到FFmpeg的api。有幸拜读<a href="https://blog.csdn.net/leixiaohua1020/category_9262578.html?spm=1001.2014.3001.5482">雷霄骅(leixiaohua1020)</a>的专栏，以下大部分内容是阅读专栏摘录内容加上自己的整理和总结。缅怀雷神</p>
<span id="more"></span>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="获取库版本"><a href="#获取库版本" class="headerlink" title="获取库版本"></a>获取库版本</h2><p>方法：<code>avcodec_version()</code>   <code>swscale_version()</code>   <code>avutil_version()</code>  <code>avformat_version()</code>  <code>swresample_version()</code></p>
<p>返回：十进制数字，如3835492</p>
<p>转换成版本号：3835492 -&gt;  0x3a8664  -&gt; 58  134  100 -&gt; 58.134.100</p>
<p>参考：<a href="https://m.yisu.com/zixun/69213.html">版本转换方法</a>、<a href="https://blog.csdn.net/seniorwizard/article/details/94725567">FFMPEG版本对应的库版本</a>、<a href="http://ffmpeg.org/doxygen/trunk/group__version__utils.html#gaaab323b60e1a6e38ec939efe881474c7">Library Version Macros</a></p>
<h2 id="注册：av-register-all"><a href="#注册：av-register-all" class="headerlink" title="注册：av_register_all"></a>注册：av_register_all</h2><p>注册所有的编解码器、复用/解复用组件等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">av_register_all</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg和reval 均为void</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：FFmpeg4.0 以上的版本，这个函数已经被废弃。</p>
</blockquote>
<h2 id="打开文件：avformat-open-input"><a href="#打开文件：avformat-open-input" class="headerlink" title="打开文件：avformat_open_input"></a>打开文件：avformat_open_input</h2><p>打开多媒体数据并且根据header获得一些相关的信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">avformat_open_input</span>(&amp;pFormatCtx, filepath, fmt, options);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1: AVFormatContext结构体</span></span><br><span class="line"><span class="comment">//arg2: 打开的文件名或视音频流的URL</span></span><br><span class="line"><span class="comment">//arg3: 强制指定AVFormatContext中AVInputFormat。默认为NULL，自动检测AVInputFormat</span></span><br><span class="line"><span class="comment">//agr4: 附加选项，默认为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reval: 成功返回0，错误返回负值AVERROR</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需以 avformat_close_input() 方法结束</p>
</blockquote>
<h2 id="查找码流：avformat-find-stream-info"><a href="#查找码流：avformat-find-stream-info" class="headerlink" title="查找码流：avformat_find_stream_info"></a>查找码流：avformat_find_stream_info</h2><p>读取媒体文件的packets以获取stream信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">avformat_find_stream_info</span>(pFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1: 输入的AVFormatContext</span></span><br><span class="line"><span class="comment">//arg2: 附加选项，默认为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reval: 成功返回&gt;=0，错误返回负值AVERROR</span></span><br></pre></td></tr></table></figure>

<h2 id="查找解码器：avcodec-find-decoder"><a href="#查找解码器：avcodec-find-decoder" class="headerlink" title="查找解码器：avcodec_find_decoder"></a>查找解码器：avcodec_find_decoder</h2><p>查找编码器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AVCodec *pCodec = <span class="built_in">avcodec_find_decoder</span>(codec_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1: 解码器的ID,可以通过pCodecCtx-&gt;codec_id 访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reval: 查找到的解码器（没有找到就返回NULL）</span></span><br></pre></td></tr></table></figure>

<h2 id="打开解码器：avcodec-open2"><a href="#打开解码器：avcodec-open2" class="headerlink" title="打开解码器：avcodec_open2"></a>打开解码器：avcodec_open2</h2><p>使用给定的编解码器初始化一个视音频编解码器的AVCodecContext</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">avcodec_open2</span>(pCodecCtx, pCodec, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1: 需要初始化的AVCodecContext</span></span><br><span class="line"><span class="comment">//arg2: 输入的AVCodec</span></span><br><span class="line"><span class="comment">//arg3: 附加选项，默认为NULL。例如使用libx264编码的时候，“preset”，“tune”等都可以通过该参数设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reval: 成功返回0，错误返回负值ERROR</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="读取：av-read-frame"><a href="#读取：av-read-frame" class="headerlink" title="读取：av_read_frame"></a>读取：av_read_frame</h2><p>读取码流中的若干帧音频或者一帧视频</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">av_read_frame</span>(pFormatCtx, packet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1: 输入的AVFormatContext</span></span><br><span class="line"><span class="comment">//arg2: 输出的AVPacket</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reval: 成功返回0，负值代表ERROR或文件末尾</span></span><br></pre></td></tr></table></figure>

<h2 id="解码：avcodec-decode-video2"><a href="#解码：avcodec-decode-video2" class="headerlink" title="解码：avcodec_decode_video2"></a>解码：avcodec_decode_video2</h2><p>从AVPacket解码一帧视频数据到AVPFrame</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">avcodec_decode_video2</span>(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1: 输入的AVFormatContext</span></span><br><span class="line"><span class="comment">//arg2: 输出的AVPFrame</span></span><br><span class="line"><span class="comment">//arg3: 不能解码返回0，否则非0</span></span><br><span class="line"><span class="comment">//arg4: 输入的AVPacket</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//reval: 成功返回0或使用的byte数，负值代表ERROR</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="缩放：sws-scale"><a href="#缩放：sws-scale" class="headerlink" title="缩放：sws_scale"></a>缩放：sws_scale</h2><p>将源图片进行缩放，存入目标图片</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">sws_scale</span>(img_convert_ctx, (<span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span>*)pFrame-&gt;data, pFrame-&gt;linesize, <span class="number">0</span>, pCodecCtx-&gt;height, </span><br><span class="line">                            pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1: 通过sws_getContext()方法获得的context</span></span><br><span class="line"><span class="comment">//arg2: src的buffer</span></span><br><span class="line"><span class="comment">//arg3: src的stride</span></span><br><span class="line"><span class="comment">//arg4: 要处理的位置，默认为0，从头处理</span></span><br><span class="line"><span class="comment">//arg5: source slice 的高度</span></span><br><span class="line"><span class="comment">//arg6: dst的buffer</span></span><br><span class="line"><span class="comment">//arg7: dst的stride</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reval: 成功返回0或使用的byte数，负值代表ERROR</span></span><br></pre></td></tr></table></figure>
<p>使用时，调用sws_getContext() 开始，调用sws_freeContext() 結束。</p>
<h2 id="查找并跳转：av-seek-frame"><a href="#查找并跳转：av-seek-frame" class="headerlink" title="查找并跳转：av_seek_frame"></a>查找并跳转：av_seek_frame</h2><p>视频跳转到指定时间戳</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> res = <span class="built_in">av_seek_frame</span>(pFormatCtx,videoindex,pos,AVSEEK_FLAG_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">//arg1: 输入的AVFormatContext</span></span><br><span class="line"><span class="comment">//arg2: 流的index，若为-1，则使用默认流</span></span><br><span class="line"><span class="comment">//arg3: 时间戳</span></span><br><span class="line"><span class="comment">//arg4: 方向和seek模式的flag，可能同时包含以上的多个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//flag值：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSEEK_FLAG_BACKWARD 1 <span class="comment">///&lt; seek backward</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSEEK_FLAG_BYTE     2 <span class="comment">///&lt; seeking based on position in bytes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSEEK_FLAG_ANY      4 <span class="comment">///&lt; seek to any frame, even non-keyframes</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AVSEEK_FLAG_FRAME    8 <span class="comment">///&lt; seeking based on frame number</span></span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//reval: 成功返回&gt;=0</span></span><br></pre></td></tr></table></figure>

<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>FFmpeg 中结构体很多。最关键的结构体可以分成以下几类：</p>
<ol>
<li><p>解协议（http, rtsp, rtmp, mms）<br>AVIOContext，URLProtocol，URLContext 主要存储音视频使用的协议的类型以及状态。URLProtocol 存储输入音视频使用的封装格式。每种协议都对应一个 URLProtocol 结构。（注意：FFmpeg 中文件也被当做一种协议 “file”）</p>
</li>
<li><p>解封装（flv, avi, rmvb, mp4）<br>AVFormatContext 主要存储音视频封装格式中包含的信息；AVInputFormat 存储输入音视频使用的封装格式。每种音视频封装格式都对应一个 AVInputFormat 结构。</p>
</li>
<li><p>解码（h264, mpeg2, aac, mp3）<br>每个 AVStream 存储一个视频/音频流的相关数据；每个 AVStream 对应一个 AVCodecContext，存储该视频/音频流使用解码方式的相关数据；每个 AVCodecContext 中对应一个 AVCodec，包含该视频/音频对应的解码器。每种解码器都对应一个 AVCodec 结构。</p>
</li>
<li><p>存数据<br>视频的话，每个结构一般是存一帧；音频可能有好几帧。解码前数据：AVPacket；解码后数据：AVFrame。</p>
</li>
</ol>
<h2 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h2><p>AVFormatContext 是存储音视频封装格式中包含的信息的结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AVIOContext *pb：输入数据的缓存</span><br><span class="line"></span><br><span class="line">unsigned int nb_streams：视音频流的个数</span><br><span class="line"></span><br><span class="line">AVStream **streams：视音频流</span><br><span class="line"></span><br><span class="line">char filename[1024]：文件名</span><br><span class="line"></span><br><span class="line">int64_t duration：时长（单位：微秒us，转换为秒需要除以1000000）</span><br><span class="line"></span><br><span class="line">int bit_rate：比特率（单位bps，转换为kbps需要除以1000）</span><br><span class="line"></span><br><span class="line">AVDictionary *metadata：元数据</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h2><p>AVFrame 结构体一般用于存储原始数据（即非压缩数据，例如对视频来说是 YUV，RGB，对音频来说是 PCM），此外还包含了一些相关的信息。比如说，解码的时候存储了宏块类型表，QP 表，运动矢量表等数据。编码的时候也存储了相关的数据。因此在使用 FFmpeg 进行码流分析的时候，AVFrame 是一个很重要的结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int8_t *data[AV_NUM_DATA_POINTERS]：解码后原始数据（对视频来说是YUV，RGB，对音频来说是PCM）</span><br><span class="line"></span><br><span class="line">int linesize[AV_NUM_DATA_POINTERS]：data中“一行”数据的大小。注意：未必等于图像的宽，一般大于图像的宽。</span><br><span class="line"></span><br><span class="line">int width, height：视频帧宽和高（1920x1080,1280x720...）</span><br><span class="line"></span><br><span class="line">int format：解码后原始数据类型（YUV420，YUV422，RGB24...）</span><br><span class="line"></span><br><span class="line">int key_frame：是否是关键帧</span><br><span class="line"></span><br><span class="line">enum AVPictureType pict_type：帧类型（I,B,P...）</span><br><span class="line"></span><br><span class="line">AVRational sample_aspect_ratio：宽高比（16:9，4:3...）</span><br><span class="line"></span><br><span class="line">int64_t pts：显示时间戳</span><br><span class="line"></span><br><span class="line">int coded_picture_number：编码帧序号</span><br><span class="line"></span><br><span class="line">int display_picture_number：显示帧序号</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h2><p>AVCodecContext 是一个描述编解码器上下文的结构体，包含了众多编解码器需要的参数信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum AVMediaType codec_type：编解码器的类型（视频，音频...）</span><br><span class="line"></span><br><span class="line">struct AVCodec  *codec：采用的解码器AVCodec（H.264,MPEG2...）</span><br><span class="line"></span><br><span class="line">int bit_rate：平均比特率</span><br><span class="line"></span><br><span class="line">uint8_t *extradata; int extradata_size：针对特定编码器包含的附加信息（例如对于H.264解码器来说，存储SPS，PPS等）</span><br><span class="line"></span><br><span class="line">AVRational time_base：根据该参数，可以把PTS转化为实际的时间（单位为秒s）</span><br><span class="line"></span><br><span class="line">int width, height：如果是视频的话，代表宽和高</span><br><span class="line"></span><br><span class="line">int refs：运动估计参考帧的个数（H.264的话会有多帧，MPEG2这类的一般就没有了）</span><br><span class="line"></span><br><span class="line">int sample_rate：采样率（音频）</span><br><span class="line"></span><br><span class="line">int channels：声道数（音频）</span><br><span class="line"></span><br><span class="line">enum AVSampleFormat sample_fmt：采样格式</span><br><span class="line"></span><br><span class="line">int profile：型（H.264里面就有，其他编码标准应该也有）</span><br><span class="line"></span><br><span class="line">int level：级（和profile差不太多）</span><br><span class="line"></span><br><span class="line">int has_b_frames：有无b帧，对于mpeg来说若为0：IP；若为1：IPB</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h2><p>AVCodec 是存储编码器信息的结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char *name：编解码器的名字，比较短</span><br><span class="line"></span><br><span class="line">const char *long_name：编解码器的名字，全称，比较长</span><br><span class="line"></span><br><span class="line">enum AVMediaType type：指明了类型，是视频，音频，还是字幕</span><br><span class="line"></span><br><span class="line">enum AVCodecID id：ID，不重复</span><br><span class="line"></span><br><span class="line">const AVRational *supported_framerates：支持的帧率（仅视频）</span><br><span class="line"></span><br><span class="line">const enum AVPixelFormat *pix_fmts：支持的像素格式（仅视频）</span><br><span class="line"></span><br><span class="line">const int *supported_samplerates：支持的采样率（仅音频）</span><br><span class="line"></span><br><span class="line">const enum AVSampleFormat *sample_fmts：支持的采样格式（仅音频）</span><br><span class="line"></span><br><span class="line">const uint64_t *channel_layouts：支持的声道数（仅音频）</span><br><span class="line"></span><br><span class="line">int priv_data_size：私有数据的大小</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h2><p>AVStream是存储每一个视频/音频流信息的结构体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int index：标识该视频/音频流</span><br><span class="line"></span><br><span class="line">AVCodecContext *codec：指向该视频/音频流的AVCodecContext（它们是一一对应的关系）</span><br><span class="line"></span><br><span class="line">AVRational time_base：时基。通过该值可以把PTS，DTS转化为真正的时间。FFMPEG其他结构体中也有这个字段，但是根据我的经验，只有AVStream中的time_base是可用的。PTS*time_base=真正的时间</span><br><span class="line"></span><br><span class="line">int64_t duration：该视频/音频流长度</span><br><span class="line"></span><br><span class="line">AVDictionary *metadata：元数据信息</span><br><span class="line"></span><br><span class="line">AVRational avg_frame_rate：帧率（注：对视频来说，这个挺重要的）</span><br><span class="line"></span><br><span class="line">AVPacket attached_pic：附带的图片。比如说一些MP3，AAC音频文件附带的专辑封面。</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h2><p>AVPacket是存储压缩编码数据相关信息的结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uint8_t *data：压缩编码的数据。</span><br><span class="line"></span><br><span class="line">int   size：data的大小</span><br><span class="line"></span><br><span class="line">int64_t pts：显示时间戳</span><br><span class="line"></span><br><span class="line">int64_t dts：解码时间戳</span><br><span class="line"></span><br><span class="line">int   stream_index：标识该AVPacket所属的视频/音频流。</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h2><p>AVIOContext 是 FFmpeg 管理输入输出数据的结构体。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unsigned char *buffer; // 缓存开始位置</span><br><span class="line"></span><br><span class="line">int buffer_size; // 缓存大小（默认32768）</span><br><span class="line"></span><br><span class="line">unsigned char *buf_ptr; // 当前指针读取到的位置</span><br><span class="line"></span><br><span class="line">unsigned char *buf_end; // 缓存结束的位置</span><br><span class="line"></span><br><span class="line">void *opaque; // URLContext结构体</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="编解码器常用命令"><a href="#编解码器常用命令" class="headerlink" title="编解码器常用命令"></a>编解码器常用命令</h1><p>FFmpeg 的命令行参数可以分成五个部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ffmpeg &#123;1&#125; &#123;2&#125; -i &#123;3&#125; &#123;4&#125; &#123;5&#125;</span><br></pre></td></tr></table></figure>

<p>分别是：全局参数、输入文件参数、输入文件、输出文件参数、输出文件</p>
<h2 id="控制b帧"><a href="#控制b帧" class="headerlink" title="控制b帧"></a>控制b帧</h2><p>（仅针对x264解码器）</p>
<p>去除b帧</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i test.mp4 -vcodec libx264 -bf 0 out.mp4</span><br><span class="line">ffmpeg -i test.mp4 -vcodec libx264 -x264opts &quot;bframes=0&quot; out.mp4</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://sites.google.com/site/linuxencoding/x264-ffmpeg-mapping">ffmpeg x264 选项指南</a></p>
<p>如果希望控制I帧P帧B帧的频率和规律，可以通过控制GOP中B帧的帧数来实现，P帧的频率可以通过x264的参数b-adapt进行设置。<br>利用sc_threshold解决场景切换会强制插入GOP问题。<br>例如设置GOP中，每2个P帧之间存放3个B帧：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.mp4 -c:v libx264 -x264opts &quot;bframes=3:b-adapt=0&quot; -g 50 -sc_threshold 0  output.mp4</span><br></pre></td></tr></table></figure>

<h2 id="缩放视频"><a href="#缩放视频" class="headerlink" title="缩放视频"></a>缩放视频</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">普通缩放</span></span><br><span class="line">ffmpeg -s 720x1280 -pix_fmt yuv420p -i out.yuv -vcodec libx264 output.mp4</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">设置纵横比</span></span><br><span class="line">ffmpeg -i input.mov -vf scale=720x406,setdar=16:9 output.mp4</span><br></pre></td></tr></table></figure>

<h2 id="显示媒体流信息"><a href="#显示媒体流信息" class="headerlink" title="显示媒体流信息"></a>显示媒体流信息</h2><p>ffprobe 是ffmpeg的一个工具包，主要用于探测音视频文件的各种信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看基本信息</span></span><br><span class="line">ffprobe test.mp4</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看封装格式</span></span><br><span class="line">ffprobe -show_format test.mp4</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">以XML格式显示媒体流信息（选择视频流）</span></span><br><span class="line">ffprobe -show_frames -select_streams v -of xml test.mp4</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看视频流的数据包信息 video视频，audio音频，s字幕</span></span><br><span class="line">ffprobe -show_packets -select_streams video test.mp4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Codec</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>media</tag>
        <tag>Codec</tag>
      </tags>
  </entry>
  <entry>
    <title>某MMO游戏脚本逆向(一)——脱壳</title>
    <url>/2021/08/23/%E6%9F%90MMO%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E9%80%86%E5%90%911/</url>
    <content><![CDATA[<p>国内外手游，尤其是MMORPG品类的游戏，经常有一些刷刷刷的日常任务，这也催生了大量游戏辅助脚本。这些脚本一般完成一些简单的pve战斗，或不需要太多机制的pvp玩法。本次将对一个主流手游的脚本进行逆向，观察下脚本的运行逻辑。</p>
<span id="more"></span>

<h1 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h1><p>首先用ida打开文件，会报错:</p>
<table><tr><td bgcolor="#fff5f6">The imports segment seems to be destroyed. This MAY mean that the file was packed or otherwise modified in order to make it more difficult to analyze. If you want to see the imports segment in the original form, please reload it with the 'make imports section' checkbox cleared.</td></tr></table>



<p><img src="/2021/08/23/%E6%9F%90MMO%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E9%80%86%E5%90%911/ida.png" alt="ida"></p>
<p>这个提示出现意味着文件被加壳了，需要进行脱壳处理。</p>
<p>用ExEinfoPE打开得到的文件，可以看到已经脱壳成功打开，可以看到使用的是Themida壳，<code>Themida &amp; WinLicense 2.0 - 2.4.6 - struct (Hide from PE scanners II-V)</code><br><img src="/2021/08/23/%E6%9F%90MMO%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E9%80%86%E5%90%911/exeinfo.png" alt="ExEinfoPE"></p>
<h1 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h1><p>脱壳方法参考<a href="https://zenhax.com/viewtopic.php?f=4&t=1051">某大神做法</a></p>
<p>脱壳需要以下工具：</p>
<ul>
<li>原版 Ollydbg</li>
</ul>
<p>插件:</p>
<ul>
<li>ODBGScript v1.82.6</li>
<li>StrongOD 0.4.8.892</li>
<li>PhanOm 1.79</li>
<li>ARImpRec.dll</li>
</ul>
<p>脱壳脚本:</p>
<ul>
<li>(Themida - Winlicense Ultra Unpacker 1.4)</li>
</ul>
<p>接下来开始按步骤操作：</p>
<ol>
<li><p>设置ARImpRec.dll路径<br>打开<code>Themida - Winlicense Ultra Unpacker 1.4.txt</code>，搜索<code>HERE_ENTER_YOUR_DLL_PATH_TO_ARIMPREC_DLL</code>并将下方代码修改为自己的ARImpRec.dll文件的绝对路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HERE_ENTER_YOUR_DLL_PATH_TO_ARIMPREC_DLL:</span><br><span class="line">mov ARIMPREC_PATH, &quot;C:\xxx\ARImpRec.dll&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>下载并设置打开Ollydbg<br>将 ollydbg 解压缩到目标路径。<br>在 ollydbg 文件夹中创建一个名为 plugin 的文件夹，并将所有插件放入该文件夹<br>从 OllyDBG 的主文件夹中删除 PSAPI.DLL<br>第一次打开Olly需要设置插件目录，菜单进入 Option -&gt; Appareance，在选项卡中设置存储插件的位置，点击确定然后重启<br>打开目标文件，会弹出一个窗口，按是，文件继续分析，等待完成<br>按F9运行，有一个弹出窗口，按确定即可终止调试</p>
</li>
<li><p>运行脚本<br>通过plugin menu-ODBGScript-Run Script，选择<code>Themida - Winlicense Ultra Unpacker 1.4.txt</code><br>重新打开目标后再次运行脚本，若弹出要求开始解包过程，选YES<br>下一个选No<br>在运行几秒后，脚本暂停，继续运行脚本即可</p>
</li>
<li><p>修改ollydbg.ini<br>随后获得弹窗，提示需要在OllyDBG.ini文件中，根据提示修改文件，并重新运行脚本</p>
</li>
<li><p>重新运行脚本<br>重复之前的步骤，打开目标并运行脚本等，完成后我们得到了最后的结果。</p>
</li>
</ol>
<p>再次使用ExEinfoPE打开得到的文件，可以看到已经脱壳成功</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>PE</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub二次验证导致博客代码无法提交</title>
    <url>/2021/08/23/GitHub%E4%BA%8C%E6%AC%A1%E9%AA%8C%E8%AF%81%E5%AF%BC%E8%87%B4%E5%8D%9A%E5%AE%A2%E6%97%A0%E6%B3%95%E6%8F%90%E4%BA%A4/</url>
    <content><![CDATA[<p>GitHub开启二次验证后会导致博客代码提交的时候提示错误，无法提交至GitHub。原因是根据<a href="https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/">官方博客</a>密码验证于2021年8月13日不再支持，需使用 personal access token 替代。</p>
<span id="more"></span>

<p>具体提示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br><span class="line">remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information.</span><br><span class="line">fatal: Authentication failed for &#x27;https://github.com/xxx/xxx.github.io.git/&#x27;</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<p><strong>1. 关闭二次验证</strong></p>
<blockquote>
<p>[warning]<br>不建议使用该方法，会降低安全性</p>
</blockquote>
<ul>
<li>登录github.com</li>
<li>进入Settings -&gt; Security</li>
<li>在 Two-factor authentication 栏下点击Edit</li>
<li>点击 Disable two-factor authentication</li>
</ul>
<blockquote>
<p>[info]<br>关闭二次验证后，hexo部署提交时使用的密码即为GitHub的用户密码。</p>
</blockquote>
<p><strong>2.生成令牌码，作为密码登录</strong> </p>
<ul>
<li>登录github.com</li>
<li>进入Settings -&gt; Personal access tokens -&gt; Generate new token</li>
<li>为令牌添加备注</li>
<li>勾选该令牌权限</li>
<li>保存</li>
</ul>
<blockquote>
<p>[info]<br>生成令牌码后，hexo部署提交时使用的密码即为该令牌码。</p>
</blockquote>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
