<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/header.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/header.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/header.jpg">
  <link rel="mask-icon" href="/images/header.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"8biiit.github.io","root":"/","images":"/images","scheme":"Gemini","version":"8.6.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Mach-O是什么Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。类似于windows上的PE文件以及linux上的ELF文件。作为 a.out 格式的替代品，Mach-O提供更多的可扩展性和更快的符号表信息存取。大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="Mach-O文件详解">
<meta property="og:url" content="http://8biiit.github.io/2019/08/09/Mach-O%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="8Biiit&#39;s Blog">
<meta property="og:description" content="Mach-O是什么Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。类似于windows上的PE文件以及linux上的ELF文件。作为 a.out 格式的替代品，Mach-O提供更多的可扩展性和更快的符号表信息存取。大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-08-09T07:47:44.000Z">
<meta property="article:modified_time" content="2019-08-09T08:32:00.000Z">
<meta property="article:author" content="8Biiit">
<meta property="article:tag" content="iOS">
<meta property="article:tag" content="Mach-O">
<meta property="article:tag" content="Mac OS">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://8biiit.github.io/2019/08/09/Mach-O%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://8biiit.github.io/2019/08/09/Mach-O%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/","path":"2019/08/09/Mach-O文件详解/","title":"Mach-O文件详解"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Mach-O文件详解 | 8Biiit's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">8Biiit's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">写点有用的</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Mach-O%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">1.</span> <span class="nav-text">Mach-O是什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%96%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">胖二进制文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%92%8C%E7%98%A6%E8%BA%AB"><span class="nav-number">2.1.</span> <span class="nav-text">合并和瘦身</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mach-O%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">Mach-O结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Header"><span class="nav-number">3.1.</span> <span class="nav-text">Header</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Segment-amp-Section"><span class="nav-number">3.2.</span> <span class="nav-text">Segment &amp; Section</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TEXT"><span class="nav-number">3.3.</span> <span class="nav-text">TEXT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol-Table-amp-String-Table"><span class="nav-number">3.4.</span> <span class="nav-text">Symbol Table &amp; String Table</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mach-O%E6%89%A7%E8%A1%8C"><span class="nav-number">4.</span> <span class="nav-text">Mach-O执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">4.1.</span> <span class="nav-text">内核处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">二进制文件加载过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BDdyld%E8%BF%87%E7%A8%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">加载dyld过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dyld%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">dyld处理流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text">处理环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90macho%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6"><span class="nav-number">4.2.2.</span> <span class="nav-text">解析macho执行文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%85%B1%E4%BA%AB%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">4.2.3.</span> <span class="nav-text">加载共享动态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BDDYLD-INSERT-LIBRARIES%E7%9A%84%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">4.2.4.</span> <span class="nav-text">加载DYLD_INSERT_LIBRARIES的动态库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%BE%9D%E8%B5%96%E5%8A%A8%E6%80%81%E5%BA%93"><span class="nav-number">4.2.5.</span> <span class="nav-text">加载依赖动态库</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="8Biiit"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">8Biiit</p>
  <div class="site-description" itemprop="description">奇跡ってのは、タダじゃないんだ</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/8biiit" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;8biiit" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://8biiit.github.io/2019/08/09/Mach-O%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="8Biiit">
      <meta itemprop="description" content="奇跡ってのは、タダじゃないんだ">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="8Biiit's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Mach-O文件详解
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-08-09 15:47:44 / 修改时间：16:32:00" itemprop="dateCreated datePublished" datetime="2019-08-09T15:47:44+08:00">2019-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="Mach-O是什么"><a href="#Mach-O是什么" class="headerlink" title="Mach-O是什么"></a>Mach-O是什么</h1><p>Mach-O 是 Mach object 文件格式的缩写，它是一种用于记录可执行文件、对象代码、共享库、动态加载代码和内存转储的文件格式。类似于windows上的PE文件以及linux上的ELF文件。作为 a.out 格式的替代品，Mach-O提供更多的可扩展性和更快的符号表信息存取。大多数基于 Mach 内核的操作系统都使用 Mach-O。NeXTSTEP、OS X 和 iOS 是使用这种格式作为本地可执行文件、库和对象代码的例子。</p>
<span id="more"></span>

<p>Mach-O文件包含固定大小的头部(Header),几个可变大小的加载命令(LoadCommands)，一个或多个代码段(Segment)，每个代码段可以包含一个或多个代码区(Section)。</p>
<h1 id="胖二进制文件"><a href="#胖二进制文件" class="headerlink" title="胖二进制文件"></a>胖二进制文件</h1><p>为了使文件能运行在多个平台，出现了胖二进制文件(Fat Binary)，又叫通用二进制文件(Universal Binary)。使用lipo命令可以列出胖文件中的体系结构类型。胖二进制文件实际上是一个包装器(Wrapper)，一种将用于多种体系结构的Mach-O文件连接起来的简单存档。</p>
<p>胖二进制文件由胖头部(Fat Header)以及后面的 Mach-O 文件组成。胖头部包含一个幻数，后接一个整数值，表示二进制文件驻留在胖文件中的体系结构数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define FAT_MAGIC  0xcafebabe</span><br><span class="line">#define FAT_CIGAM  0xbebafeca  /* NXSwapLong(FAT_MAGIC) */</span><br><span class="line"> </span><br><span class="line">struct fat_header &#123;</span><br><span class="line">    uint32_t    magic;      /* FAT_MAGIC                        标记，表示是Fat的文件类型，是固定的0xcafebabe或者是0xbebafeca  */</span><br><span class="line">    uint32_t    nfat_arch;  /* number of structs that follow    包含了多个少Mach-O文件        */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再后面是一系列胖体系结构指示符(fat_arch)，每个指示符用于胖文件中包含的一种体系结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct fat_arch &#123;</span><br><span class="line">    cpu_type_t  cputype;    /* cpu specifier (int)              支持的CPU类型，一般有ARMV7，ARM64，X86，X86_64这几种类型  */</span><br><span class="line">    cpu_subtype_t   cpusubtype; /* machine specifier (int)      子CPU类型*/</span><br><span class="line">    uint32_t    offset;     /* file offset to this object file  当前架构的 Mach-O 文件的数据相对于文件开头的偏移位置 */</span><br><span class="line">    uint32_t    size;       /* size of this object file         数据的大小*/</span><br><span class="line">    uint32_t    align;      /* alignment as a power of 2        数据的内存对齐边界 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>offset 在armv7中是16384(0x4000)，arm64中是4294967296 （0x10000 0000）</p>
<p>注意：尽管胖文件中的Mach-O文件遵循其所在体系结构的字节序，但fat_header和fat_arch总是大端字节储存。 MacOS是小端序的。</p>
<h2 id="合并和瘦身"><a href="#合并和瘦身" class="headerlink" title="合并和瘦身"></a>合并和瘦身</h2><p>Xcode 在编译 iOS 程序可以选择同时支持 ARMV7 和 ARM64，编译 macOS 程序也可以选择同时支持 x86 和 x86_64，但是如果一个程序需要同时支持 iOS 和 macOS 的时候，Xcode 不能自动生成，可以使用 lipo 命令手动对文件进行合并。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$lipo -create test_iPhone test_macOS -output test_all</span><br></pre></td></tr></table></figure>

<p>由于每个 CPU 平台都是单独的一个 Mach-O 文件，然后合成的 Fat 文件，所以体积会变大，比如某个程序我们只需要支持 ARM64，就可以把其他平台给移除掉，这样就能起到 “瘦身” 的作用，使用 lipo 命令移除其他平台。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$lipo -thin arm64 ~/debugserver -output ~/debugserver</span><br></pre></td></tr></table></figure>

<h1 id="Mach-O结构"><a href="#Mach-O结构" class="headerlink" title="Mach-O结构"></a>Mach-O结构</h1><p>Mach-O 没有类似于 XML、YAML、JSON 等诸如此类的特殊格式，它只是一个二进制字节流，被划分为了有意义的数据块。这些块包含元信息，比如，字节顺序、cpu 类型、块的大小，等等。</p>
<p>典型的 Mach-O 文件包含三个区域：</p>
<ul>
<li>Header-包含该二进制文件的一般信息：字节顺序、（魔数）、cpu 类型、LoadCommands的数量等等。</li>
<li>LoadCommands -它是一张包含很多内容的表，内容包括区域的位置、符号表、动态符号表等。每个加载指令都包含一个元信息，比如指令类型、名称、在二进制文件中的位置等等。加载Mach-O文件时会使用这里的数据来确定内存的分布</li>
<li>Data-通常是对象文件中最大的部分。每一个segment的具体数据都保存在这里。主要包含代码、数据，例如符号表，动态符号表等等。</li>
</ul>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>Headers的主要作用就是帮助系统迅速的定位Mach-O文件的运行环境，以下是mach_header与mach_header_64的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The 32-bit mach header appears at the very beginning of the object file for</span><br><span class="line"> * 32-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header &#123;</span><br><span class="line">  uint32_t  magic;    /* mach magic number identifier    和 fat_hader 里的 magic 类似，也是一个标记，32 位的值是 MH_MAGIC，64位的值是 MH_CIGAM_64。 */</span><br><span class="line">  cpu_type_t  cputype;  /* cpu specifier                 与 fat_arch 里的 cputype 的含义一样。*/</span><br><span class="line">  cpu_subtype_t cpusubtype; /* machine specifier         与 fat_arch 里的 cpusubtype 的含义一样*/</span><br><span class="line">  uint32_t  filetype; /* type of file                    可执行文件就是 MH_EXECUTE，如果是动态库就是 MH_DYLIB  */</span><br><span class="line">  uint32_t  ncmds;    /* number of load commands         表示 Mach-O 文件中 load command (加载命令)的个数  */</span><br><span class="line">  uint32_t  sizeofcmds; /* the size of all the load commands   表示load command (加载命令) 占用的字节总大小  */</span><br><span class="line">  uint32_t  flags;    /* flags                                 表示dyld加载时文件的标志信息*/</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/* Constant for the magic field of the mach_header (32-bit architectures) */</span><br><span class="line">#define MH_MAGIC  0xfeedface  /* the mach magic number */</span><br><span class="line">#define MH_CIGAM  0xcefaedfe  /* NXSwapInt(MH_MAGIC) */</span><br><span class="line">​</span><br><span class="line">/*</span><br><span class="line"> * The 64-bit mach header appears at the very beginning of object files for</span><br><span class="line"> * 64-bit architectures.</span><br><span class="line"> */</span><br><span class="line">struct mach_header_64 &#123;</span><br><span class="line">  uint32_t  magic;    /* mach magic number identifier */</span><br><span class="line">  cpu_type_t  cputype;  /* cpu specifier */</span><br><span class="line">  cpu_subtype_t cpusubtype; /* machine specifier */</span><br><span class="line">  uint32_t  filetype; /* type of file */</span><br><span class="line">  uint32_t  ncmds;    /* number of load commands */</span><br><span class="line">  uint32_t  sizeofcmds; /* the size of all the load commands */</span><br><span class="line">  uint32_t  flags;    /* flags */</span><br><span class="line">  uint32_t  reserved; /* reserved                                  系统保留字段  */</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">/* Constant for the magic field of the mach_header_64 (64-bit architectures) */</span><br><span class="line">#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */</span><br><span class="line">#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */</span><br></pre></td></tr></table></figure>

<p>Mach-O文件不仅仅用来实现可执行文件，同时还用来实现了其他内容。</p>
<p>filetype:<br>​```<br>#define MH_OBJECT 0x1   /* relocatable object file               一个中间的，可重定位的目标文件，也可用于内核扩展(传统具有.o后缀)<em>/<br>#define MH_EXECUTE  0x2   /</em> demand paged executable file        一个标准的按需分页的可执行文件*/<br>#define MH_FVMLIB 0x3   /* fixed VM shared library file          CoreDump <em>/<br>#define MH_CORE   0x4   /</em> core file                             用于存储中止程序的地址空间的文件，包含”核心转储“的核心文件(core file)<em>/<br>#define MH_PRELOAD  0x5   /</em> preloaded executable file <em>/<br>#define MH_DYLIB  0x6   /</em> dynamically bound shared library      一个动态共享库*/<br>#define MH_DYLINKER 0x7   /* dynamic link editor                 一个特殊共享库，是一个动态链接器 <em>/<br>#define MH_BUNDLE 0x8   /</em> dynamically bound bundle file         在运行时以编程方式加载进应用程序中的插件代码*/<br>#define MH_DYLIB_STUB 0x9   /* shared library stub for static <em>/<br>          /</em>  linking only, no section contents <em>/<br>#define MH_DSYM   0xa   /</em> companion file with only debug <em>/<br>          /</em>  sections <em>/<br>#define MH_KEXT_BUNDLE  0xb   /</em> x86_64 kexts                     内核扩展文件*/</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Mach-O headers还包含了一些很重要的dyld的加载参数</span><br><span class="line"></span><br><span class="line">flags:</span><br></pre></td></tr></table></figure>
<p>/* Constants for the flags field of the mach_header <em>/<br>#define    MH_NOUNDEFS 0x1     /</em> the object file has no undefinedreferences    目标文件没有未定义的符号，不存在链接依赖*/<br>#define    MH_INCRLINK 0x2     /* the object file is the output of an<br>                       incremental link against a base file<br>                       and can’t be link edited again <em>/<br>#define MH_DYLDLINK    0x4     /</em> the object file is input for the              目标文件是动态链接输入文件，不能被再次静态链接<br>                       dynamic linker and can’t be staticly<br>                       link edited again <em>/<br>#define MH_BINDATLOAD  0x8     /</em> the object file’s undefined<br>                       references are bound by the dynamic<br>                       linker when loaded. <em>/<br>#define MH_PREBOUND    0x10        /</em> the file has its dynamic undefined<br>                       references prebound. <em>/<br>#define MH_SPLIT_SEGS  0x20        /</em> the file has its read-only and            只读 segments 和 可读写 segments 分离<br>                       read-write segments split <em>/<br>#define MH_LAZY_INIT  0x40    /</em> the shared library init routine is<br>             to be run lazily via catching memory<br>             faults to its writeable segments<br>             (obsolete) <em>/<br>#define MH_TWOLEVEL 0x80    /</em> the image is using two-level name<br>             space bindings */<br>​<br>/*MH_NO_HEAP_EXECUTION 堆内存不可执行<br>MH_PIE  允许随机的地址空间<br>MH_ALLOW_STACK_EXECUTION  栈内存可执行代码，一般是默认关闭的。<br>MH_NO_HEAP_EXECUTION  堆内存无法执行代码<br>*/</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">## LoadCommands</span><br><span class="line">Headers 之后就是 Load Commands，其占用的内存和加载命令的总数在 Headers 中已经指出。</span><br><span class="line"></span><br><span class="line">load_command 数据结构:</span><br><span class="line">​```</span><br><span class="line">struct load_command &#123;</span><br><span class="line">  uint32_t cmd;   /* type of load command             加载命令类型 */</span><br><span class="line">  uint32_t cmdsize; /* total size of command in bytes 命令的总大小，以字节为单位*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>cmd结构类型:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/* Constants for the cmd field of all load commands, the type */</span><br><span class="line">#define    LC_SEGMENT  0x1 /* segment of this file to be mapped */</span><br><span class="line">#define    LC_SYMTAB   0x2 /* link-edit stab symbol table info */</span><br><span class="line">#define    LC_SYMSEG   0x3 /* link-edit gdb symbol table info (obsolete) */</span><br><span class="line">#define    LC_THREAD   0x4 /* thread */</span><br><span class="line">#define    LC_UNIXTHREAD   0x5 /* unix thread (includes a stack) */</span><br><span class="line">#define    LC_LOADFVMLIB   0x6 /* load a specified fixed VM shared library */</span><br><span class="line">#define    LC_IDFVMLIB 0x7 /* fixed VM shared library identification */</span><br><span class="line">#define    LC_IDENT    0x8 /* object identification info (obsolete) */</span><br><span class="line">#define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */</span><br><span class="line">#define LC_PREPAGE      0xa     /* prepage command (internal use) */</span><br><span class="line">#define    LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */</span><br><span class="line">#define    LC_LOAD_DYLIB   0xc /* load a dynamically linked shared library */</span><br><span class="line">#define    LC_ID_DYLIB 0xd /* dynamically linked shared lib ident */</span><br><span class="line">#define LC_LOAD_DYLINKER 0xe   /* load a dynamic linker */</span><br><span class="line">#define LC_ID_DYLINKER 0xf /* dynamic linker identification */</span><br><span class="line">#define    LC_PREBOUND_DYLIB 0x10  /* modules prebound for a dynamically */</span><br><span class="line">                /*  linked shared library */</span><br><span class="line">#define    LC_ROUTINES 0x11    /* image routines */</span><br><span class="line">#define    LC_SUB_FRAMEWORK 0x12   /* sub framework */</span><br><span class="line">#define    LC_SUB_UMBRELLA 0x13    /* sub umbrella */</span><br><span class="line">#define    LC_SUB_CLIENT   0x14    /* sub client */</span><br><span class="line">#define    LC_SUB_LIBRARY  0x15    /* sub library */</span><br><span class="line">#define    LC_TWOLEVEL_HINTS 0x16  /* two-level namespace lookup hints */</span><br><span class="line">#define    LC_PREBIND_CKSUM  0x17  /* prebind checksum */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * load a dynamically linked shared library that is allowed to be missing</span><br><span class="line"> * (all symbols are weak imported).</span><br><span class="line"> */</span><br><span class="line">#define    LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)</span><br><span class="line"> </span><br><span class="line">#define    LC_SEGMENT_64   0x19    /* 64-bit segment of this file to be</span><br><span class="line">                   mapped */</span><br><span class="line">#define    LC_ROUTINES_64  0x1a    /* 64-bit image routines */</span><br><span class="line">#define LC_UUID        0x1b    /* the uuid */</span><br><span class="line">#define LC_RPATH       (0x1c | LC_REQ_DYLD)    /* runpath additions */</span><br><span class="line">#define LC_CODE_SIGNATURE 0x1d /* local of code signature */</span><br><span class="line">#define LC_SEGMENT_SPLIT_INFO 0x1e /* local of info to split segments */</span><br><span class="line">#define LC_REEXPORT_DYLIB (0x1f | LC_REQ_DYLD) /* load and re-export dylib */</span><br><span class="line">#define    LC_LAZY_LOAD_DYLIB 0x20 /* delay load of dylib until first use */</span><br><span class="line">#define    LC_ENCRYPTION_INFO 0x21 /* encrypted segment information */</span><br><span class="line">#define    LC_DYLD_INFO    0x22    /* compressed dyld information */</span><br><span class="line">#define    LC_DYLD_INFO_ONLY (0x22|LC_REQ_DYLD)    /* compressed dyld information only */</span><br><span class="line">#define    LC_LOAD_UPWARD_DYLIB (0x23 | LC_REQ_DYLD) /* load upward dylib */</span><br><span class="line">#define LC_VERSION_MIN_MACOSX 0x24   /* build for MacOSX min OS version */</span><br><span class="line">#define LC_VERSION_MIN_IPHONEOS 0x25 /* build for iPhoneOS min OS version */</span><br><span class="line">#define LC_FUNCTION_STARTS 0x26 /* compressed table of function start addresses */</span><br><span class="line">#define LC_DYLD_ENVIRONMENT 0x27 /* string for dyld to treat</span><br><span class="line">                    like environment variable */</span><br><span class="line">#define LC_MAIN (0x28|LC_REQ_DYLD) /* replacement for LC_UNIXTHREAD */</span><br><span class="line">#define LC_DATA_IN_CODE 0x29 /* table of non-instructions in __text */</span><br><span class="line">#define LC_SOURCE_VERSION 0x2A /* source version used to build binary */</span><br><span class="line">#define LC_DYLIB_CODE_SIGN_DRS 0x2B /* Code signing DRs copied from linked dylibs */</span><br><span class="line">#define    LC_ENCRYPTION_INFO_64 0x2C /* 64-bit encrypted segment information */</span><br><span class="line">#define LC_LINKER_OPTION 0x2D /* linker options in MH_OBJECT files */</span><br><span class="line">#define LC_LINKER_OPTIMIZATION_HINT 0x2E /* optimization hints in MH_OBJECT files */</span><br><span class="line">#ifndef __OPEN_SOURCE__</span><br><span class="line">#define LC_VERSION_MIN_TVOS 0x2F /* build for AppleTV min OS version */</span><br><span class="line">#endif /* __OPEN_SOURCE__ */</span><br><span class="line">#define LC_VERSION_MIN_WATCHOS 0x30 /* build for Watch min OS version */</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">结构</th>
<th align="left">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">LC_SEGMENT、LC_SEGMENT_64</td>
<td align="left">将 segment 映射到进程的内存空间，</td>
</tr>
<tr>
<td align="center">LC_ID_DYLIB</td>
<td align="left">动态库</td>
</tr>
<tr>
<td align="center">LC_UUID</td>
<td align="left">二进制文件 id，与符号表 uuid 对应，可用作符号表匹配</td>
</tr>
<tr>
<td align="center">LC_LOAD_DYLINKER</td>
<td align="left">启动动态加载器，</td>
</tr>
<tr>
<td align="center">LC_SYMTAB</td>
<td align="left">描述在 __LINKEDIT 段的哪找字符串表、符号表</td>
</tr>
<tr>
<td align="center">LC_CODE_SIGNATURE</td>
<td align="left">代码数字签名等</td>
</tr>
<tr>
<td align="center">LC_THREAD</td>
<td align="left">开启一个MACH线程，但是不分配栈空间</td>
</tr>
<tr>
<td align="center">LC_UNIXTHREAD</td>
<td align="left">开启一个UNIX线程</td>
</tr>
<tr>
<td align="center">LC_ENCRYPTION_INFO</td>
<td align="left">加密二进制文件</td>
</tr>
<tr>
<td align="center">LC_RPATH</td>
<td align="left">程序运行时的查找路径</td>
</tr>
<tr>
<td align="center">LC_VERSION_MIN_IPHONEOS</td>
<td align="left">支持最低的 iOS 版本号</td>
</tr>
<tr>
<td align="center">LC_MAIN</td>
<td align="left">记录了可执行文件的主函数main()的位置</td>
</tr>
</tbody></table>
<p>LC_MAIN加载命令中的Entry Offset字段+基地址（RVA选项下的文件头部地址）= IDA中左侧函数_main的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct entry_point_command &#123;</span><br><span class="line">    uint32_t  cmd;  /* LC_MAIN only used in MH_EXECUTE filetypes */</span><br><span class="line">    uint32_t  cmdsize;  /* 24 */</span><br><span class="line">    uint64_t  entryoff; /* file (__TEXT) offset of main()      main() 函数的文件偏移*/</span><br><span class="line">    uint64_t  stacksize;/* if not zero, initial stack size */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="Segment-amp-Section"><a href="#Segment-amp-Section" class="headerlink" title="Segment &amp; Section"></a>Segment &amp; Section</h2><p>加载数据时，主要加载的就是<code>LC_SEGMET</code>或<code>LC_SEGMENT_64</code>。<code>LC_SEGMENT</code>的数据结构是这样的。这里大部分的数据是用来帮助内核将Segment映射到虚拟内存的</p>
<p>segment_command:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct segment_command &#123; /* for 32-bit architectures */</span><br><span class="line">  uint32_t  cmd;    /* LC_SEGMENT */</span><br><span class="line">  uint32_t  cmdsize;  /* includes sizeof section structs */</span><br><span class="line">  char    segname[16];  /* segment name                     段的名称,常见的段名称有 __PAGEZERO、__LINKEDIT、__TEXT、__DATA*/</span><br><span class="line">  uint32_t  vmaddr;   /* memory address of this segment     段要加载的虚拟内存地址 未偏移），由于 ALSR，程序会在进程加上一段偏移量（slide），真实的地址 = vm address + slide*/</span><br><span class="line">  uint32_t  vmsize;   /* memory size of this segment        段所占的虚拟内存的大小*/</span><br><span class="line">  uint32_t  fileoff;  /* file offset of this segment        段数据所有的文件中的偏移地址*/</span><br><span class="line">  uint32_t  filesize; /* amount to map from the file        段数据的大小*/</span><br><span class="line">  vm_prot_t maxprot;  /* maximum VM protection              页面所需要的最高内存保护*/</span><br><span class="line">  vm_prot_t initprot; /* initial VM protection              页面初始的内存保护*/</span><br><span class="line">  uint32_t  nsects;   /* number of sections in segment      标示了Segment中有多少secetion */</span><br><span class="line">  uint32_t  flags;    /* flags                              段的标志信息*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__PAGEZERO : 可执行文件有的，动态库里没有。这个段开始地址为0（NULL指针指向的位置），是一个不可读、不可写、不可执行的空间，能够在空指针访问时抛出异常。这个段的大小，32位上是 0x4000，64位上是 4G。</span><br><span class="line">__TEXT：代码段，里面主要是存放代码的，该段是可读可执行，但是不可写。</span><br><span class="line">__DATA ：数据段，里面主要是存放数据，该段是可读可写，但不可执行。</span><br><span class="line">__LINKEDIT ：用于存放签名信息，该段是只可读，不可写不可执行。 包含需要被动态链接器使用的信息，包括符号表、字符串表、重定位项表等</span><br><span class="line">__OBJC 包含会被Objective Runtime使用到的一些数据</span><br></pre></td></tr></table></figure>

<p>section:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct section &#123; /* for 32-bit architectures */</span><br><span class="line">  char    sectname[16]; /* name of this section               section的名称，最长 16 字节大小*/</span><br><span class="line">  char    segname[16];  /* segment this section goes in       节区所在的段名*/</span><br><span class="line">  uint32_t  addr;   /* memory address of this section         节区所在的内存地址*/</span><br><span class="line">  uint32_t  size;   /* size in bytes of this section          节区所在的大小*/</span><br><span class="line">  uint32_t  offset;   /* file offset of this section          节区所在文件偏移*/</span><br><span class="line">  uint32_t  align;    /* section alignment (power of 2)       节区的内存对齐边界*/</span><br><span class="line">  uint32_t  reloff;   /* file offset of relocation entries    重定位信息的文件偏移*/</span><br><span class="line">  uint32_t  nreloc;   /* number of relocation entries         重定位条目的个数 */</span><br><span class="line">  uint32_t  flags;    /* flags (section type and attributes)  节区的标志属性  如果是 SG_PROTECTED_VERSION_1，表示该段是经过加密的*/</span><br><span class="line">  uint32_t  reserved1;  /* reserved (for offset or index) */</span><br><span class="line">  uint32_t  reserved2;  /* reserved (for count or sizeof) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="TEXT"><a href="#TEXT" class="headerlink" title="TEXT"></a>TEXT</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_text：主程序代码</span><br><span class="line">__cstring: 硬编码的字符串 去重后的C字符串</span><br><span class="line">const  初始化过的常量</span><br><span class="line">__stubs 桩代码 符号桩。本质上是一小段会直接跳入lazybinding的表对应项指针指向的地址的代码。</span><br><span class="line">__stub_helper：辅助函数。上述提到的lazybinding的表中对应项的指针在没有找到真正的符号地址的时候，都指向这。</span><br><span class="line">__symbolstub1：用于动态链接的存根</span><br><span class="line">unwind_info：用于存储处理异常情况信息</span><br><span class="line">__objc_methname：Objective-C的方法名</span><br><span class="line">__objc_classname：Objective-C的类名</span><br><span class="line">__cstring：硬编码的字符串</span><br><span class="line">_DATA </span><br><span class="line">__data 初始化可变的数据</span><br><span class="line">const 没有初始化过的常量</span><br><span class="line">__objc_imageinfo 镜像信息 ，在运行时初始化时 objc_init，调用 load_images 加载新的镜像到 infolist 中</span><br><span class="line">__lazy_symbol：懒加载，延迟加载节，通过dyld_stub_binder辅助链接</span><br><span class="line">_got：存储引用符号的实际地址，类似于动态符号表</span><br><span class="line">__la_symbol_ptr: lazy-binding的指针表，每个表项中的指针一开始指向stub_helper</span><br><span class="line">__nl_symbol_ptr：非lazy-binding的指针表，每个表项中的指针都指向一个在装载过程中，被动态链机器搜索完成的符号</span><br><span class="line">__mod_init_func：初始化的全局函数地址，在主要之前被调用  初始化函数，在main之前调用</span><br><span class="line">__mod_term_func：结束函数地址    终止函数，在main返回之后调用</span><br><span class="line">__cfstring：Core Foundation用到的字符串（OC字符串）</span><br><span class="line">__objc_classlist 类列表</span><br><span class="line">__objc_classrefs 引用的类</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-Table-amp-String-Table"><a href="#Symbol-Table-amp-String-Table" class="headerlink" title="Symbol Table &amp; String Table"></a>Symbol Table &amp; String Table</h2><p>Symbol 表的头信息是在 LoadCommand 里的 LC_SYMTAB，其中 symoff 表示符号表的偏移。符号表的结构是一个连续的列表，其中的每一项都是一个 struct nlist。 </p>
<p>nlist：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct nlist &#123;</span><br><span class="line">  union &#123;</span><br><span class="line">    uint32_t n_strx;  /*符号名在字符串表中的偏移量  */</span><br><span class="line">  &#125; n_un;</span><br><span class="line">  uint8_t n_type;</span><br><span class="line">  uint8_t n_sect;      /*节的索引*/</span><br><span class="line">  int16_t n_desc;     </span><br><span class="line">  uint32_t n_value;     /*函数对应的地址*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>动态库载入信息 Dynamic Loader Info</li>
<li>入口函数 Function Starts</li>
<li>符号表 Symbol Table</li>
<li>动态库符号表 Dynamic Symbol Table</li>
<li>字符串表 String Table</li>
</ul>
<h1 id="Mach-O执行"><a href="#Mach-O执行" class="headerlink" title="Mach-O执行"></a>Mach-O执行</h1><p>当你点击一个icon启动应用程序的时候，系统在内部大致做了如下几件事：</p>
<ul>
<li>内核（OS Kernel）创建一个进程，分配虚拟的进程空间等等，加载动态链接器。</li>
<li>通过动态链接器加载主二进制程序引用的库、绑定符号。</li>
<li>启动程序</li>
</ul>
<h2 id="内核处理流程"><a href="#内核处理流程" class="headerlink" title="内核处理流程"></a>内核处理流程</h2><h3 id="二进制文件加载过程"><a href="#二进制文件加载过程" class="headerlink" title="二进制文件加载过程"></a>二进制文件加载过程</h3><p>下面列出来在加载二进制文件过程中依次调用的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execve</span><br><span class="line">__mac_execve</span><br><span class="line">exec_activate_image</span><br><span class="line">exec_mach_imgact</span><br><span class="line">load_machfile</span><br><span class="line">parse_machfile</span><br><span class="line">load_dylinker</span><br></pre></td></tr></table></figure>

<h3 id="加载dyld过程"><a href="#加载dyld过程" class="headerlink" title="加载dyld过程"></a>加载dyld过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">load_dylinker&#123;</span><br><span class="line">  get_macho_vnode&#123;</span><br><span class="line">    //读取dyld的fat_header</span><br><span class="line">    vn_rdwr&#123;&#125;</span><br><span class="line">    //读取dyld的mach_header</span><br><span class="line">    vn_rdwr&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  parse_machfile&#123;</span><br><span class="line">    //Map the load commands into kernel memory.</span><br><span class="line">    vn_rdwr&#123;&#125;</span><br><span class="line">    load_segment&#123;</span><br><span class="line">      //这里进行了slide偏移, 并且在对_TEXT segment 进行映射时重新定位了, result-&gt;mach_header,  这个的原理像elf的segment加载时, 把elf-header算在第一个segment上.</span><br><span class="line">      map_segment&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="dyld处理流程"><a href="#dyld处理流程" class="headerlink" title="dyld处理流程"></a>dyld处理流程</h2><p>dyld 的处理过程在 dyld.cpp, 从 LC_MAIN 拿到地址后转到 <code>dyld.cpp/_main()</code> 执行</p>
<p>一切的开始是dyldbootstrap::start这个函数.它去调用了dyld::main函数.这个函数从外部传入Mach-O的header,在dyld::main中,dyld会去设置运行环境,配置相关的环境变量.</p>
<h3 id="处理环境变量"><a href="#处理环境变量" class="headerlink" title="处理环境变量"></a>处理环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  configureProcessRestrictions(mainExecutableMH);</span><br><span class="line">#if __MAC_OS_X_VERSION_MIN_REQUIRED</span><br><span class="line">    if ( gLinkContext.processIsRestricted ) &#123;</span><br><span class="line">    pruneEnvironmentVariables(envp, &amp;apple);</span><br><span class="line">    // set again because envp and apple may have changed or moved</span><br><span class="line">    setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">#endif</span><br><span class="line">  &#123;</span><br><span class="line">    checkEnvironmentVariables(envp);</span><br><span class="line">    defaultUninitializedFallbackPaths(envp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">configureProcessRestrictions //对 ios 和 osx 做了区分, ios 默认不支持任何环境变量</span><br><span class="line">|</span><br><span class="line">checkEnvironmentVariables //检查环境变量, 之后调用下一个函数做处理</span><br><span class="line">|</span><br><span class="line">processDyldEnvironmentVariable //处理环境变量, 设置gLinkContext</span><br></pre></td></tr></table></figure>
<p>这里有一个关键的过程 setContext(mainExecutableMH, argc, argv, envp, apple); 设置上下文需要使用到的全局变量.</p>
<h3 id="解析macho执行文件"><a href="#解析macho执行文件" class="headerlink" title="解析macho执行文件"></a>解析macho执行文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">  </span><br><span class="line">    // instantiate ImageLoader for main executable</span><br><span class="line">    sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">    gLinkContext.mainExecutable = sMainExecutable;</span><br><span class="line">    gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line">从 instantiateFromLoadedImage 开始解析</span><br><span class="line"></span><br><span class="line">instantiateFromLoadedImage</span><br><span class="line">// 检查文件格式, 加载主可执行文件, 记录该image到全局环境变量</span><br><span class="line">instantiateFromLoadedImage:dyld.cpp</span><br><span class="line">&#123;</span><br><span class="line">  // 处理加载命令, 根据加载命令处理加载可执行文件</span><br><span class="line">  ImageLoaderMachO::instantiateMainExecutable:ImageLoaderMachO.cpp</span><br><span class="line">  &#123; </span><br><span class="line">    // 处理, 区分加载命令</span><br><span class="line">    ImageLoaderMachO::sniffLoadCommands:ImageLoaderMachO.cpp</span><br><span class="line">    // 根据加载命令, 开始加载可执行文件  ImageLoaderMachOCompressed::instantiateMainExecutable:ImageLoaderMachOCompressed.cpp</span><br><span class="line">    &#123;</span><br><span class="line">      // 创建ImageLoaderMachOCompressed对象</span><br><span class="line">      ImageLoaderMachOCompressed::instantiateStart:ImageLoaderMachOCompressed.cpp</span><br><span class="line">      // 根据加载命令填充ImageLoaderMachOCompressed对象</span><br><span class="line">      ImageLoaderMachOCompressed::instantiateFinish:ImageLoaderMachOCompressed.cpp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 记录image到全局变量</span><br><span class="line">  addImage:dyld.cpp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载共享动态库"><a href="#加载共享动态库" class="headerlink" title="加载共享动态库"></a>加载共享动态库</h3><p>在环境变量配置完毕后,dyld会去加载共享缓存</p>
<p>加载的步骤是先通过checkShareRegionDisable函数检查是否被关闭,iOS下必须开启共享缓存,如果没有被禁用,那么就会调用mapSharedCache函数去加载,当然实际加载是在该函数内调用的loadDyldCache函数,加载共三种,fast Path(已经加载的不需要再加载),slow path(第一次调用则去加载.mapCacheSystemWide),还有一种是模拟器下(simulator)的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">​</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide,</span><br><span class="line">​</span><br><span class="line">int argc, const char* argv[], const char* envp[], const char* apple[],</span><br><span class="line">​</span><br><span class="line">uintptr_t* startGlue)</span><br><span class="line">​</span><br><span class="line">&#123;</span><br><span class="line">​</span><br><span class="line"> [...]</span><br><span class="line">​</span><br><span class="line">// load shared cache</span><br><span class="line">​</span><br><span class="line"> checkSharedRegionDisable();</span><br><span class="line">​</span><br><span class="line">#if DYLD_SHARED_CACHE_SUPPORT</span><br><span class="line">​</span><br><span class="line">if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">​</span><br><span class="line"> mapSharedCache(); // 判断是否存在共享动态库, 如果存在直接使用, 否则进行加载, gLinkContext记录共享库地址</span><br><span class="line">​</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">​</span><br><span class="line">dyld_kernel_image_info_t kernelCacheInfo;</span><br><span class="line">​</span><br><span class="line"> bzero(&amp;kernelCacheInfo.uuid[0], sizeof(uuid_t));</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.load_addr = 0;</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.fsobjid.fid_objno = 0;</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.fsobjid.fid_generation = 0;</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.fsid.val[0] = 0;</span><br><span class="line">​</span><br><span class="line"> kernelCacheInfo.fsid.val[0] = 0;</span><br><span class="line">​</span><br><span class="line"> task_register_dyld_shared_cache_image_info(mach_task_self(), kernelCacheInfo, true, false);</span><br><span class="line">​</span><br><span class="line"> &#125;</span><br><span class="line">​</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>当共享缓存被加载后,接下来,dyld就会继续在main函数中加载我们的主程序也就是我们的可执行文件。我们在方法中找到instantiateFromLoadedImage这个函数,在这个函数里,dyld会实例化我们的可执行文件。它实际上是通过我们传进来的machO的header判断当前cpu是否支持当前我们的machO的架构.如果支持则调用instantiateMainExecutable函数去实例化我们的可执行文件,并添加到imageList中。</p>
<p>当然可执行文件的实例化是在instantiateMainExecutable函数内部实现的,在该函数内部先调用了sniffLoadCommands,这个函数通过读取loadCommand段内的信息去加载。在sniffLoadCommands中严格判断了loadCommands的条数,不能超过255条,依赖的库不能超过4095个。最后该函数会修改Compress值,外部的instantiateMainExecutable函数会通过这个值来决定加载主程序的方式。在主程序被实例化加载后,接下来dyld就会继续在main函数中去加载我们插入的动态库,具体加载函数在loadInsertedDylib里进行。</p>
<h3 id="加载DYLD-INSERT-LIBRARIES的动态库"><a href="#加载DYLD-INSERT-LIBRARIES的动态库" class="headerlink" title="加载DYLD_INSERT_LIBRARIES的动态库"></a>加载DYLD_INSERT_LIBRARIES的动态库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">    // load any inserted libraries</span><br><span class="line">    if  ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) &#123;</span><br><span class="line">      for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) </span><br><span class="line">        loadInsertedDylib(*lib);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>loadInsertedDylib：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">loadInsertedDylib:dyld.cpp</span><br><span class="line">&#123;</span><br><span class="line">  load:dyld.cpp</span><br><span class="line">  &#123;</span><br><span class="line">    loadPhase0:dyld.cpp</span><br><span class="line">    loadPhase1:dyld.cpp</span><br><span class="line">    loadPhase2:dyld.cpp</span><br><span class="line">    loadPhase3:dyld.cpp</span><br><span class="line">    loadPhase4:dyld.cpp</span><br><span class="line">    loadPhase5:dyld.cpp</span><br><span class="line">    loadPhase5check:dyld.cpp</span><br><span class="line">    loadPhase5load:dyld.cpp</span><br><span class="line">    loadPhase5stat:dyld.cpp</span><br><span class="line">    loadPhase5load:dyld.cpp</span><br><span class="line">    loadPhase5open:dyld.cpp</span><br><span class="line">    loadPhase6</span><br><span class="line">    &#123;</span><br><span class="line">      checkandAddImage::dyld.cpp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加载依赖动态库"><a href="#加载依赖动态库" class="headerlink" title="加载依赖动态库"></a>加载依赖动态库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">    int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">    uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line">    link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">    sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">    if ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">      gLinkContext.bindFlat = true;</span><br><span class="line">      gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从 link 函数开始加载依赖动态库，在link方法中不光是链接我们的插入动态库,还会在函数内通过recursiveLoadLibraries函数循环加载我们的所有的依赖库.在加载后再Rebase每一个都添加上偏移值以得到真正的依赖库的地址也就是重定位。在链接定位后,还是在这个函数中继续对依赖库进行符号绑定,弱绑定等一系列操作,当这些都做完了主程序也就被加载链接完成。跟主程序加载链接一致,dyld当得知插入依赖库长度大于0会遍历加载链接这些库.链接完毕后就会将主程序与这些库绑定起来。</p>
<p>link</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">link:dyld.cpp</span><br><span class="line">&#123;</span><br><span class="line">  ImageLoader::link:ImageLoader.cpp</span><br><span class="line">  &#123;</span><br><span class="line">    ImageLoader::recursiveLoadLibraries:ImageLoader.cpp</span><br><span class="line">    &#123;</span><br><span class="line">      ImageLoaderMachO::doGetDependentLibraries:ImageLoader.cpp</span><br><span class="line">      libraryLocator:dyld.cpp</span><br><span class="line">      &#123;</span><br><span class="line">        load:dyld.cpp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这些依赖库的操作全部完成,就会调用initializeMainExecutable函数来初始化我们的主程序!</p>
<p>接下来会调用loadImages函数</p>
<p>load_images调用了call_load_methods，函数内就是循环调用我们的Objc类的load方法。接下来dyld就会调用doModInitFunctions这个函数会调用执行我们程序的特殊函数,比如全局的C++的构造方法.其实实质上就是dyld会读取Mach-O里DATA段中的init_func这个字段进行调用里面的函数。</p>
<p>最终一系列的操作完毕后,dyld就会去查找我们主程序的入口,对应我们Mach-O的LC_MAIN.在找到后返回一个result结果,也就调起了我们主程序的main函数,结束掉dyld_start整个流程。</p>
<p>参考文献: </p>
<p>[1]<a target="_blank" rel="noopener" href="https://amywushu.github.io/2017/02/21/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%A7%A3%E8%AF%BB-Mach-O-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.html">解读Mach-O文件格式</a></p>
<p>[2]<a target="_blank" rel="noopener" href="http://turingh.github.io/2016/03/07/mach-o%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/#">mach-o格式分析</a></p>
<p>[3]<a target="_blank" rel="noopener" href="https://www.exchen.net/mach-o-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90.html#Mach_Header">Mach-O 文件格式解析</a></p>
<p>[4]<a target="_blank" rel="noopener" href="https://juejin.im/post/5ab47ca1518825611a406a39">探秘 Mach-O 文件</a></p>
<p>[5]<a target="_blank" rel="noopener" href="http://www.bubuko.com/infodetail-2243416.html">http://www.bubuko.com/infodetail-2243416.html</a></p>
<p>[6]<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8498cec10a41">https://www.jianshu.com/p/8498cec10a41</a></p>
<p>[7]<a target="_blank" rel="noopener" href="https://satanwoo.github.io/2017/06/13/Macho-1/">https://satanwoo.github.io/2017/06/13/Macho-1/</a></p>
<p>[8]<a target="_blank" rel="noopener" href="https://jmpews.github.io/2017/02/27/darwin/PWN%E4%B9%8Bmacho%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/">https://jmpews.github.io/2017/02/27/darwin/PWN%E4%B9%8Bmacho%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</a></p>
<p>[9]<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7ad7b3ba7985">https://www.jianshu.com/p/7ad7b3ba7985</a></p>
<p>[10]<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4d86de908721">https://www.jianshu.com/p/4d86de908721</a></p>
<p>[11]<a target="_blank" rel="noopener" href="https://juejin.im/post/5c8e6f5c518825458b3ba6a4">https://juejin.im/post/5c8e6f5c518825458b3ba6a4</a>这个写的比较清楚</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>赞助博主的人类改造计划</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="8Biiit 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="8Biiit 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>8Biiit
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://8biiit.github.io/2019/08/09/Mach-O%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/" title="Mach-O文件详解">http://8biiit.github.io/2019/08/09/Mach-O文件详解/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
              <a href="/tags/Mach-O/" rel="tag"># Mach-O</a>
              <a href="/tags/Mac-OS/" rel="tag"># Mac OS</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
            </div>
            <div class="post-nav-item">
                <a href="/2019/08/12/Frida/" rel="next" title="Frida在iOS平台进行OC函数hook的常用方法">
                  Frida在iOS平台进行OC函数hook的常用方法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">8Biiit</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"8biiit","repo":"8biiit.github.io","client_id":"8c5e1f409f422d4e10f6","client_secret":"dd74067b3e311d6338eb117e3711361d6769df41","admin_user":"8biiit","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"785ecf894d74d15ea1a99005bd74e4e5"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
